[{"title":"第三章第六节 TCP的传输连接管理","url":"/cn/cn-ch3-par6.html","content":"\n## 三次握手\n\n<div style=\"width:56%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n&nbsp;\n\nQ：为什么需要第三次握手?\n\nA：TCP作为可靠传输，收到报文后都要向发送方回复ACK回执。根据这个机制，TCP建立连接应该需要4次握手：\n\n(1)客户端向服务器端发送请求连接的SYN报文；\n\n(2)服务器端向客户端回复确认接收的ACK报文；\n\n(3)服务器端向客户端发送允许连接的SYN报文；\n\n(4)客户端向服务器端回复确认接收的ACK报文；\n\n然而，第(2)次握手与第(3)次握手可以合并到一个报文中，于是形成了熟知的三次握手。\n\n## 四次挥手\n\n<div style=\"width:60%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\n此时为什么第(2)次挥手与第(3)次挥手不能合并，是因为服务器端收到客户端请求释放连接的报文后，可能还需要处理一些工作，因此只能先发送确认收到报文，然后等工作处理完之后，向客户端发送允许释放连接的报文，客户端收到此报文后回复确认收到的报文后即可释放此TCP连接，服务器端收到客户端确认收到的回复报文后，释放此TCP连接，进入LISTEN状态。\n\n## TCP的有限状态机\n\n<div style=\"width:56%;margin:auto\">{% asset_img 43.png pic43 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第三章第五节 TCP流量与拥塞控制","url":"/cn/cn-ch3-par5.html","content":"\n## 流量控制\n\n利用滑动窗口实现流量控制\n\n<div style=\"width:56%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## TCP拥塞控制\n\n### TCP拥塞控制的手段\n\n* 慢开始。TCP连接刚刚建立时，由小到大逐渐增大发送窗口。\n* 拥塞避免。当拥塞窗口增大到一定程度时，将其增速放缓。\n* 快重传。收到数据后立即发送已按顺序收到的报文的确认。若发送方连续收到3个重复确认，则要对确认报文之后的报文进行重传。\n* 快恢复。调整慢开始门限为拥塞窗口大小/2，拥塞窗口大小为慢开始门限，然后执行拥塞避免算法。\n\n### TCP拥塞控制流程\n\nTCP使用上述四种手段实现拥塞控制的流程图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 40.png pic40 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第三章第四节 可靠传输的工作原理及其TCP实现","url":"/cn/cn-ch3-par4.html","content":"\n## 可靠传输的工作原理\n\n### 停止等待协议\n\n顾名思义，在发送分组后等待确认收到，之后再发送下一分组。如果设定时间内没有收到确认，则将此分组重传。因此TCP在发送完一个分组后，必须保留此分组的副本直到收到确认。由于没有收到确认有两种可能：(1)发送分组丢失或出错；(2)对方收到分组，且确认无误，但是发送的确认丢失；(3)由于网络阻塞，收到确认迟到了；不管是哪种可能，发送方都会重传分组。对于(1)，接收方会接收分组并发送确认；而对于(2)，接收方直接丢弃这个重复分组，但是仍然发送确认分组。对于(3)，发送方收到重复的确认后直接丢弃。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n然而，停止等待协议的信道利用率极其低，下面介绍连续ARQ协议与滑动窗口协议。\n\n### 连续ARQ协议\n\n**发送**：位于窗口内的分组可以全部发送出去而不用等待前一组的接收确认。\n\n**累积确认**：接收方不需要对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送接收确认，这就代表到这个分组为止的所有分组均已收到。\n\n**窗口滑动**：发送方收到确认后，将窗口滑动到确认分组的下一分组。\n\n连续ARQ协议工作例子如下。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n## TCP可靠传输的实现\n\n### 以字节为单位的滑动窗口\n\n&nbsp;\n\n### 超时重传时间的选择\n\nTCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间。这两者之差为该报文段的往返时间RTT，TCP保留一个加权平均往返时间RTTS<-(1-a)×RTTS+a×RTT。a建议为1/8。超时重传时间RTO=RTTS+4×RTTD，RTTD为RTT偏差的加权平均值。而重传的报文，其往返时间无法准确计算，于是Karn提出：重传报文的RTT不加入RTTS的计算，而这种方法又不能及时应对网络阻塞的变化(如果网络阻塞，导致RTT变大，而重传报文的RTT不加入RTTS的计算，于是超时重传时间得不到及时更新)，于是Karn算法修正为报文段每重传一次，就将超时重传时间增加一倍。","tags":["backend"],"categories":["cn"]},{"title":"第三章第三节 传输控制协议TCP概述","url":"/cn/cn-ch3-par3.html","content":"\n## TCP主要特点\n\n* TCP是面向连接的传输层协议，即应用程序在使用TCP协议前，必须先建立TCP连接；\n* TCP连接只能是一对一；\n* TCP提供可靠交付。通过TCP协议传送的数据，可无差错、不丢失、不重复、按序到达；\n* TCP提供全双工通信。运行通信双方的应用进程在(建立连接之后，释放连接以前的)任何时候都可以发送数据，通信双方既是发送方也是接收方，TCP连接的两端都设有发送缓存与接收缓存；\n* 面向字节流。TCP将应用程序交付下来的数据仅仅看作一连串无结构的字节流。\n\n## TCP连接\n\nTCP连接有两个端点，这个端点就是套接字，可使用`IP:Port`唯一区分。\n\n## TCP头部\n\nTCP头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n* 确认号。若确认号为N，则表明从起始序号到N-1的TCP字节流已经按顺序收到。\n* 数据偏移。即TCP头部长度。\n* 确认ACK。仅当确认ACK为1时确认号字段才有效，TCP规定：在连接建立后，所有传送的报文段都必须将ACK置1。\n* 复位RST。RST为1表明TCP连接出现严重差错，必须立即释放连接。\n* SYN位。在连接建立时用来同步序号，SYN=1且ACK=0用来请求连接，SYN=1且ACK=1表明接受连接；SYN位置1标志建立连接阶段的报文。\n* FIN位。FIN位置1表明向对方提出终止连接。\n* 窗口。用来告知通信另一方，自本报文段头部的确认号算起，允许其发送的数据量(以字节为单位)。\n* 选项。长度可变，包括最大报文段长度、窗口扩大选项、时间戳、选择确认等。","tags":["backend"],"categories":["cn"]},{"title":"第三章第二节 用户数据报协议UDP","url":"/cn/cn-ch3-par2.html","content":"\n## UDP概述\n\nUDP只在IP协议上增加了复用/分用与差错检测功能。UDP具有无连接、尽最大努力交付、面向报文(应用层交给UDP多长的报文，UDP就照样发送)、无拥塞控制(即使网络出现拥塞，源主机发送数据的速率不变)、支持一/多对一/多、头部开销小的特点。\n\n## UDP头部\n\nUDP头部格式如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n若接收方UDP发现收到的报文目的端口号不正确，则丢弃该报文，并且向源主机发送ICMP端口不可达差错报文。UDP的校验和是将首部与数据部分一起校验。","tags":["backend"],"categories":["cn"]},{"title":"第三章第一节 传输层协议概述","url":"/cn/cn-ch3-par1.html","content":"\n## 进程间通信\n\n传输层是向应用进程间提供端到端的逻辑通信。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n## 传输层两个主要协议\n\n传输层的两个主要协议：用户数据报协议UDP与传输控制协议TCP。下表是使用TCP或UDP的应用层协议。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n## 传输层的端口\n\n标志本计算机应用层的各个进程与传输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。传输层的端口号分为下面两类。\n\n**服务端使用的端口号**：分为熟知端口号与登记端口号。熟知端口号(0-1023)可在`www.iana.org`查到。如下表是一些常用的熟知端口号。\n\n<div style=\"width:72%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n登记端口号(1024-49151)被没有熟知端口号的应用程序使用，使用前需在IANA登记。\n\n**客户端使用的端口号**：仅在客户进程运行时才动态选择(49152-65535)。","tags":["backend"],"categories":["cn"]},{"title":"第二章 网络层","url":"/cn/cn-ch2.html","content":"\n[第一节 网际协议IP](https://chu-kangming.gitee.io/cn/cn-ch2-par1.html)\n\n[第二节 划分子网与构造超网](https://chu-kangming.gitee.io/cn/cn-ch2-par2.html)\n\n[第三节 网际控制报文协议ICMP](https://chu-kangming.gitee.io/cn/cn-ch2-par3.html)\n\n[第四节 互联网的路由选择协议](https://chu-kangming.gitee.io/cn/cn-ch2-par4.html)\n\n[第五节 IPv6](https://chu-kangming.gitee.io/cn/cn-ch2-par5.html)\n\n[第六节 IP多播](https://chu-kangming.gitee.io/cn/cn-ch2-par6.html)\n\n[第七节 VPN与NAT](https://chu-kangming.gitee.io/cn/cn-ch2-par7.html)\n\n[第八节 多协议标记交换MPLS](https://chu-kangming.gitee.io/cn/cn-ch2-par8.html)","tags":["backend"],"categories":["cn"]},{"title":"超椭圆曲线(九)超椭圆曲线密码系统的实现","url":"/tech/Hyper-ch9.html","content":"\nDiffie-Hellman密钥交换[10]是一个协议，两个实体$A$和$B$可以通过公共通道上的一系列传输，就一个秘密的加密密钥达成一致。方法如下。$A$和$B$首先选择一个(乘式写)有限Abel群$G$和某个元素$\\alpha\\in G$。然后$A$选择一个随机整数$a$且将$\\alpha^{a}$传输给$B$，$B$反过来选择一个随机整数$b$且将$\\alpha^{b}$传输给$A$。这样$A,B$均能确定$\\alpha^{ab}$，作为他们的共享密钥。\n\n窃听者$C$监控$A$与$B$之间的传输将会得到$G,\\alpha,\\alpha^{a},\\alpha^{b}$，选择参数$G$和$\\alpha$，使$C$确定$\\alpha^{ab}$在计算上是不可行的。事实上，若$C$可以计算$a$或者$b$，则$C$可以确定$\\alpha^{ab}$。给定$\\alpha,\\beta=\\alpha^{a}$确定$a$的问题称为离散对数问题。当限制在$[0,order(\\alpha)-1]$范围内$a$是唯一的，称为以$\\alpha$为底，$\\beta$的对数。确定$\\alpha^{ab}$与计算$G$上的离散对数问题是否等价还没有定论，在其他安全依赖于离散对数问题的加密协议中，有ElGamal公钥加密和数字签名方案[12]，以及最近采用的美国数字签名标准[29]。\n\n最好的算法以解决离散对数问题在任意$G$组指数平方根攻击(见McCurley[24]),有一个运行时间的平方根成比例最大的质数因子$l$, $l$是$\\alpha$的阶。因此，如果选择$G$和$\\alpha$，使$l$有一个大的素数因子，那么这些攻击就可以避免。\n\n令$F_{q}$代表阶为$q$的有限域，再令$q=p^{m}$其中$p$是$F_{q}$的特征，Diffie与Hellman最初提议$G=F_{q}^{*}$，$F_{q}$的乘法群，作为实现Diffie-Hellman密钥交换协议的候选。有一些已知的随机次指数时间算法可用于计算$F_{q}$中的对数。关于$q$为质数的情形，请参见Coppersmith，Odlyzko和Schroeppel [9]和Gordon [17]，对于$p=2$的情况，请参见Odlyzko [30]，有关一般情况，请参见Adleman和DeMarrais [1]。这些算法是对上一段中提到的通用算法的渐进改进。 出于加密目的，我们对相应离散对数问题的次指数算法未知的群感兴趣。另外，为了有效和实际地实施，群操作应该相对容易地应用。 对于这样的群，在有限域上定义的超椭圆曲线的雅可比行列式就是一种可能性。\n\n为了使用超椭圆曲线实现离散对数密码系统，必须选择合适的曲线$C$和有限域$K$。 所选曲线和域的理想属性包括：\n\n* 底层有限域K中的算术应该有效地实现； 特征2的有限域似乎是最有吸引力的选择；\n* $C$的行列式$J(K)$的阶，表示为$\\sharp J(K)$，应该能被大素数整除。给定当前的计算技术，一个安全的要求为$\\sharp J(K)$可被至少45位的十进制素数$r$整除。另外，为了避免约化攻击Frey and Ruck [13]，它将$J(K)$中的离散对数问题简化为扩展域$K=F_{q}$中的离散对数问题。对所有的$F_{q^{k}}$中的离散对数可解的小整数$k$，$r$应无法整除$q^{k}-1$($1\\leq k\\leq 2000/(\\log_{2}q)$满足)。\n\n接下来描述一种用于选择超椭圆曲线并计算$\\sharp J(K)$的技术。令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，由方程$v^{2}+h(u)v=f(u)$给定，令$F_{q^{n}}$代表$F_{q}$的$n$次扩展，且令$N_{n}$代表有限Abel群$J(F_{q^{n}})$的阶，$C$上的$F_{q^{n}}$-有理点的个数定义为$M_{n}$。与$C$关联的是zeta函数，定义如下：\n\n**定义53**(zeta函数)令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，再令$M_{r}=\\sharp C(F_{q^{r}}),r\\geq 1$，$C$的zeta函数是幂级数：\n$$\nZ_{C}(t)=exp\\left(\\sum_{r\\geq 1}M_{r}\\frac {r} {t^{r}}\\right)\n$$\n以下是有关zeta函数的一些众所周知的事实(例如，参见[23])。\n\n**定理54**(zeta函数的性质)令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$Z_{C}(t)$为$C$的zeta函数。\n\n$\\textrm{(i)}\\ Z_{C}(t)\\in Z(t)$。更确切地说，我们有：\n$$\nZ_{C}(t)=\\frac {P(t)} {(1-t)(1-qt)}\\tag{9}\n$$\n其中$P(t)$为次数为$2g$的整系数多项式；此外，$P(t)$有如下形式：\n$$\nP(t)=1+a_{1}t+\\cdots+a_{g}t^{g}+qa_{g-1}t^{g+1}+q^{2}a_{g-2}t^{g+2}+\\cdots+q^{g-1}a_{1}t^{2g-1}+q^{g}t^{2g}\\tag{10}\n$$\n$\\textrm{(ii)}\\ P(t)$分解为：\n$$\nP(t)=\\prod_{i=1}^{g}(1-\\alpha_{i}t)(1-\\bar\\alpha_{i}t)\\tag{11}\n$$\n\n其中每个$\\alpha_{i}=\\sqrt{q}$，$\\bar\\alpha_{i}$为$\\alpha_{i}$的共轭。\n\n$\\textrm{(iii)}\\ N_{n}=\\sharp J(F_{q^{n}})$满足：\n$$\nN_{n}=\\prod_{i=1}^{g}|1-\\alpha_{i}^{n}|^{2}\\tag{12}\n$$\n为了计算$N_{n}$，由它满足$\\textrm{(i)}$确定$P(t)$的系数$a_{1},\\cdots,a_{g}$，从而确定$P(t)$；$\\textrm{(ii)}$分解$P(t)$因此可以确定$\\alpha_{i}$；$\\textrm{(iii)}$通过等式$(12)$计算$N_{n}$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n&nbsp;\n\n**推论55** 令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$N_{n}=\\sharp J(F_{q^{n}})$，则$(q^{n/2}-1)^{2g}\\leq N_{n}\\leq (q^{n/2}+1)^{2g}$；从而$N_{n}\\approx q^{ng}$。\n\n[原文链接](http://www.math.uwaterloo.ca/~ajmeneze/publications/hyperelliptic.pdf)\n\n翻译不当之处还请批评指正，另外文中有些证明等我看明白了再翻译...","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(八)约化因数相加","url":"/tech/Hyper-ch8.html","content":"\n令$C$是定义在有限域$K$上属性为$g$的一个超椭圆曲线，令$J$是$C$的雅克比行列式，令$P(x,y)\\in C$，令$\\sigma$是$\\bar K$到$K$的一个自同构，则$P^{\\sigma}=(x^{\\sigma},y^{\\sigma})$同样是$C$上的一个点。\n\n**定义48**(因数的定义域)若一个因数$D=\\sum m_{P}P$有$D^{\\sigma}=\\sum m_{P}P^{\\sigma}$能对任意$\\bar K$到$K$的自同构$\\sigma$均与$D$相等。\n\n注意到如果$D$定义在$K$上，这并不代表$D$的支撑集中的每个点均为$K$有理点，一个主因数定义在$K$上当且仅当它是一个有$K$中系数的有理函数的因数，$J$中所有除数类的集合$J(K)$有一个定义在$K$上的代表，是$J$的一个子群。$J(K)$的每个元素都有一个唯一的表示形式，即约化因数$div(a, b)$，其中$a,b\\in K[u],deg(a)\\leq g,deg(b)<deg(a)$，因此$J(K)$事实上是一个有限Abel群。本节介绍一种在该组中元素相加的有效算法。\n\n令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个在$K$上定义的约化因数(则$a_{1},b_{1},a_{2},b_{2}\\in K[u]$)。算法1寻找一个半约化因数$D=\\textrm{div}(a,b),a,b\\in K[u]$使得$D\\sim D_{1}+D_{2}$。算法2将$D$约化为等价的约化因数$D^{'}$。\n\n算法1,2由Koblitz [20]实现，其推广了Cantor[5]的早期算法—假定$h(u)=0$且$char(K)\\neq 2$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n**定理49**(算法1的有效性)令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个半约化因数，令$a,b$如式$(4),(5)$定义，则$D=\\textrm{div}(a,b)$是一个半约化因数且$D\\sim D_{1}+D_{2}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n算法2：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:56%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n**定理51**(算法2的有效性)令$D=\\textrm{div}(a,b)$是一个半约化因数，则由算法2返回的因数$D^{'}=\\textrm{div}(a^{'},b^{'})$是约化的且$D^{'}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n注意，算法1和算法2中的所有计算都发生在域$K$本身(而不是$K$的任何适当扩展)。在算法1中，若$deg(a_{1})\\leq g,deg(a_{2})\\leq g$则$deg(a)\\leq 2g$。此时，算法2对步骤1的迭代次数最多为$[g/2]$。","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(七)约化因数","url":"/tech/Hyper-ch7.html","content":"\n本节定义了约化因数的概念，并证明了商群的每个陪集$\\bf{J=D^{0}/P}$只有一个约化因数，因此，我们可以用它的约化因数来识别每个陪集。\n\n**定义44**(约化因数)令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，若$\\sum m_{i}\\leq g$($g$是$C$的属性)，则$D$称为一个约化因数。\n\n**定义45**(因数的范数)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的范数定义为：$|D|=\\sum_{P\\in C\\setminus {\\infty}}m_{P}$。\n\n注意到给定一个因数$D\\in \\bf{D^{0}}$，在引理39的证明中所描述的操作会产生一个半约化因数$D_{1}$使得$D_{1}\\sim D$且$D_{1}\\leq D$。\n\n**引理46** 令$R\\in \\bar K(C)^{*}$，若$R$没有有限的极点，则$R$是一个多形式函数。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n**定理47 **对任一因数$D\\in \\bf{D^{0}}$存在一个唯一的约化因数$D_{1}$使得$D_{1}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(六)半约化因数的表示","url":"/tech/Hyper-ch6.html","content":"\n本节描述雅可比矩阵半约化因子的多项式表示。它引出了一个有效的算法来添加雅可比矩阵的元素。\n\n**引理40** 令$P(x,y)$是$C$上一个平凡点，再令$R\\in \\bar K(C)$是一个在$P$处没有极点的有理函数，则对任意的$k\\geq 0$，存在唯一的元素$c_{0},\\cdots,c_{k}\\in\\bar K$与$R_{k}\\in \\bar K(C)$使得$R=\\sum_{i=0}^{k} c_{i}(u-x)^{i}+(u-x)^{k+1}R_{k}$，其中$R_{k}$在$P$处没有极点。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n**引理41** 令$P(x,y)$是$C$上一个平凡点，则对任一$k\\geq 1$，存在唯一的多项式$b_{k}(u)\\in \\bar K[u]$使得：\n\n$\\textrm{(i)}\\ deg_{u} b_{k}<k$；\n\n$\\textrm{(ii)}\\ b_{k}(x)=y$且$b_{k}^{2}(u)+b_{k}(u)h(u)\\equiv f(u)\\ \\textrm{mod}\\ (u-x)^{k}$；\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n下面的定理说明了半约化因数如何可以表示为两个多项式函数的因数的最大公约数。\n\n**定理42** 令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，其中$P_{i}(x_{i},y_{i})$，令$a(u)=\\prod (u-x_{i})^{m_{i}}$。令$b(u)$是唯一满足如下条件的多项式：\n$\\textrm{(i)}\\ deg(b)<deg(a)$；\n\n$\\textrm{(ii)}$对所有$m_{i}\\neq 0$的$i$都有$b(x_{i})=y_{i}$；\n\n$\\textrm{(iii)}\\ a(u)|[b^{2}(u)+b(u)h(u)-f(u)]$，则$D=\\textrm{gcd}(div(a(u)),div(b(u)-v))$。\n\n注：$\\textrm{gcd}(div(a(u)),div(b(u)-v))$通常缩写为$div(a(u),b(u)-v)$或者，更简单：$div(a,b)$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n注意到零因数表示为$div(1,0)$，下一个结果来自定理42的证明。\n\n**引理43** 令$a(u),b(u)\\in \\bar K[u]$使得$deg(b)<deg(a)$，若$a|(b^{2}+bh-f)$则$div(a,b)$是半约化的。","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(五)因数","url":"/tech/Hyper-ch5.html","content":"\n本节介绍因数的基本性质及超椭圆曲线的雅可比矩阵。\n\n**定义31**(因数 , 次数 , 阶数)因数D是C中的点的形式和：$D=\\sum_{P\\in C}m_{P}P ,m_{P}\\in Z$，其中只有有限的$m_{P}$是非零的。D的次数，记为$degD$，是$\\sum_{P\\in C}m_{P}$。$D$在$P$处的阶数$m_{P}$，记$ord_{P}(D)=m_{P}$。\n所有因数的集合记为D，在加法规则下形成一个可加群：$\\sum_{P\\in C}m_{P}P+\\sum_{P\\in C}n_{P}P=\\sum_{P\\in C}(m_{P}+n_{P})P$。\n所有次数为$0$的因数组成的集合，记为$\\bf{D^{0}}$，是$D$的子群。\n\n**定义32**(因数的公约数)令$D_{1}=\\sum_{P\\in C}m_{P}P , D_{2}=\\sum_{P\\in C}n_{P}P$为两个因子，$D_{1}$与$D_{2}$的最大公约数定义为：$gcd(D_{1},D_{2})=\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P})P-(\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P}))\\infty$(注意到$gcd(D_{1},D_{2})\\in \\bf{D^{0}}$)。\n\n**定义33**(有理函数的因数)令$R\\in \\bar K(C)^{*}$。$R$的因数是$div(R)=\\sum_{P\\in C}(ord_{P}R)P$，注意到若$R=G/H$则$div(R)=div(G)-div(H)$。定理29表明有理函数的因数确实是一个有限形式和并且次数为0。\n\n**例34**若$P(x,y)$是$C$上的一个平凡点，则$div(u-x)=P+\\bar P-2\\infty$，若$P(x,y)$是$C$上的一个特殊点，则$div(u-x)=2P-2\\infty$。\n\n**引理35**令$G\\in \\bar K[C]^{*} , div(G)=\\sum_{P\\in C}m_{P}P$，则$div(\\bar G)=\\sum_{P\\in C}m_{P}\\bar P$。\n\n证明：由引理28易得。\n\n若$R_{1} , R_{2}\\in \\bar K(C)^{*}$则由引理25可得$div(R_{1}R_{2})=div(R_{1})+div(R_{2})$。\n\n**定义36**若对某些有理函数$R\\in \\bar K(C)^{*}$，$D=div(R)$，则因数$D\\in \\bf{D^{0}}$称为主因数。所有主因数组成的集合，记为$\\bf{P}$，是$\\bf{D^{0}}$的子群；商群$J=\\bf{D^{0}/P}$称为曲线$C$的雅可比矩阵。若$D_{1} , D_{2}\\in \\bf{D^{0}}$，当$D_{1}-D_{2}\\in \\bf{P}$时我们记为$D_{1}\\sim D_{2}$，$D_{1}$与$D_{2}$被称为等价因数。\n\n**定义37**(因数的支持)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的支持是集合$\\textrm{supp}(D)=\\{P\\in C|m_{P}\\neq 0\\}$。\n\n**定义38**(半约化因数)半约化因数是形如$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$，其中每个$m_{i}\\geq 0$且$P_{i}$均为有限点使得当$P_{i}\\in \\textrm{supp}(D)$则$\\bar P_{i}\\notin \\textrm{supp}(D)$，除非$P_{i}=\\bar P_{i}$，此时$m_{i}=1$。\n\n**引理39**对每个因数$D\\in\\bf{D^{0}}$存在一个半约化因数$D_{1}(D_{1}\\in\\bf{D^{0}})$使得$D\\sim D_{1}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(四)零点与极点","url":"/tech/Hyper-ch4.html","content":"\n本节介绍单值化参数的概念，以及有理函数的零点和极点的阶数。\n\n**定义18**(零点，极点)令$R\\in \\bar K(C)^{*},P\\in C$。若$R(P)=0$则记为$R$在$P$有一个零点。若$R$在$P$处没有定义则记为$R$在$P$处有一个极点，此时我们记为$R(P)=\\infty$。\n\n**引理19**令$G\\in \\bar K(C)^{*},P\\in C$，若$G(P)=0$，则$\\bar G(\\bar P)=0$。\n\n证明：套定义算就行，过程略。\n\n定理23中使用引理20、21和22，证明了单值化参数的存在性。\n\n**引理20** 令$P(x,y)$是$C$上一个点。假定$G(u,v)=a(u)-b(u)v\\in \\bar K[C]^{*}$在$P$处有一个零点，且$x$不是$a(u),b(u)$的根。则$\\bar G(P)=0$当且仅当$P$是一个特殊点。\n\n证明：式子一列就看出来了。\n\n**引理21** 令$P(x,y)$是$C$上一个平凡点，$G=a(u)-b(u)v\\in \\bar K(C)^{*}$。若$G(P)=0$，且$x$不是$a(u),b(u)$的根。则$G$能被写为$(u-x)^{s}S$的形式，其中$s$是$(u-x)$能够整除$N(G)$的最高次数。$S\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：$G=N(G)/\\bar G$，由引理20，$\\bar G(P)\\neq 0\\Rightarrow N(G)(x)=0$，因此$N(G)$可被表示为$(u-x)^{s}d(u)$的形式。再令$S=d(u)/\\bar G$，则$G$能被写为$(u-x)^{s}S$的形式。由$s$的定义可知$S(P)\\neq 0$且$S(P)\\neq \\infty$。\n\n**引理22** 令$P(x,y)$是一个在$C$上的特殊点。则$(u-x)$可被写为$(v-y)^{2}\\cdot S(u,v)$，其中$S(u,v)\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：记$H(u,v)=(v-y)^{2} , s(u)=H(u,y)$，显然$s(x)=0 , s^{'}(u)=f^{'}(u)-h^{'}(u)y$，由于$C$是超椭圆曲线，无奇异点，而$P(x,y)$是特殊点，因此$2y+h(u)=0$，因此必有$f^{'}(x)-h^{'}(x)y\\neq 0$，即$s^{'}(x)\\neq 0$；综上，$(u-x)|H(u,v)$且$(u-x)^{2}\\nmid H(u,v)$，可得$S(x,y)\\neq 0,\\infty$。\n\n**引理23**(单值化参数的存在性)令$P\\in C$，则存在一个函数$U\\in\\bar K(C) , U(P)=0$使下列性质成立：对于每个多项式函数$G\\in \\bar K[C]^{*}$，存在整数$d$与函数$S\\in\\bar K(C)$，使得$S(P)\\neq 0,\\infty$且$G=U^{d}S$；此外，$d$与$U$的选择无关。$U$称为关于$P$的单值化参数。\n\n证明：太麻烦了，自己看吧！\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n下面利用单值化参数的概念来定义多项式函数在某一点上的阶数。定义26给出了[20]的另一种定义，它更便于用于计算目的。引理27证明这两个定义实际上是等价的。\n\n**定义24**(多项式函数在一点的阶数的通常定义)令$G\\in \\bar K[C]^{*} , P\\in C , U\\in \\bar K(C)$是关于$P$的单值化参数，记$G=U^{d}S$，其中$S\\in \\bar K(C) , S(P)\\neq 0,\\infty$。$G$的阶在$P$处定义为$ord_{P}(G)=d$。\n\n**引理25** 令$G_{1} , G_{2}\\in \\bar K[C]^{*} , P\\in C$，记$ord_{P}(G_{1})=r_{1} , ord_{P}(G_{2})=r_{2}$。\n\n$\\textrm{(i)}\\ ord_{P}(G_{1}G_{2})=ord_{P}(G_{1})+ord_{P}(G_{2})$\n\n$\\textrm{(ii)}$若$G_{1}\\neq -G_{2}$。若$r_{1}\\neq r_{2}$，则$ord_{P}(G_{1}+G_{2})=\\textrm{min}(r_{1},r_{2})$，若$r_{1}=r_{2}$则$ord_{P}(G_{1}+G_{2})\\geq\\textrm{min}(r_{1},r_{2})$\n\n证明：由定义24易证！\n\n**定义26**(多项式函数在一点的阶数的另一种定义) $G=a-bv\\in \\bar K[C]^{*} , P\\in C$，$G$在$P$处的定义记为$ord_{P}(G)$，定义如下：\n\n$\\textrm{(i)}$若$P(x,y)$是有限点，则令$r$为$u-x$能够同时整除$a(u),b(u)$的最高次数，记$G(u,v)=(u-x)^{r}[a_{0}(u)-b_{0}(u)v]$，若$a_{0}(x)-b_{0}(x)y\\neq 0$，则令$s=0$；否则，令$s$为$u-x$能整除$N(a_{0}(u)-b_{0}(u)v)=a_{0}^{2}+a_{0}b_{0}h-b_{0}f$。若$P$是一个平凡点，则定义$ord_{P}(G)=r+s$，若$P$是一个特殊点，则定义$ord_{P}(G)=2r+s$。\n\n$\\textrm{(ii)}$若$P=\\infty$，则$ord_{P}(G)=-max[2deg(a),2g+1+2deg(b)]$。\n\n**引理27** 定义24与定义26等价。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n**引理28** 令$G\\in \\bar K[C]^{*} , P\\in C$。则$ord_{P}(G)=ord_{\\bar P}(\\bar G)$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n**定理29**$G\\in \\bar K[C]^{*}$。则$G$存在有限个零点与极点；此外，$\\sum _{P\\in C}ord_{P}(G)=0$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n**定义30**(有理函数在一点上的阶数)令$R=G/H\\in \\bar K(C)^{*} , P\\in C$，$R$在$P$处的阶数定义为$ord_{P}(R)=ord_{P}(G)-ord_{P}(H)$。\n\n不难证明ordP (R)不依赖于G和H的选择，引理25和定理29对于非零有理函数也成立。","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(三)多项式与有理函数","url":"/tech/Hyper-ch3.html","content":"\n本节介绍多项式和有理函数的基本性质，这些性质是将它们视为超椭圆曲线上的函数而产生的。\n\n**定义8**(坐标环，多项式函数)$K$上$C$的坐标环，定义为$K[C]$，是商环\n$$\nK[C]=K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n其中$(v^{2}+h(u)v-f(u))$定义为由多项式$v^{2}+h(u)v-f(u)$生成的$K[u,v]$的理想。类似地，$\\bar K$上$C$的坐标环定义为\n$$\n\\bar K[C]=\\bar K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n$\\bar K[C]$的一个元素称为$C$上的多项式函数。\n\n**引理9** $\\bar K$上的多项式$r(u,v)=v^{2}+h(u)v-f(u)$不可约，从而$\\bar K[C]$是一个整环。\n\n证明：\n\n若$r(u,v)$在$\\bar K$可约，那么它将被分解为$(v-a(u))(v-b(u)),a,b\\in \\bar K[u]$。然而，此时$deg(a\\cdot b)=deg(f)=2g+1,deg(a+b)=deg(h)=g$，这是不可能的！\n\n注意到对每个$G(u,v)\\in \\bar K[C]$，我们可以重复地用$f(u)-h(u)v$替换$v^{2}$直到最终得到如下表示：\n$$\nG(u,v)=a(u)-b(u)v,a(u),b(u)\\in \\bar K[u]\n$$\n显然这种表示是唯一的。\n\n**定义10**(共轭)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G(u,v)$的共轭被定义为$\\bar G(u,v)=a(u)+b(u)[v+h(u)]$。\n\n**定义11**(范数)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G$的范数为多项式函数$N(G)=G\\cdot \\bar G$。\n\n范数函数在把关于双变量多项式函数的问题转化为关于单变量多项式的简单问题时非常有用。\n\n**引理12**(范数的性质)令$G,H\\in \\bar K[C]$为多项式函数。\n\n$\\textrm{(i)}\\ N(G)$是$\\bar K[u]$的一个多项式；\n\n$\\textrm{(ii)}\\ N(\\bar G)=N(G)$；\n\n$\\textrm{(iii)}\\ N(GH)=N(G)N(H)$；\n\n证明：$N(G)=a^{2}(u)-b^{2}(u)f(u)+a(u)b(u)h(u)$...基本就是套定义，没有什么思路的难度。\n\n**定义13**(函数域，有理函数)$K$上$C$的函数域$K(C)$是$K[C]$的分数域。同理，$\\bar K$上$C$的函数域$\\bar K(C)$是$\\bar K[C]$的分数域。$\\bar K(C)$的元素被称为$C$上的有理函数。\n\n注意到$\\bar K[C]$是$\\bar K(C)$的子环，即每个多项式函数也是有理函数。\n\n**定义14**(有理函数在有限点处的值)令$R\\in \\bar K(C),P\\in C,P\\neq \\infty$。如果存在多项式函数$G,H\\in \\bar K[C]$，使得$R=G/H$且$H(P)\\neq 0$，则称$R$在$P$处有定义。如果没有这样的$G,H\\in \\bar K[C]$存在，则$R$在$P$处没有定义。如果$R$在$P$处有定义，则$R$在$P$处的值定义为$R(P)=G(P)/H(P)$。\n\n显然值$R(P)$是定义明确的，即它不取决于$G,H$的选择，下面的定义介绍了多项式函数的次数的概念。\n\n**定义15**(多项式函数的次数)令$G(u,v)=a(u)-b(u)v$为$\\bar K[C]$中非零多项式函数，$G$的次数定义为：\n$$\ndeg(G)=max[2deg(a),2g+1+2deg(b)]\n$$\n**引理16**(次数的性质)令$G,H\\in \\bar K[C]$。\n\n$\\textrm{(i)}\\ deg(G)=deg(N(G))$；\n\n$\\textrm{(ii)}\\ deg(GH)=deg(G)+deg(H)$；\n\n$\\textrm{(iii)}\\ deg(G)=deg(\\bar G)$；\n\n证明：\n\n$\\textrm{(i)}N(G)=a^{2}-b^{2}f+abh,deg(N(G))=max[deg(G),deg(a)+deg(b)+g]$，因此只需证$deg(a)+deg(b)+g$必小于$2deg(a)$与$2g+1+2deg(b)$其中一个。\n\n$\\textrm{(ii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(iii)}$的结论，$deg(GH)=deg(N(GH))=deg(N(G)N(H))=deg(N(G))+deg(N(H))=deg(G)+deg(H)$\n\n$\\textrm{(iii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(ii)}$的结论...\n\n**定义17**(有理函数在$\\infty$处的值)令$R=G/H\\in \\bar K(C)$是一个有理函数。\n\n$\\textrm{(i)}$若$deg(G)<deg(H)$则$R$在$\\infty$处的值被定义为$R(\\infty)=0$；\n\n$\\textrm{(ii)}$若$deg(G)>deg(H)$则$R$在$\\infty$处的无定义；\n\n$\\textrm{(iii)}$若$deg(G)=deg(H)$则$R(\\infty)$被定义为$G$与$H$的首项系数的比值。","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(二)基本定义与属性","url":"/tech/Hyper-ch2.html","content":"\n**定义1(超椭圆曲线)**设$K$是一个域，$\\bar K$是$K$的代数闭包。$K$上类为$g$的超椭圆曲线定义为如下等式：\n$$\nC: v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v] \\tag{1}\n$$\n其中$h(u)\\in K[u]$是次数不超过$g$的多项式，$f(u)\\in K[u]$是次数为$2g+1$的首项系数为$1$多项式，并且不存在解$(u,v)\\in \\bar K\\times\\bar K$同时满足方程$v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v]$与两个偏微分方程$2v+h(u)=0,h^{'}(u)v-f^{'}(u)=0$。\n\n所谓$C$上的奇异点是一个解$(u,v)\\in \\bar K\\times\\bar K$同时满足上述三个方程。定义$1$表明超椭圆曲线没有任何奇异点。\n\n对于本文的其余部分，假设域$K$和曲线$C$已经固定。\n\n\n\n**引理1** 令$C$是$K$上如式$(1)$定义的超椭圆曲线；\n\n$(\\textrm{i})$ 若$h(u)=0$，则$char(K)\\neq 2$；\n\n$(\\textrm{ii})$ 若$char(K)\\neq 2$，则变量替换$u\\rightarrow u,v\\rightarrow (v-h(u)/2)$将$C$转换为形式$v^{2}=f(u)$，其中$f$的次数为$2g+1$；\n\n$(\\textrm{iii})$ 令$C$是形如$(1)$的等式且$h(u)=0,char(K)\\neq 2$，则$C$是超椭圆曲线当且仅当$f(u)$在$\\bar K$上没有重根；\n\n证明：\n\n$(\\textrm{i})$假设$char(K)=2$，则任意的$x\\in K , 2x=0$，因此要成为曲线$C$上的奇异点只需要满足如下两个等式即可：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n\n先求满足$f^{'}(u)=0$的根$u_{0}$，再求满足$v^{2}=f(u_{0})$的根$v_{0}$，从而得到曲线$C$的奇异点$(u_{1},v_{0})$；这与$C$是超椭圆曲线矛盾。\n\n$(\\textrm{ii})$经变量替换，$C$的形式为：$(v-\\frac {h(u)} {2})^{2}=f(u)\\Rightarrow v^{2}=f(u)-\\frac {h^{2}(u)} {4}$，而$deg(h)\\leq g\\Rightarrow deg(f(u)-\\frac {h^{2}(u)} {4})=2g+1$。\n\n$(\\textrm{iii}) 当h(u)=0,char(K)\\neq 2$时，$C$有奇异点等价于存在$(u,v)\\in \\bar K\\times\\bar K$，满足：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\n2v=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n等价于：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\\\\\n\\\\\nv=0\n\\end{cases}\n$$\n因此，$C$有奇异点等价于存在$u\\in \\bar K$，满足：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n即$f$有重根；因此，$C$是超椭圆曲线等价于$f$无重根。\n\n**定义3**(有理点，无限点，有限点)设$L$是$K$的扩展域。$C$上$L$有理点的集合，记为$C(L)$，是满足曲线$C$的等式$(1)$的所有点$P(x,y)\\in L\\times L$连同一个在无穷远处的特殊点(记为$\\infty$)，点集$C(\\bar K)$简单地被$C$定义，$C$上异于$\\infty$的点称为有限点。\n\n\n\n**例4**(实数域上的超椭圆曲线)如下是实数域上的超椭圆曲线的三个例子，每条曲线类$g=2$且$h(u)=0$。\n\n$(\\textrm{i})\\ C_{1}:\\ v^{2}=u^{5}+u^{4}+4u^{3}+4u^{2}+3u+3=(u+1)(u^{2}+1)(u^{2}+3)$，$C_{1}$在实平面的图像如图$1$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n$(\\textrm{ii})\\ C_{2}:\\ v^{2}=u^{5}+u^{4}-u^{2}-u=u(u-1)(u+1)(u^{2}+u+1)$，$C_{2}$在实平面的图像如图$2$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n$(\\textrm{iii})\\ C_{3}:\\ v^{2}=u^{5}-5u^{3}-u^{2}+4u=u(u-1)(u+1)(u-2)(u+2)$，$C_{3}$在实平面的图像如图$3$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n\n\n**定义5**(相反点、特殊点和平凡点)令$P(x,y)$是曲线$C$上的一个有限点。$P$的相反点是$\\bar P(x,-y-h(x))$。(注意到$\\bar P$确实在$C$上。)我们同样定义$\\infty$的相反点$\\bar \\infty=\\infty$为他的本身。若一个有限点$P$满足$P=\\bar P$，则该点被称为特殊的；否则，该点被称为平凡的。\n\n\n\n**例6**($Z_{7}$上的超椭圆曲线)考虑有限域$Z_{7}$上的曲线$C:v^{2}+uv=u^{5}+5u^{4}+6u^{2}+u+3$。这里，$h(u)=u,f(u)=u^{5}+5u^{4}+6u^{2}+u+3$且$g=2$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$确实是一个超椭圆曲线。$C$上的$Z_{7}$有理点为$C(Z_{7})={\\infty,(1,1),(1,5),(2,2),(2,3),(5,3),(5,6),(6,4)}$，点$(6,4)$是一个特殊点。\n\n\n\n**例7**($F_{2^{5}}$上的超椭圆曲线)考虑有限域$F_{2^{5}}=F_{2}[x]/(x^{5}+x^{2}+1)$，并且令$\\alpha$是本原多项式$x^{5}+x^{2}+1$在$F_{2^{5}}$的根。$\\alpha$的指数如表$1$所示。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n考虑有限域$F_{2^{5}}$上类$g=2$曲线$C: v^{2}+(u^{2}+u)v=u^{5}+u^{3}+1$，这里$h(u)=u^{2}+u,f(u)=u^{5}+u^{3}+1$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$实际上是一个超椭圆曲线。$C(F_{2^{5}})$中的有限点如下：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n其中，点$(0,1),(1,1)$是特殊的。","tags":["hyper"],"categories":["tech"]},{"title":"超椭圆曲线(一)简介","url":"/tech/Hyper-ch1.html","content":"\n**前言**：本文对具有密码相关性的任意特征的有限域上的超椭圆曲线的一些理论作了初步的介绍。给出了在超椭圆曲线雅可比矩阵中求解的康托算法，并证明了该算法的正确性。\n\n\n超椭圆曲线是一类特殊的代数曲线，可以看作是椭圆曲线的推广。对每类$g\\geq1$的超椭圆曲线，当$g=1$时超椭圆曲线退化为椭圆曲线。一百多年来，人们对椭圆曲线进行了广泛的研究，并有大量的相关文献;例如，参见西尔弗曼[34,35]的著作。最初研究椭圆曲线主要是出于纯粹的审美原因，最近已成为几个重要应用领域的必要工具，包括编码理论(如Driencourt和Michon[11]和van der Geer [15])；伪随机数生成(如Kaliski [18]);数论算法(如Goldwasser and Kilian[16]和Lenstra [21]);和公开密钥密码学(见Koblitz [19]， Miller[27]和Menezes [25])。\n\n另一方面，超椭圆曲线理论还没有得到学术界足够的重视。在代数几何文献中出现的关于超椭圆曲线的大多数结果都是用非常一般的术语表达的。例如，在有关超椭圆曲线的论文中，一个常见的来源是芒福德的书[28]。然而，非专业人士很难将本书中的结果专门研究(更不用说发现)到超椭圆曲线的特殊情况。另一个困难是，这些书中的理论通常仅限于复数上的超椭圆曲线(如芒福德的书)，或特征不等于$2$的代数闭域。最近的Cassels和Flynn[6]的书是关于类为$2$曲线的广泛记述。(与他们的书相比，我们的方法绝对是“低级的”。)近年来，超椭圆曲线在代数几何以外的领域得到了应用。超椭圆曲线是Adleman和Huang关于证明[3]的质数的随机多项式时间算法的关键组成部分。在纠错码[4]、整数分解算法[22]和公钥密码[20]的设计中也考虑了超椭圆曲线。对于实现这些代码和密码系统，在特征为$2$的有限域上的超椭圆曲线是特别有趣的。\n\nCharlap和Robbins[7,8]对椭圆曲线进行了初步的介绍。目的是为有限域上计算椭圆曲线上的点的Schoof算法[33]的一些基本理论提供基本的自成证明。讨论仅限于不等于2或3的特征域。然而，在实际应用中，椭圆曲线和超椭圆曲线在两个特征域上特别具有吸引力。本文与Charlap和Robbins的思想相似，对具有密码相关性的任意特征有限域上的超椭圆曲线的一些理论作了初步的介绍。关于代数曲线理论的一般介绍，请参阅富尔顿的著作[14]。","tags":["hyper"],"categories":["tech"]},{"title":"第二章第八节 多协议标记交换MPLS","url":"/cn/cn-ch2-par8.html","content":"\n## MPLS的工作原理\n\nMPLS工作原理图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n一个标记仅仅在一对标记交换路由器LSR之间才有意义，MPLS数据包每经过一个LSR，LSR需要做两件事：更换标记与转发。划分为同一转发等价类的数据包被设置同样的标记，转发等价类也可用于负载均衡。\n\n## MPLS头部\n\nMPLS头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 31.png pic31 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第二章第七节 VPN与NAT","url":"/cn/cn-ch2-par7.html","content":"\n## 虚拟专用网VPN\n\n由于IP地址的紧缺，如果一个机构只需要与机构内的其他主机通信，因此只需为其分配一个在机构内唯一的IP地址即可。为避免与互联网上的IP地址冲突，RFC 1918规定：以下3个地址块为机构内通信的专用地址。\n\n* 10.0.0.0至10.255.255.255；\n* 172.16.0.0至172.31.255.255；\n* 192.168.0.0至192.168.255.255；\n\n利用公用互联网作为机构各专用网之间的通信载体，这样的专用网称为虚拟专用网VPN。下图用例子说明如何用IP隧道技术实现虚拟专用网。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n## 网络地址转换NAT\n\nNAT方法需要专用网上路由器有NAT组件，所有使用专用地址与外界通信的主机，都要在NAT路由器上将源IP地址转换为NAT路由器的IP地址，才能发送到互联网中。NAT的工作原理如下图所示。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n而数据包出入时源IP地址/目的IP地址的转换就通过NAT地址转换表进行。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n\n由此可见，如果NAT路由器有n个全球IP地址，则专用网内最多可有n台主机接入互联网。\n\n为更充分利用NAT路由器的IP地址，目前的NAT转换表将传输层的端口号也利用上，这也称为网络地址与端口号转换。此时的NAT地址转换表如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 29.png pic29 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第二章第六节 IP多播","url":"/cn/cn-ch2-par6.html","content":"\n## 网际组管理协议IGMP\n\nIGMP协议基于IP协议。ICMP的工作大体分为两类。\n\n* 有主机要加入某一多播组时，主机向该多播组的多播地址发送一个IGMP报文，声明加入该组。本地的多播路由器收到IGMP报文后，需利用多播路由选择协议将这种组成员关系转发给互联网上的其他多播路由器；\n* 本地多播路由器需周期性探询本地局域网上的主机，以便知道这些主机是否仍然为组成员。只要有一台组内的主机响应，那么本地的多播路由器就认为该组活跃，否则，本地的多播路由器认为局域网中所有主机离开该组，不再将这个组的成员关系转发给其他多播路由器；\n\n为减少网络开销，IGMP协议具有以下特点。\n\n* 主机与多播路由器间的所有通信均为IP多播；\n* 多播路由器在探询组成员关系时，只需要对所有组发送一个请求信息的询问报文；\n* 同一组内每台主机都要监听响应，若本组的其他主机先发送了响应，则自己不用再发送响应；\n\n## 多播路由选择协议\n\n多播路由选择就是要找出以源主机为根节点的多播转发树，多播路由选择协议尚未标准化，下面接收多播路由选择的3种方法。\n\n### 洪泛与剪除\n\n开始，路由器使用洪泛法转发多播数据报，每个路由器在收到一个数据包后，检查数据包是否是从源点经最短路径传送来的(计算从路由器到源点的最短路径，判断刚刚转发数据包的路由器是否为最短路径上的第一个路由器)。若是，则向所有其他方向转发此多播数据包，否则丢弃而不转发。如下是一个例子。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n&nbsp;\n\n若多播转发树上的某个路由器的下游树枝已无该多播组的成员，则将该路由器与其下游树枝一起剪除。\n\n### 隧道技术\n\n适用于多播组的位置在地理上分散的情形。在多播数据包进入单播网络时，将多播数据包封装上普通IP头部，到达多播网络后再去除普通IP头部。多播数据包如同在隧道中通过单播网络。\n\n### 基于核心的发现技术\n\n对每个多播组G指定一个核心路由器q，给出q的IP单播地址。q按照洪泛与剪除法创建G的转发树。发送到核心路由器的数据包会被沿途所有路由器检查内容，到达q后，若数据包是多播数据包，则q向G中所有成员转发数据包。若数据包是请求加入G，q就会将源路由器加入G，然后用隧道技术向刚刚加入的路由器转发每个多播数据报的副本。","tags":["backend"],"categories":["cn"]},{"title":"第二章第五节 IPv6","url":"/cn/cn-ch2-par5.html","content":"\n## IPv6基本首部\n\nIPv6数据报大体分两部分：基本头部与有效载荷，有效载荷中可写入多个扩展头部(非必需)。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\nIPv6基本头部格式如下。\n\n<div style=\"width:54%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n其中，流标号是基于IPv6所提出的流概念，\"流\"是互联网上从某一源点到某一终点的一系列数据包，这个\"流\"经过的路由器都保证指明的服务质量。\n\n## IPv6地址\n\n每个地址占128位，采用冒号16进制记法。IPv6地址分类如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n## 从IPv4向IPv6过渡\n\n(1)双协议栈；(2)隧道技术：在IPv6数据报要进入IPv4网络时，将其封装为IPv4数据报。示意图如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n## ICMPv6\n\n与IPv4一样，IPv6也不保证数据的可靠交付，因此IPv6也需要使用类似ICMP的协议来反馈差错信息——ICMPv6，它将地址解析协议ARP、网际组管理协议IGMP合并进自身。","tags":["backend"],"categories":["cn"]},{"title":"第二章第四节 互联网的路由选择协议","url":"/cn/cn-ch2-par4.html","content":"\n## 基本概念\n\n理想的路由算法应具有如下特点：(1)算法必须正确、完整；(2)算法易于计算；(3)算法具有自适应性，即能适应通信量与网络拓扑的变化；(4)稳定性；(5)公平性；(6)算法应是最优的。实际的路由算法应尽可能接近理想的路由算法。\n\n### 分层的路由选择协议\n\n互联网采用分层次的路由选择协议，整个互联网被划分为许多较小的自治系统AS。于是，路由选择协议分为两类：(1)内部网关协议IGP：自治系统内部使用的路由选择协议，如RIP、OSPF协议；(2)外部网关协议：各自治系统间使用的路由选择协议，如BGP-4。\n\n## 内部网关协议RIP\n\n### 工作原理\n\nRIP协议要求网络中的每个路由器均维护一个从自身到所有其他网络的距离，即跳数。RIP协议有如下特点：\n\n* 只与相邻路由器交换信息。\n* 路由器无保留地交换信息。\n* 路由器按固定的时间间隔交换信息。\n\n路由表中的主要信息为：(1)到某个网络的最短距离；(2)下一跳的地址；路由器更新要做的就是刷新到各个网络的最短距离及其应该经过的下一跳地址。即RIP协议所使用的距离向量算法。\n\n### 距离向量算法\n\n对每一相邻路由器发来的RIP报文，路由器根据此报文更新路由表：\n\n(1)对地址为X的相邻路由器发来的RIP报文中的路由表，将路由表中的所有路由的下一跳项改为X、距离项的值加1；\n\n(2)对修改后的每一路由r：若路由器的路由表中没有到r中目的网络y的路由，则将此路由添加到路由器的路由表中。否则，记路由器的路由表中到目的网络y的路由为s，(i)若s的下一跳地址为X，则将r替换s；(ii)s的下一跳地址非X，若r的距离小于s的距离，则将r替换s。\n\n(3)若3分钟未收到相邻路由器的路由表，则将此相邻路由器标记为不可达。\n\n### RIP协议的报文格式\n\n<div style=\"width:56%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n其中路由标记填入自治系统号ASN。RIP实现简单、开销小，存在的问题是传递故障信息的速度很慢，适用于小规模网络。\n\n## 内部网关协议OSPF\n\n### 工作原理\n\nOSPF为分布式链路状态协议，具有以下3个特点：\n\n* 采用洪泛法向所有相邻的路由器发送信息；\n* 发送的信息为与自身相邻的所有路由器的链路状态，链路状态包含费用、距离、时延、带宽等等；\n* 只有链路状态发生变化时，发生变化的路由器才使用洪泛法向所有相邻的路由器发送信息；\n\n各路由器之间频繁交换链路状态信息，最终所有的路由器都能建立一个链路状态数据库，即全网的拓扑结构图。每个路由器根据拓扑结构图使用Dijkstra算法计算到各路由器的路由。\n\n### 划分区域\n\nOSPF为适应大规模的自治系统，将其划分为若干个小范围——区域，每一区域有一个32位的标识符。此时再使用洪泛法发送信息时就只在区域内传递。为使得区域间能发送消息，OSPF会定义一个主干区域，其他区域均为边界区域。主干区域的标识符为0.0.0.0，它连接所有的边界区域，来自其他区域的信息先汇集到该区域的边界路由器，进入主干区域后流入目的区域。如下是一个例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### OSPF协议报文格式\n\nOSPF使用IP数据报传递信息，OSPF分组使用如下图的24字节固定长度头部，如下图为OSPF协议报文格式。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\nOSPF报文共有5种类型。其中路由器标识符标志发送此报文的路由器接口IP地址。OSPF具有以下特点：\n\n* OSPF允许管理员给每条路由指派不同的代价；\n* 若到目的网络存在多条代价相同的路由，OSPF可将通信量分配到多条路径，达到多路由间的负载均衡；\n* 所有使用OSPF协议的路由器在交换时都会进行鉴别，确保仅在可信赖的路由器间交换链路状态信息；\n* OSPF支持可变长度的子网划分与无分类的编址CIDR；\n* 由于网络中的链路状态经常变化，因此OSPF让每一个链路状态带有一个32位的序号，每次链路状态改变序号加1，且OSPF协议规定增长的速率不超过次/5s；\n\n### 5类OSPF报文\n\n* 问候报文。发现与维持相邻路由器的可达性；\n* 数据库描述报文。向相邻路由器发送自身链路状态数据库中所有链路状态项目的摘要信息；\n* 链路状态请求报文。向目的路由器请求其发送某些链路状态项目的详细信息；\n* 链路状态更新报文。使用洪泛法向全网更新链路状态；\n* 链路状态确认报文。对链路更新分组进行确认；\n\n除问候报文外，其余四类报文均用来进行链路状态数据库的同步。一个刚刚工作的路由器先通过问候报文得知有哪些路由器与之物理相邻。每个路由器向相邻路由器发送数据库描述报文，路由器再根据这些数据库描述报文向对应路由器发送链路状态请求报文。通过一系列交互，建立起全网同步的链路数据库。上述同步的示意图如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n## 外部网关协议BGP\n\n### 工作原理\n\n在配置BGP时，每个自治系统的管理员至少选择一个路由器作为\"BGP发言人\"，BGP发言人使用TCP连接交换路由信息。BGP发言人与自治系统AS之间的关系如下图。各BGP发言人之间交换的信息就是达到某个网络需经过的自治系统。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\nBGP协议支持无分类域间路由选择CIDR，因此使用BGP协议的路由器的每条路由应包含目的网络前缀、下一跳IP地址、到达目的网络需经过的自治系统序列。若某个BGP发言人收到其他BGP发言人的路径通知，它需要检查自身是否在通知的路径中，若在，则不能采用此路径，避免形成回路。\n\n路由器运行稳定后，路由器只需要在自治系统发生变化时发送BGP报文。\n\n### 4类BGP报文\n\n* OPEN报文。与相邻的BGP发言人建立关系，初始化通信；\n* UPDATE报文。告知某一路由的信息(不能增加多条)，以及列出要撤销的多条路由；\n* KEEPALIVE报文。周期性地证实连接的连通性。\n* NOTIFICATION报文。发送检测到的差错。\n\n### BGP报文格式\n\n4类BGP报文具有同样的通用BGP头部，如下图所示。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n&nbsp;\n\nKEEPALIVE报文只有BGP头部，共19字节。OPEN报文主体有6个字段：版本、本自治系统号、保持时间、BGP标识符、可选参数长度、可选参数；UPDATE报文主体有5个字段：不可行路由长度、撤销路由列表、路径属性总长度、路径属性、网络层可达信息。NOTIFICATION报文有3个字段：差错代码、差错子代码、差错数据。\n\n## 路由器简介\n\n典型的路由器结构如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第二章第三节 网际控制报文协议ICMP","url":"/cn/cn-ch2-par3.html","content":"\n## 概述\n\n为更有效地转发IP数据报，在网络层使用网际控制报文协议ICMP。ICMP允许路由器或主机报告IP数据报的差错情况。ICMP报文格式如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\nICMP报文分两种：ICMP差错报告报文与ICMP询问报文。ICMP报文前4字节是包含3个字段(类型、代码、校验和)的固定格式，接下来4个字节的内容与ICMP的类型有关。最后的数据字段取决于ICMP的类型。下表给出常用的ICMP报文类型。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n下面具体介绍。\n\n## ICMP差错报告报文\n\nICMP差错报告报文主要有以下4种：\n\n* 终点不可达。路由器或主机无法交付数据报。\n* 时间超过。路由器收到生存时间为0的数据报，丢弃该数据报，并向数据报的源点发送时间超过ICMP报文。\n* 参数问题。路由器或目的主机收到的数据报头部有不正确字段，则丢弃该数据报，向源点发送参数问题报文。\n* 改变路由(重定向)。路由器将改变路由报文发送给主机，告知主机下次将报文发送给另外的路由器。\n\n对于需要进行差错报告的IP数据报，路由器或主机会将IP头部与IP数据字段的前8字节取出，作为ICMP报文的数据字段，再填写ICMP头部得到ICMP报文。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n对于以下几种情形，均不发送ICMP差错报文。\n\n* 对ICMP报文，它也是IP数据报，但是对于它的差错情况无需发送ICMP差错报文；\n* 一个IP数据包出错，路由器发送ICMP差错报文后，同属于这一数据报的数据包的差错情况不用再发ICMP差错报文；\n* 对具有多播地址或特殊地址(127.0.0.0、0.0.0.0)的数据报，均不发送ICMP差错报文；\n\n## ICMP询问报文\n\n(1)回送请求与回答；ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给查询方回复ICMP回送回答报文。这类报文用来测试目的站是否可达以及了解其相关状态。\n\n(2)时间戳请求与回答；ICMP时间戳请求报文向目的主机或路由器查询当前日期与时间，这类报文用于时钟同步与时间测量。\n\n## ICMP应用举例\n\nunix/Linux上的应用traceroute可以显示一个数据报从源点到终点的路径，此工具的原理如下。\n\ntraceroute从源主机向目的主机发送UDP数据报，第一个数据报P1的生存时间TTL设为1，那么当P1到达路径上第一个路由器R1时，R1将其接收，并将P1的TTL减1，于是TTL等于0，R1便将P1丢弃并向源主机发送一个ICMP时间超过差错报告报文，于是traceroute就得到了路径上的第一个路由器的IP地址；第二个数据报P2的生存时间TTL设为2从而得到路径上的第二个路由器的IP地址；以此类推，直到UDP数据报恰能到达目的主机，目的主机向源主机发送ICMP终点不可达差错报告报文。","tags":["backend"],"categories":["cn"]},{"title":"第二章第二节 划分子网与构造超网","url":"/cn/cn-ch2-par2.html","content":"\n## 划分子网\n\n基本思路如下：\n\n* 一个拥有多个物理网络的单位，将所属的物理网络划分为若干子网，但该单位对外仍表现为一个网络。\n* 从网络的主机号借用若干位作为子网号，两级IP地址在本单位内部变成三级IP地址{<网络号><子网号><主机号>}。\n* 发送给本单位某台主机的网络包到达本单位网络上的路由器后，路由器根据目的网络号与子网号找到目的子网，再将网络包发送给目的子网。\n\n## 子网掩码\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n目的IP与子网掩码按位与得到子网地址。网络的默认子网掩码中1的位置与网络中主机IP地址的网络号字段对应。\n\n## 使用子网时的分组转发\n\n在划分子网的情形下，路由表的每条路由主要包含三项：目的网络地址、子网掩码、下一跳IP地址，分组转发算法也要做出相应改变。\n\n* 路由器从网络包的IP头部提取目的IP；将目的IP与各子网掩码按位与，若计算结果等于子网地址，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 对路由表的每一行<目的网络地址, 子网掩码, 下一跳IP地址>，用其子网掩码与网络包的目的IP按位与，若计算结果等于其目的网络地址，则将数据传递给该路由的下一跳IP地址。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。\n\n## 无分类编址CIDR\n\n### 网络前缀\n\n无分类域间路由选择。CIDR将32位的IP地址划分为前后两个部分，前面部分指明网络，后面部分指明主机。消除了传统的A类、B类、C类地址与划分子网概念。如下是一个CIDR地址划分的例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n### 最长前缀匹配\n\n根据上节的例子可以看到，在查找路由表时可能会得到不止一个匹配结果，此时应该选择匹配长度最长的路由。这称为最长前缀匹配。\n\n### 二叉线索查找路由\n\n为进行有效查找，无分类编址的路由表存放在二叉线索树中。在查找前，找出对应每个IP地址在表中的唯一前缀，接下来以这些前缀构造二叉线索，查找时，只要可以与唯一前缀匹配即可。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第二章第一节 网际协议IP","url":"/cn/cn-ch2-par1.html","content":"\n## 虚拟互连网络\n\n许多计算机网络通过路由器互连，参加互连的计算机网络都使用相同的网际协议IP，因此可以把互连以后的计算机网络看成如下图所示的一个虚拟互连网络。互连起来的各种物理网络的异构性是客观存在的，但是使用IP协议就可以使这些性能各异的网络在网络层看起来如同一个统一的网络。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n## 分类的IP地址\n\n将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，第一个字段称为网络号，第二个字段称为主机号。组成的IP地址在整个互联网范围内是唯一的。这种两级IP地址记为{<网络号><主机号>}。如下图是各种类型的IP地址：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n## IP地址与硬件地址\n\n(1)设计IP地址的目的。(有了MAC地址为什么还要IP地址)\n\n随着网络中设备的逐渐增多，人们发现路由(寻址数据包从发送端到接收端的路径)越来越困难。于是有人提出将网络划分成很多的子网，在路由时就可以将其他子网看成一个整体，路由器只需要考虑将数据包发送到接收端所在子网即可(剩下工作由子网内部解决)。这样找到的路由接近最优路由但大大减少了计算量。于是，需要有一种地域相关的地址，而IP地址就是！位于同一子网上的网络设备，其IP地址的前缀一致。从而在路由时通过IP地址找到较优路由。\n\n(2)设计MAC地址的目的。(有了IP地址为什么还要MAC地址)\n\nMAC地址是网卡地址，网卡才是真正能够做通讯的设备，IP只是上层的软件，负责将不同的网络连接在一起。\n\n&nbsp;\n\nIP地址用在网络层及以上，MAC地址用在数据链路层及以下。如下图，三个局域网用两个路由器连接起来，由于路由器R1、R2同时连接在两个局域网上，因此R1、R2都有两个MAC地址。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n## 地址解析协议ARP\n\n根据IP地址，解析出同一局域网上设备的MAC地址。每台主机上都设置一个ARP高速缓存，存放着本局域网上各主机与路由器的IP地址到MAC地址的映射表。显然，如果主机查询的IP地址在主机的ARP高速缓存中存在，即可读取出IP地址对应的MAC地址，否则，按如下步骤找出IP地址对应的MAC地址。\n\n* 查询主机的ARP进程在本局域网上广播发送一个ARP请求分组用于查询IP地址对应的MAC地址；\n* 本局域网上所有主机运行的ARP进程都收到此ARP请求分组；\n* IP地址与请求分组中查询MAC地址的IP地址不一致的主机忽略此请求，否则，(IP地址与请求分组中查询MAC地址的IP地址一致的主机)向查询主机发送ARP响应分组，其中包含自身的MAC地址。同时在自身的ARP高速缓存中写入查询主机的IP : MAC映射；\n* 查询主机收到响应分组后，在其ARP缓存中添加这组IP : MAC映射；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n## IP数据报的格式\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n格式中大部分内容的作用很显然，这里解释一下标识。IP软件维持一个计数器，每产生一个数据报，计数器加1，并将计数器的值赋给标识字段。这个标识并不是序号(IP是无连接的)，这是因为当数据报很长需要分组传输时，每个分组的数据包的标识字段都是一样的。相同标识字段的数据包意味着数据包来自同一数据报。\n\n## IP数据报的分组转发\n\n在路由表中，最主要的路由包含(目的IP地址, 下一跳IP地址)。网络包每次到达路由器，路由器都根据目的IP地址确定下一跳路由器的IP地址，然后将IP数据包送交数据链路层的网络接口，网络接口将下一跳的IP地址借助ARP协议转换为MAC地址，它将作为MAC头部的目的地址，然后路由器将网络包发送到下一跳路由器。归纳如下分组转发算法。\n\n* 路由器从网络包的IP头部提取目的IP；若目的IP与路由器在同一网络，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由表有到达目的主机所在网络的路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。","tags":["backend"],"categories":["cn"]},{"title":"第一章 计算机网络体系结构","url":"/cn/cn-ch1.html","content":"\n## 分层的好处\n\n分层的好处：(1)各层之间相互独立；(2)灵活；(3)易于实现与维护；(4)促进标准化。通常各层要完成以下功能：\n\n* 差错控制：保证相应层次对等方的通信可靠；\n* 流量控制：发送的数据要让接收端来得及接收；\n* 分段与重装：发送端将要发送的数据划分为一定长度的数据块，接收端要将接收的数据块还原；\n* 复用与分用：发送端的多个高层应用复用一条低层的连接，而接收端的低层将收到的信息分别交付高层的多个应用；\n* 连接建立与释放：通信开始前建立连接，通信结束断开连接；\n\n## 五层协议模型\n\n<div style=\"width:56%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n**应用层**\n\n通过应用进程间的交互来完成特定网络应用。应用层协议定义应用进程间通信与交互的规则。如域名系统DNS、HTTP协议、SMTP电子邮件协议。\n\n**传输层**\n\n向两台主机中进程之间的通信提供通用的数据传输服务。传输层主要有TCP协议与UDP协议：\n\n* 传输控制协议TCP：提供面向连接、可靠的数据传输服务；\n* 用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务；\n\n**网络层**\n\n为分组交互网上的不同主机提供通信服务。网络层主要使用IP协议。\n\n## TCP/IP协议族\n\n将TCP/IP协议族按层次描述如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 2.png pic2 %}</div>","tags":["backend"],"categories":["cn"]},{"title":"第十九章 I/O子系统","url":"/os/os-ch19.html","content":"\n## I/O特点\n\nI/O设备有三种常见类型：字符设备(键盘、鼠标等)，块设备(磁盘驱动器、光驱等)，网络设备(无线网卡、蓝牙等)。不同类型的设备访问特征不同。\n\n* 字符设备：以字节为单位顺序访问，访问使用get()、put()函数；\n* 块设备：读写以一个数据块为单位，访问既可以使用get()、put()函数，也可以使用文件系统接口，或者将文件映射到内存；\n* 网络设备：交互复杂，接收格式化的网络报文，访问使用专门的网络报文收发接口——send/receive；\n\n## I/O结构\n\n如下是整个计算机系统的结构：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 77.png pic77 %}</div>\n\n&nbsp;\n\nI/O的结构层次如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 78.png pic78 %}</div>\n\n&nbsp;\n\n下面考虑一个完整的I/O请求的生命周期：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 79.png pic79 %}</div>\n\n## I/O数据传输\n\n访问设备的数据可通过CPU指令(in/out)实现，这种方式便于实现但是消耗CPU(时间与数据量成正比)。或者直接通过内存访问，只需要在传输数据的开始和结束使用CPU，传输数据过程不影响CPU，在高吞吐量的I/O设备中使用该方式。\n\n处理设备请求有两种方式：轮询与设备中断；设备中断效率高，设备中断的I/O处理流程如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 80.png pic80 %}</div>\n\n&nbsp;\n\n## Linux I/O子系统\n\nLinux I/O系统结构如下图所示：\n\n<div style=\"width:38%;margin:auto\">{% asset_img 81.png pic81 %}</div>","tags":["backend"],"categories":["os"]},{"title":"第十八章 文件系统实例","url":"/os/os-ch18.html","content":"\n## FAT文件系统\n\nFAT文件系统的结构如下：\n\n```basic\n---------------------------------------------------------------------------------------\n| 启动扇区 |   文件分配表   |  文件分配表副本  |  根目录项  |           其他文件           |\n---------------------------------------------------------------------------------------\n```\n\n## EXT4文件系统\n\n支持大容量存储，可快速恢复异常状态。\n\n### 大容量存储\n\n<div style=\"width:68%;margin:auto\">{% asset_img 68.png pic68 %}</div>\n\n&nbsp;\n\n索引块采用\"段机制\"，对于大文件(一般连续)，只需要一次访问。\n\n### 异常恢复\n\nEXT4文件系统框架示意图如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 71.png pic71 %}</div>\n\n&nbsp;\n\n其中Group的结构如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 69.png pic69 %}</div>\n\n&nbsp;\n\n其中，Bitmaps标志每个文件数据块是否被占用，文件数据块有两种——索引数据块与存储数据块；\n\n当系统出现断电或者系统崩溃，有些在缓存中的数据还未写入文件，这时就出现缓存与文件的数据不一致。EXT4文件系统使用日志来恢复异常(现代的文件系统都是日志文件系统)。日志的组成如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 70.png pic70 %}</div>\n\n其中，TxB与TxE分配标志一个日志的开始与结束，中间是日志的内容：\n\n* I[v2]：对更改的存储数据块对应的索引数据块的改变；\n* B[v2]：对更改的存储数据块对应的Bitmaps位的改变；\n* Db：更改的存储数据块；\n\n日志文件系统先将对应日志写入日志数据块，再将缓存数据写入文件。为保证TxE的正确性，先写入TxB、I[v2]、B[v2]，再写入TxE。\n\n为提高数据写入文件的速度，可采用批处理；此外，通过循环日志的方式，缩小日志数据的规模。\n\n为了进一步提高数据写入文件的速度，metadata日志省略了在日志数据块中写入Db，但此时要调整数据写入顺序：Db写入文件->metadata写入日志数据块->metadata写入文件系统。通过强制首先写入数据，保证指针永远不会指向垃圾数据。\n\n## ZFS文件系统\n\n### 概述\n\nZFS是一种新型的文件系统，它提供了简单的管理、事务语义、端到端数据完整性与极大的可扩展性。ZFS文件系统框架如下图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 72.png pic72 %}</div>\n\n* ZPL：封装的处理文件的接口；\n* DMU：数据管理单元，提供基于对象的事务操作的支持；\n* ARC：(类似内存的)缓存与替换算法；\n* ZIO：对实际的I/O处理做抽象，向ARC层提供支持；\n* VDEV：虚拟设备，内置了各种RAID；\n\nZFS文件系统使用存储池作为存储设备。取消了文件卷，采用分配与回收机制，分配的空间易于调整；\n\n<div style=\"width:40%;margin:auto\">{% asset_img 73.png pic73 %}</div>\n\n&nbsp;\n\n### 数据完整性\n\n**写时复制**：对数据进行修改时，先复制数据的一个副本，在副本上修改完再写回数据的位置(提交)。\n\n读数据时，采用分层校验，即ZFS校验树，每级目录都有校验和；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 74.png pic74 %}</div>\n\n&nbsp;\n\n在读数据时，如果数据未能通过校验，则读取数据副本，并将副本写入数据位置。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 75.png pic75 %}</div>\n\n&nbsp;\n\nZFS采用动态条带宽，不同对象校验数据块的的个数也不同，根据所需安全性来选择合适的校验数据块个数；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 76.png pic76 %}</div>\n\n&nbsp;","tags":["backend"],"categories":["os"]},{"title":"第十七章 文件系统概念","url":"/os/os-ch17.html","content":"\n## 文件系统与文件\n\n文件系统是操作系统中管理持久性数据的子系统，提供数据存储与访问功能。文件是具有符号名，由字节序列构成的数据项集合。文件是文件系统的基本数据单位，文件名是文件的标识符号。\n\n**文件系统的功能**\n\n* 分配文件磁盘空间：管理文件数据块、管理空闲空间、分配存储区域；\n* 管理文件集合：文件定位、文件命名、文件系统结构——文件的组织；\n* 数据可靠与安全：安全(多层次保护数据安全)、可靠(持久保存数据，避免系统崩溃、媒体错误、攻击等等)；\n\n**文件属性**\n\n文件属性包括名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等等。\n\n**文件头**\n\n文件系统元数据中的文件信息。其中包括文件属性以及文件的存储位置与顺序。\n\n## 文件描述符\n\n操作系统维护的打开的文件的状态与信息。包括文件指针、文件打开次数、文件在磁盘上的位置、访问权限等等。\n\n## 目录 文件别名 文件系统种类\n\n目录是一种特殊的文件，用来表示其他文件的信息，目录的内容为文件索引表(每个索引项为<文件名, 指向文件的指针>)。\n\n**日志文件系统**：文件系统的所有修改，都会记录。\n\n## 虚拟文件系统\n\n对所有不同文件系统的抽象。主要实现以下四个功能：\n\n* 提供相同的文件与文件系统接口；\n* 管理所有文件和文件系统关联的数据结构；\n* 高效的查询；\n* 与特定文件系统模块的交互；\n\n### 文件系统基本数据结构\n\n* 文件卷控制块；一个文件系统有一个文件卷控制块，包含文件系统详细信息(块大小、空余块、计数/指针等)。\n* 文件控制块；一个文件有一个文件控制块，包含文件详细信息(访问权限、所有者、大小、数据块位置等)。\n* 目录项；一个文件有一个目录项，将目录项数据结构及树型布局编码成树型数据结构(指向文件控制块、父目录、子目录等)。\n\n整个文件系统的组织视图如下：\n\n<div style=\"width:42%;margin:auto\">{% asset_img 56.png pic56 %}</div>\n\n## 文件缓存与打开文件\n\n### 文件缓存\n\n在计算机系统中存在多处缓存：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 57.png pic57 %}</div>\n\n&nbsp;\n\n数据块有两种缓存方式：数据块缓存与页缓存(将数据块与内存页缓存起来)。\n\n* 数据块缓存：虚拟页对换与文件读写分开。最终合并为数据块缓存。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 58.png pic58 %}</div>\n\n&nbsp;\n\n* 页缓存：在虚拟地址空间中虚拟页面可映射到本地外存文件中。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 59.png pic59 %}</div>\n\n&nbsp;\n\n其中文件数据块被映射为页，文件的读/写操作被转换成对内存的访问。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 60.png pic60 %}</div>\n\n### 打开文件\n\n每个打开的文件都有一个文件描述符，记录文件的状态信息，包括目录项、当前文件指针、文件操作设置等；\n\n每个进程有一个打开文件表，记录进程单独打开的文件描述符；\n\n同时操作系统还有一个打开文件表，其中记录的文件描述符由多个进程共享；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 61.png pic61 %}</div>\n\n&nbsp;\n\n一些文件系统提供文件锁，用于协调多进程的文件访问；文件系统有两个处理方式：强制与劝告。\n\n* 强制：根据锁的状态与访问请求确定是否拒绝访问；\n* 劝告：进程查看锁的状态，由进程决定下一步操作；\n\n## 文件分配\n\n本质为如何表示分配给一个文件数据块的位置与顺序。与内存分配类似，文件分配也有连续、链式、索引分配。所谓索引分配，就是用存储文件数据块的指针来表示分配给一个文件数据块的位置与顺序(这个存储文件数据块的指针的数据块称为索引数据块)。这3种分配方式各有优缺点，实际的文件分配方案会将这三种分配方式结合起来，下面介绍UFS文件系统的文件分配方案。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 62.png pic62 %}</div>\n\n&nbsp;\n\n文件头包含13个指针，前10个指针(直接)指向文件数据块、第11个指针指向索引块、第12个指针指向2级索引块、第13个指针指向3级索引块；对于小文件：这种文件分配退化为连续分配，对于大文件：这种文件分配就是多级索引分配。\n\n## 冗余磁盘阵列\n\n使用多磁盘可改善吞吐量(并行)，增加可靠性(冗余)。\n\n### RAID-0\n\n磁盘条带化技术。将数据分成多个子块，存储在独立的磁盘中。增加了读写的磁盘带宽，读写数据的性能提升。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 63.png pic63 %}</div>\n\n&nbsp;\n\n### RAID-1\n\n向两个磁盘写入，从任何一个读取。增加了可靠性与读数据的性能。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 64.png pic64 %}</div>\n\n&nbsp;\n\n### RAID-4\n\n带校验的磁盘条带化——数据块级别的磁盘条带化加专用奇偶校验磁盘。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 65.png pic65 %}</div>\n\n### RAID-5\n\n带分布式校验的磁盘条带化。减小了带校验和磁盘的读写压力。\n\n<div style=\"width:66%;margin:auto\">{% asset_img 66.png pic66 %}</div>\n\n&nbsp;\n\n此外，这些RAID技术还可以嵌套使用。比如RAID-0与RAID-1的嵌套：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 67.png pic67 %}</div>","tags":["backend"],"categories":["os"]},{"title":"第十六章 进程通信","url":"/os/os-ch16.html","content":"\n## 进程通信基本概念\n\n进程通信，简称IPC，是进程进行通信与同步的机制；IPC提供2个基本操作——send(发送操作)与receive(接收操作)；进程通信的流程为：(1)在通信进程间建立通信链路，(2)通过send/receive交互消息；\n\n### 直接通信与间接通信\n\n**直接通信**：send(P,mes)<->receive(Q,mes)，进程在直接通信时必须指明发送/接收的对象是谁。\n\n**间接通信**：通过操作系统维护的消息队列(内核中)实现进程间消息的接收与发送。每个消息队列都有一个唯一的标识，只有共享了相同消息队列的进程才可以通信。\n\n### 阻塞通信与非阻塞通信\n\n阻塞通信\n\n* 发送：发送进程在发送消息后进入等待，直到接收进程成功接收。\n* 接收：接收进程在请求消息后进入等待，直到接收到消息。\n\n非阻塞通信\n\n* 发送：发送进程在发送完消息后不用等待，可继续进行其他操作。\n* 接收：接收进程在请求消息后如果没有收到消息不用等待，可继续进行其他操作。\n\n## 信号与管道\n\n### 信号\n\n进程间软件中断通知与处理机制。信号机制的实现如下图。\n\n<div style=\"width:42%;margin:auto\">{% asset_img 54.png pic54 %}</div>\n\n### 管道\n\n进程间基于内存文件的通信机制。是一种间接通信机制。\n\n* 创建管道：pipe(rgfd)；rgfd是两个文件描述符组成的数组，其中rgfd[0]是读文件描述符、rgfd[1]是写文件描述符。\n* 读管道：系统调用read(fd, buffer, n)\n* 写管道：系统调用write(fd, buffer, n)\n\n## 消息队列与共享内存\n\n### 消息队列\n\n操作系统维护的以字节序列为基本单位的间接通信机制。\n\n### 共享内存\n\n操作系统通过将同一物理内存区域映射到多个进程的地址空间来实现进程通信。需要额外的同步互斥机制。是进程间最快速的通信机制。\n\n## D-bus机制\n\n&nbsp;\n\n## Binder机制\n\n### 一次拷贝\n\n<div style=\"width:68%;margin:auto\">{% asset_img 55.png pic55 %}</div>\n\n当进程A向进程B拷贝数据时，首先将进程A的数据从用户空间拷贝到内核空间，再将内核空间中的数据所在内存区域映射到进程B的用户空间，这样使用一次拷贝即可传递进程A的数据到进程B，之所以没有使用共享内存是为了避免同步互斥的开销。","tags":["backend"],"categories":["os"]},{"title":"第十五章 死锁与并发错误检测","url":"/os/os-ch15.html","content":"\n## 死锁的概念\n\n多个进程各自占用部分资源，形成循环等待的现象。\n\n死锁的必要条件：\n\n* 互斥：任何时刻只能有一个进程使用该资源；\n* 持有并等待：进程占用着一个资源，并且还需要等待另外的资源；\n* 非抢占：资源只能由进程使用后自愿释放；\n* 出现了循环等待；\n\n## 死锁处理方法\n\n对死锁的处理采用\"纵深防御\"的思路——死锁预防、死锁避免、死锁检测与恢复；死锁通常由应用程序处理，操作系统层面不考虑死锁。\n\n### 死锁预防\n\n限制并发进程对资源的请求，使操作系统在任何时刻不满足死锁的必要条件；但资源的利用效率低。\n\n### 死锁避免\n\n**安全进程序列**：对一列进程$\\{\\rm{P_1}, \\cdots , \\rm{P_n}\\}$，$\\rm{P_i}$未来需要的资源量(声明所需资源的最大量减去已占用的资源量)<=当前可用资源量+所有$\\rm{P_j(j<i)}$的资源量对所有的$\\rm{i}$均成立，则这个进程序列称为安全进程序列。\n\n系统处于安全状态，即对所有占用资源的进程，存在一个安全进程序列。\n\n于是当进程请求资源时，操作系统判断分配资源之后是否还处于安全状态，如果是，则分配进程申请的资源。\n\n### 死锁检测\n\n检测操作系统是否出现死锁，根据占用资源的进程是否存在一个安全进程序列，如果不存在，操作系统就会出现死锁。","tags":["backend"],"categories":["os"]},{"title":"第十四章 信号量与管程","url":"/os/os-ch14.html","content":"\n## 信号量\n\n信号量是操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象的数据类型，由一个整型变量与两个原子操作(P操作——申请资源，V操作——释放资源)组成：\n\n```c++\nclass Semaphore{\n    int sem;\n    WaitQuene q;//等待队列q\n}\n\nSemaphore::P(){\n    sem--;\n    if(sem<0){\n        q.add(t);//进程t\n        block(t);\n    }\n}\n\nSemaphore::V(){\n    sem++;\n    if(sem<=0){\n        q.remove(t);\n        wakeup(t);\n    }\n}\n```\n\nP、V操作由操作系统实现，执行过程中不会被打断，从而保证其原子性。借助P、V操作的原子性，可以更简单地实现同步互斥。下面介绍信号量的使用。\n\n### 信号量的使用\n\n实现互斥的伪代码如下：\n\n```c++\nmutex= new Semaphore(1);\n```\n\n对于需要互斥访问的临界区代码：\n\n```c++\nmutex->P(t);\n//Critical Section\nmutex->V();\n```\n\n注意：必须按照先P操作后V操作的顺序使用，且P操作与V操作必须成对使用。\n\n&nbsp;\n\n实现条件同步的伪代码如下：\n\n```c++\ncondition=new Semaphore(0);\n```\n\n例如：必须等线程B执行完X，线程A才能执行N；这样使用信号量：\n\n对线程A：在N之前插入P操作，对线程B：在X后插入V操作，即：\n\n```c++\n//线程A\n----------------\n|     M        |\n----------------\ncondition->P();\n----------------\n|     N        |\n----------------\n//线程A\n\n//线程B\n----------------\n|     X        |\n----------------\ncondition->V();\n----------------\n|     Y        |\n----------------\n//线程B\n```\n\n### 用信号量解决生产者-消费者问题\n\n问题分析：\n\n* 任何时刻只能有一个线程操作缓冲区(互斥访问)；\n* 缓冲区空则消费者必须等待生产者(条件同步)；\n* 缓冲区满则生产者必须等待消费者(条件同步)；\n\n每个约束条件对应一个信号量：(二进制)信号量mutex、(资源)信号量fullBuffers与(资源)信号量emptyBuffers。定义如下数据结构：\n\n```c++\nclass BoundedBuffer{\n    Semaphore mutex;\n    Semaphore fullBuffers;\n    Semaphore emptyBuffers;\n    char data[n];//n为缓冲区大小\n}\n```\n\n初始化如下：\n\n```c++\nbuffer= new BoundedBuffer(1,0,n);\n```\n\n定义两个方法——生产(Deposit)与消费(Remove)：\n\n```c++\nBounderBuffer::Deposit(c){\n    emptyBuffers->P();\n    mutex->P();\n    write(data, & c);\n    mutex->V();\n    fullBuffers->V();\n}\n\nBounderBuffer::Remove(){\n    fullBuffers->P();\n    mutex->P();\n    move(data, & c);\n    mutex->V();\n    emptyBuffers->V();\n}\n```\n\n从上面的运用中可以看出，使用信号量来解决同步互斥问题对程序编写者要求较高，编写容易出错。一旦没有考虑周全，就会导致死锁。\n\n## 管程\n\n管程是一种用于多线程互斥访问共享资源的程序结构。它采用面向对象的编程方法，将对共享资源的P、V操作写入对共享资源操作的方法。与临界区不同的是，正在管程中的线程可以放弃管程的互斥访问，等待事件出现时恢复(线程在临界区中执行时，只能临界区执行完后退出临界区)。\n\n利用管程来定义访问数据的方法，从而不用在访问时考虑P、V操作。管程包括锁与条件变量(可选)：\n\n* 锁用于控制管程代码的互斥访问，因此在管程外会有一个等待队列；\n* 每个条件变量对应一种等待原因，都有一个等待队列(这是在管程内部的)；另外，条件变量有两种操作——Wait操作与Signal操作；对条件变量的定义如下：\n\n```c++\nclass Condition{\n    int numWaiting;\n    WaitQuene q;\n}\n\nCondition::Wait(lock){\n    numWaiting++;\n    //自身阻塞在条件变量的等待队列中\n    q.add(t);\n    //释放管程的互斥访问\n    lock.Release();\n    //去唤醒其他线程\n    schedule();\n    //条件满足后重新获取锁\n    lock.Acquire();\n}\n\nCondition::Signal(){\n    if(numWaiting>0){\n        q.remove(t);//进程t\n        //唤醒管程外等待的线程进入管程\n        wakeup(t);\n        numWaiting--;\n    }\n}\n```\n\n### 用管程解决生产者-消费者问题\n\n```c++\nclass BoundedBuffer{\n    Lock lock;\n    int count=0;\n    Condition notFull, notEmpty;\n    char data[n];//n为缓冲区大小\n}\n\nBoundedBuffer::Deposit(c){\n    lock.Acquire();\n    //检查是否还有空闲区，如果缓存写满了就等待，直到notFull的条件满足。\n    while(count==n)\n        notFull.Wait(lock);\n    write(data, & c);\n    count++;\n    notEmpty.Signal();\n    lock.Realease();\n}\n\nBoundedBuffer::Remove(c){\n    lock.Acquire();\n    while(count==0)\n        notEmpty.Wait(lock);\n    move(data, & c);\n    count--;\n    notFull.Signal();\n    lock->Release();\n}\n```\n\n### 条件变量释放后的处理\n\n根据条件变量释放后处理的不同，管程分为Hansen管程与Hoare管程；Hansen管程会等到当前线程执行完之后再去执行条件变量唤醒的线程，而Hoare管程会立即切换到条件变量唤醒的线程执行。在实际操作系统中，使用Hansen管程因为其效率更高。\n\n### 用管程解决读者-写者问题\n\n读者-写者问题约束如下：\n\n* 同一时刻，允许多个读者同时读；\n* 读写互斥；\n* 写写互斥；\n\n定义两个基本方法——Read与Write，4个条件变量；\n\n```c++\nclass Database{\n    int AR;//active reader\n    int AW;//active writer\n    int WR;//waiting reader\n    int WW;//waiting writer\n    Lock lock;\n    Condition okToRead, okToWrite;\n    char * data;\n}\n\nDatabase::Read(){\n    while (AW+WW);//wait until no writers.\n    StartRead();\n    read(data);\n    //check out: wake up waiting writers.\n    DoneRead();\n}\n\nDatabase::StartRead(){\n    lock.Acquire();\n    while((AW+WW)>0){\n        WR++;\n        okToRead.wait(lock);\n        WR--;\n    }\n    AR++;\n    lock.Release();\n}\n\nDatabase::DoneRead(){\n    lock.Acquire();\n    AR--;\n    if(AR==0 && WW>0)\n        okToWrite.Signal();\n    lock.Release();\n}\n\nDatabase::Write(){\n    while (AR+WR);//wait until no reader.\n    StartWrite();\n    write(data);\n    //check out: wake up wating reader.\n    DoneWrite();\n}\n\nDatabase::StartWrite(){\n    lock.Acquire();\n    while((AW+AR)){\n        WW++;\n        okToWrite.wait(lock);\n        WW--;\n    }\n    AW++;\n    lock.Release();\n}\n\nDatabase::DoneWrite(){\n    lock.Acquire();\n    AW--;\n    if(WW>0)\n        okToWrite.Signal();\n    else if(WR>0)\n        okToRead.broadcast();//使所有在该条件上等待的进程都被释放并进入队列(读读不互斥)\n    lock.Release();\n}\n```","tags":["backend"],"categories":["os"]},{"title":"第十三章 同步互斥","url":"/os/os-ch13.html","content":"\n## 同步互斥的背景\n\n同步互斥是操作系统中协调进程协作与相互关系的一种机制。对于并发的进程，存在多个进程共享资源的情形，那么这时进程执行就会存在不确定性与不可重现性；然而，进程并发执行具有节约资源(共享)、高速等优点，因此为了使并发的进程能够正确运行，操作系统使用了同步互斥机制。\n\n### 原子操作\n\n一次不存在任何中断与失败的操作。\n\n操作系统需要利用同步互斥机制在并发执行的同时，保证一些操作是原子操作。\n\n实现同步互斥机制最简单有效的方案为利用两个原子操作实现一个锁：\n\n* Lock.Acquire()：在锁释放前请求锁的进程一直处于等待状态；如果多于一个进程都在等待同一个锁，在锁释放之后，只有一个进程能够获得锁。\n* Lock.Release()：解锁并唤醒任何等待中的进程。\n\n事实上，这就是用两个原子操作的锁放在一段需要是原子操作的代码两端，使这段代码的执行是原子操作。开头的锁操作称为进入临界区，代码后的解锁操作称为退出临界区。\n\n### 进程的交互关系\n\n根据进程相互感知程度的不同，进程之间的交互分为3种关系，如下表所示：\n\n|             相互感知的程度             |     交互关系     |             进程间的影响             |\n| :------------------------------------: | :--------------: | :----------------------------------: |\n|  相互不感知(完全不了解其他进程的存在)  |       独立       |         进程间的操作互不影响         |\n| 间接感知(双方与第三方交互，如共享资源) | 通过共享进行协作 |    进程的结果依赖于共享资源的状态    |\n|     直接感知(双方直接交互，如通信)     | 通过通信进行协作 | 进程的结果依赖于从其他进程获取的信息 |\n\n此时进程间会出现如下三种状态。\n\n* 互斥：一个进程占用资源，其他的进程不能使用该资源；\n* 死锁：多个进程各自占用部分资源，形成循环等待；\n* 饥饿：进程一直得不到资源。\n\n## 同步方法\n\n为了保证只有一个进程进入临界区执行，需要在进入临界区之前检查进程是否能够进入临界区，若可以进入，接下来设置相应\"进入临界区\"的标志。进程使用完资源之后，退出临界区，去除相应\"进入临界区\"的标志。\n\n综上，临界区的访问规则为空闲则入、忙则等待、有限等待与让权等待(可选)。\n\n### 禁用硬件中断\n\n没有中断，没有上下文切换，因此没有并发。\n\n* 硬件将中断处理延迟到中断被启用之后；\n* 现代计算机体系结构都提供指令来实现禁用中断；\n\n因此，进入临界区就是禁用所有中断并保存标志位；退出临界区就是启用所有中断并恢复标志位。禁用硬件中断可有效实现同步互斥，但是也有如下局限性：\n\n* 禁用中断后，进程无法被停止；会使整个操作系统暂停，导致其他进程处于饥饿状态；\n* 临界区执行时间可能很长；\n\n因此，禁用硬件中断的方法须小心使用。\n\n### 基于软件的同步\n\n复杂(需要两个进程间的共享数据项)，是一个忙等待(浪费CPU时间)。\n\n### 高级抽象的同步方法\n\n原子操作指令1：测试与置位指令(TS指令)——从内存单元读取值并返回，期间将内存单元置1；\n\n该指令的伪代码操作如下：\n\n```c\nbool TestAndSet(bool * target)\n{\n    bool rv=* target;\n    * target=true;\n    return rv;\n}\n```\n\n\n\n原子操作指令2：交换指令(exchange)，顾名思义，交互内存中的两个值。\n\n基于上述两个原子操作指令，来实现锁。\n\n**使用TS指令实现锁**：\n\n```c++\nclass Lock{\n    bool value=0;\n}\n\nLock::Acquire(){\n    while (TS(& value)){\n        //run\n    }\n}\n\nLock::Release(){\n    value=0;\n}\n```\n\n但是上述实现是一种忙等待，改进如下：\n\n```c++\n//增加一个等待队列\nclass Lock{\n    bool value=0;\n    WaitQuene q=NULL;\n}\n\n//当进程申请不到资源时，进入等待队列，执行进程调度\nLock::Acquire(pcb){\n    while (TS(& value)){\n        q.add(pcb);\n        schedule();\n    }\n}\n\n//当占用资源的进程使用完资源后，释放锁，并且将某个等待的进程从等待队列中移除并将其唤醒\nLock::Release(pcb){\n    value=0;\n    q.remove(pcb);\n    wakeup(pcb);\n}\n```","tags":["backend"],"categories":["os"]},{"title":"第四步 Web服务器处理请求","url":"/cn/cn-step4.html","content":"\n## 服务器程序的结构\n\n为保证服务器同时与多个客户端进行通信，服务器启动多个服务器程序一对一地与客户端交互。服务器程序的结构如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n服务器程序分为两个模块：等待连接模块与通信模块；在服务器启动并完成初始化操作后，它就会运行等待连接模块；等待连接模块创建套接字，然后进入等待连接的暂停状态，直到客户端发起连接；等待连接模块恢复运行并接受连接，启动客户端通信模块，传递套接字的副本给通信模块；\n\n通信模块使用已连接的套接字与客户端通信。由于在服务器上，一个端口可能与多个客户端建立通信，因此会有多个套接字的端口号相同，于是不能只通过端口号来指定套接字(在客户端可以这样做)，还需要加上源IP，因为各个客户端的IP肯定是不同，每个套接字与客户端一一对应，这样就能准确指定套接字。\n\n## 服务器的接收操作\n\n数据经网卡、MAC层、IP层到达TCP层(对于HTTP消息来说)，TCP的数据收发详见第二章，只剩下TCP的断开操作还未介绍；TCP断开操作称为四次挥手，示意图如下：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 21.jpg pic21 %}</div>\n\n&nbsp;\n\nHTTP协议规定服务器返回响应消息后主动断开连接，于是服务器端执行TCP断开操作；服务器端发送FIN位置1的TCP头部(表面自己已经没有要发送的消息)，客户端收到后返回确认接收的TCP头部，客户端仍然可以给服务器端发送消息，等客户端处理完数据可以结束与服务器端的连接时，客户端发送FIN位置1的TCP头部，处于等待状态的服务器返回确认接收的TCP头部，到此TCP连接彻底断开。\n\n## 服务器解析请求消息并作出响应\n\nWeb服务器公开的目录并不是磁盘上的实际目录，而是如下图所示的虚拟目录：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\nWeb服务器根据请求消息中的源IP、用户名&密码、客户端域名进行访问控制；只有满足条件的请求消息才会对请求消息作出响应。\n\n对于运行访问的请求消息，若URL指定HTML文件或图片，直接将文件内容作为响应消息返回客户端即可；若URL指定的是一个程序，则服务器要从消息中获取运行程序所需参数(方法为GET，参数在URL之后；方法为POST，参数在消息体中)并运行程序然后将输出结果作为响应消息返回客户端。\n\n接下来Web服务器将响应消息委托给协议栈发送给客户端。\n\n## 浏览器接收响应并显示内容\n\n&nbsp;","tags":["backend"],"categories":["cn"]},{"title":"第三步 服务器端的局域网","url":"/cn/cn-step3.html","content":"\n## 防火墙的结构与原理\n\n防火墙的基本思路：只允许发往特定服务器的特定应用程序的网络包通过，屏蔽其他的网络包。其中最主流的方式为包过滤，它根据源IP与目的IP、源端口与目的端口、控制位等信息来判断是否允许网络包通过。\n\n## 负载均衡\n\n若对服务器的访问量上升，则需要多台服务器来分担负载，即分布式架构。要采用这种方法，需要一种机制将客户端发送的请求分发到不同的服务器上，最简单的方式是通过DNS服务器来分配——由于客户端访问Web服务器时需要先向DNS服务器查询Web服务器的IP地址，这时在DNS服务器中对Web服务器的域名填写多个IP地址，则每次查询时DNS服务器都会按顺序(循环地)返回不同的IP地址，即轮询。但是，DNS服务器不能确认某个IP地址对应的Web服务器是否正常工作，因此，如果某台Web服务器出现故障，DNS仍然会给客户端返回这台Web服务器的IP地址，那么客户端发送的请求就无法被处理。\n\n另外，由于一些操作需要发送多次HTTP请求，这就导致需要在一个Web服务器上完成这多个请求，然而轮询会把这些HTTP请求分发到不同的Web服务器上。\n\n为避免上述问题，需要使用名为负载均衡器的设备，对于相关HTTP请求消息，客户端发送HTTP请求消息时在表单里面加上表示关联的信息，或者对HTTP规格进行扩展，在HTTP头部字段加上用来判断相关性的信息。若请求消息相关，负载均衡器将不考虑Web服务器的负载而是必须将相关的请求发送到同一Web服务器。\n\n同样地，要使用负载均衡器，要将Web服务器域名对应的IP在DNS服务器中设置为负载均衡器的IP。\n\n## 缓存服务器\n\nWeb服务器需要检查网址与访问权限，还有一些在页面填充数据的操作，因此将页面返回客户端的时间较长；相对地，缓存服务器只需要将保存在磁盘上的数据读取出来发送给客户端即可。使用缓存服务器既减轻了Web服务器的负担，又缩短了请求响应的时间。\n\n### 缓存服务器的工作过程\n\n与负载均衡器相同，缓存服务器也需要代替Web服务器被注册到DNS服务器上；因此，对于使用了缓存服务器的Web服务器，客户端的请求会到达缓存服务器，缓存服务器接收请求消息，接收操作下一章介绍；然后，缓存服务器会检查请求消息的内容，判断请求的数据是否已经在缓存中；\n\n* 不在缓存中。缓存服务器在HTTP请求消息头部添加一个Via字段，表示这个消息经过缓存服务器转发，然后将消息转发给Web服务器(如果有多台Web服务器，可根据请求消息中URL的目录名来判断)，示意图如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\n缓存服务器转发请求消息时，缓存服务器相当于客户端，会创建套接字并连接Web服务器的套接字，然后转发请求消息并接收Web服务器的响应消息，然后在响应消息中加上Via字段表示响应消息是经缓存服务器中转的；最后，响应消息会保存在缓存服务器中，并记录保存的时间。\n\n* 在缓存中。缓存服务器在HTTP请求头部添加一个If-Modified-Since字段(内容为缓存数据被保存的时间)并将请求转发给Web服务器，Web服务器比较请求数据最后的更新时间与缓存数据被保存的时间来判断Web服务器上的请求的数据与缓存服务器上保存的请求的数据是否一致。\n  * 若一致。缓存服务器将请求的数据返回给客户端，同样加上Via字段；示意图如下。\n  * 若不一致。Web服务器返回最新的请求数据，缓存服务器加上Via字段转发给客户端。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n这种在Web服务器端缓存数据的代理机制，称为反向代理。\n\n**透明代理**：缓存服务器在判断转发的目标Web服务器时，还可以查看请求消息头部，从而可以将消息转发给任一Web服务器。\n\n## 内容分发服务\n\n缓存服务器放在Web服务器端虽然可以减轻Web服务器的负载，但无法减少互联网中的流量。从这一点来看，将缓存服务器放在客户端更有效，但是Web服务器的运营者无法控制客户端的缓存服务器。于是出现了内容分发服务，一些专门从事相关服务的厂商来部署缓存服务器，并租借给Web服务器运营者。\n\n而互联网中有很多缓存服务器，需要找到离客户端最近的一个。\n\n* 一种方法是DNS服务器使用路由表的路由信息计算大致距离，并向客户端返回距离(收到客户端查询请求的DNS服务器)最近的缓存服务器的IP地址。这种计算比较粗略；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n* 另一种方法是使用重定向服务器分配访问目标；当使用重定向告知客户端最近的缓存服务器时，首先需要将重定向服务器注册到DNS服务器上。于是，客户端会将HTTP请求消息发送到重定向服务器上。重定向服务器和刚才一种方法中的DNS服务器一样，收集了来自各个路由器的路由信息，并根据这些信息找到离客户端最近的缓存服务器，然后将缓存服务器的地址放到Location字段中返回响应。这样，客户端就会重新去访问指定的缓存服务器了。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n同时，每次客户端发送请求时缓存服务器都需要询问Web服务器缓存的数据是否一致，而更好的方法是每次Web服务器中数据发生改变时主动联系缓存服务器，使缓存服务器上的内容时刻保持最新。","tags":["backend"],"categories":["cn"]},{"title":"第十二章 CPU多核调度","url":"/os/os-ch12.html","content":"\n## CPU多核调度概述\n\n### 单队列多核调度\n\n* 缺乏可扩展性：多个CPU核均对一个就绪队列进行读写操作；\n* 缺乏缓存亲和性：CPU核对进程的缓存不能得到有效利用；\n\n如下图，4个CPU核对5个进程的调度：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 46.png pic46 %}</div>\n\n为了提高调度算法的缓存亲和性，尽量让进程在同一个CPU核上运行(在保持对该进程的缓存亲和性时，可能会牺牲其他进程的缓存亲和性)；如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 47.png pic47 %}</div>\n\n### 多队列多核调度\n\n* 每个CPU核维护一个就绪队列，各CPU核之间的调度相互独立；\n* 会出现负载不均衡；\n\n如下图，开始给进程A、C分配CPU核0，给进程B、D分配CPU核1；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 48.png pic48 %}</div>\n\n一段时间之后，进程C结束，进程A独占CPU核0；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 49.png pic49 %}</div>\n\n一段时间之后，进程A结束，CPU核0处于空闲状态，而CPU核1还在运行着两个进程，此时就出现了负载不均衡；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 50.png pic50 %}</div>\n\n为了解决出现的负载不均衡问题，就要将繁忙的CPU核上的进程迁移到空闲的CPU核上去；比如上幅图，可以将进程B移到CPU核0上，然后系统负载均衡；而对于进程A独占CPU核0的情形，调度就比较复杂，此时操作系统该如何决定发起迁移？\n\n一般采用一种叫做\"工作窃取\"的技术；让执行的进程数目少的CPU核\"不定期\"地查看其他CPU核的就绪队列，从那些长的就绪队列中\"拉取\"一个或多个进程，从而实现负载均衡。而这个查看的时刻一般选在CPU核的进程进行切换的时候。\n\n## O1调度器\n\nLinux系统中进程有140种优先级，使用长140的比特数组来记录优先级；每个(优先级)比特对应该优先级的FIFO进程队列(若一个优先级下有进程队列，则这个优先级对应的bit位置1)，其中run比特数组管理还未运行的就绪态进程，expired比特数组管理运行过的进程；给每个CPU核维护上述两个数组。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 51.png pic51 %}</div>\n\n对于调度时对数组进行的3种基本操作：访问(最高优先级就绪态进程)、(在expired比特数组对应的优先级队列中)插入(刚刚运行过的进程)、(在expired比特数组对应的优先级队列中)删除(刚刚运行过的进程)；分析这些操作的复杂度：\n\n* 访问：在切换进程时，会寻找最高优先级的就绪态进程，而这等价于寻找一个比特数组中为1的最高位比特，CPU可在O(1)时间内找出一个字节中为1的最高位比特；因此，随机访问的复杂度为O(1)；\n* 插入：在队尾插入，复杂度O(1)；如果插入前在expired数组的该优先级下没有进程队列，则将expired数组的该优先级对应的比特置1；\n* 删除：在队头删除，复杂度O(1)；如果删除后在run数组的该优先级下没有进程队列，则将run数组的该优先级对应的比特置0；如果run数组所有比特均为0，则交换run数组与expired数组；并且，每个CPU核不定期检查自己的负载，如果自己负载较其他CPU核轻，则\"拉取\"其他CPU核上的就绪态进程；\n\n## CFS调度\n\n完全公平的调度。通过进程消耗的CPU时间(标准化之后的虚拟CPU时间)来确定调度哪个进程；\n\n分配给进程的运行时间=调度周期×进程权重/所有进程权重之和；但是调度周期一直处于动态变化中，通过这个式子确定分配给进程的运行时间比较麻烦，因此引入虚拟运行时间vruntime=实际运行时间×1024/进程权重；这样既考虑到分配CPU运行时间较少的进程(对它给予一定补偿)，有考虑到高优先级的进程。\n\nLinux系统(每个CPU核)采用红黑树来维护进程的vruntime，需要调度时，从红黑树中选取vruntime最小的进程投入CPU中执行。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 52.png pic52 %}</div>\n\n为避免已经运行一段时间的进程在新的进程进入后出现\"饥饿\"现象=>不能将新进程的vruntime设置为0，而应该设置为红黑树中就绪态进程的最小vruntime。\n\n对于休眠了一段时间的进程，由于其他进程的vruntime一直增加而休眠进程的vruntime并未增加，因此在休眠进程被唤醒后可能会长时间抢占其他进程的CPU资源=>在休眠进程被唤醒后应该以红黑树中就绪态进程的最小vruntime为基准重新设置其vruntime值。\n\n在负载轻的CPU核\"拉取\"负载重的CPU核上的就绪态进程时，它的vruntime需要进行调整以\"适应新的环境\"=>记进程的vruntime为vrt，它所在CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_1，\"拉取\"此进程的CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_2，则此进程新的vruntime=vrt-min_vrt_1+min_vrt_2；\n\n由计算vruntime的式子可以看到，CPU的运行时间长了之后，各进程的实际运行时间也会很长，这是算出的vruntime值可能会产生溢出，考虑到vruntime的作用是作为调度的依据——选择最小vruntime的进程=>填在红黑树中的节点值实际上是每个进程的vrt-min_vrt；\n\n## BFS调度算法\n\nBFS调度算法是时间片轮转算法的变种。大致形式如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 53.png pic53 %}</div>\n\nBFS算法在多核CPU的情形下使用单就绪队列(链表)，增加了队列互斥访问的开销，但减少了维护负载均衡的开销。\n\nBFS算法设定了103个优先级(100个静态的实时优先级与3个普通的优先级)，每个优先级维护一个就绪进程队列。每个CPU核计算进程的虚拟截止时间时，对于进程上一次执行的CPU核，会适当减小其虚拟截止时间。","tags":["backend"],"categories":["os"]},{"title":"第十一章 CPU调度","url":"/os/os-ch11.html","content":"\n## CPU调度概念\n\nCPU的调度要考虑以下几个问题：\n\n* 调度的时机；\n* 从就绪队列中挑选下一个占用CPU运行的进程；\n* 从多个可用CPU里面挑选就绪进程可使用的CPU资源。\n\n操作系统通过调度程序来完成CPU的调度，操作系统运行调度程序的条件：\n\n* 进程从运行状态切换到等待状态；\n* 进程退出；\n\n对非抢占系统：只有当进程主动放弃CPU时，操作系统才能运行调度程序；\n\n对抢占系统：如果分配给进程的时间片用完或者优先级更高的等待进程切换到就绪状态，那么在抢占系统中，操作系统就会运行调度程序；\n\n## 调度准则\n\n响应时间指标；\n\n* 减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户。\n* 减少平均响应时间的波动；\n\n吞吐量指标；\n\n* 增加吞吐量；\n* 减少等待时间；\n\n公平性指标；\n\n* 保证每个进程占用相同的CPU时间；\n* 保证每个进程的等待时间相同；\n\n## 调度算法\n\n### 先来先服务算法\n\n&nbsp;\n\n### 短进程优先算法\n\n&nbsp;\n\n### 最高响应比优先算法\n\n响应比R=(w+s)/s，其中w为等待时间、s为执行的时间，然后选择就绪队列中响应比R值最高的进程。该调度算法不可抢占、关注进程的等待时间从而防止执行时间长的进程出现长时间等待的情况(\"饥饿\")。\n\n### 时间片轮转算法\n\n时间片：分配CPU资源的基本时间单元；\n\n给每个进程分配一个时间片占用CPU，一个时间片结束之后，按照先来先服务算法切换到下一个就绪进程。该调度算法存在额外的上下文切换造成的开销，需要选择一个合适的时间片长度(一般是10ms，能够保证上下文切换的开销占CPU处理的1%)\n\n### 多级反馈队列算法\n\n由于没有一个调度算法能够满足所有的需求(有的希望响应迅速，有的希望处理时间短)；为解决这个问题，操作系统使用多个队列，不同需求的就绪进程放到不同的就绪队列，根据需求的不同选择合适的调度算法，各队列按照一定的比例分配CPU处理时间；\n\n进一步改进，让各个队列之间存在交流，这就是多级反馈队列。\n\n* 时间片大小随优先级的增加而增加；\n* 若进程在当前的时间片内没有完成，则降到下一(优先)级就绪队列；\n\n算法执行过程如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n\n&nbsp;\n\n### 公平共享调度算法\n\n强调资源访问的公平，将用户与进程分组，更重要的用户的进程分配更长的运行时间；同时保证不重要的组无法垄断资源；未使用的资源安装比例分配，没有使用完所分配资源的组获得更高的优先级。\n\n## 进程切换中的调度\n\n调度程序在进程切换时被调用，具体的使用时机见下图：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 45.png pic45 %}</div>\n\n## 实时调度\n\n对于实时操作系统，它的正确性依赖于时间与功能两方面。实时操作系统的性能主要考虑时间约束的及时性，而速度与平均性能相对不重要。因此，实时操作系统要求时间约束的可预测性。\n\n时间约束分为硬时限与软时限；硬时限：错过任务时限会导致严重后果，必须验证操作系统在最坏情况下能够满足时限；软时限：通常能满足任务时限，若有时不能满足，则降低要求。\n\n关于实时调度的调度算法，有以下两个：速率单调调度算法与最早截止时间优先算法。\n\n速率单调调度算法：先执行周期最短的任务；\n\n最早截止时间优先算法：先执行截止时间最早的任务；\n\n## 多核CPU的进程分配\n\n对于多个处理器的CPU，有下面两种方式来分配进程：\n\n* 静态进程分配：进程从开始到结束都在一个固定的处理器上运行，每个处理器有自己的队列，此时调度的开销很小；\n* 动态进程分配：进程在执行过程中可分配到任一空闲处理器上运行，所有处理器共享一个就绪队列，由于进程会在不同的处理器间切换，因此调度开销较大，然而这种进程分配能够保证各处理机是负载均衡的。\n\n## 优先级反置\n\n低优先级的进程占着高优先级申请的资源使得高优先级的进程进入等待状态，而这时优先级处于前面两个优先级之间的进程抢占了低优先级的进程；这一现象称为优先级反置。解决优先级反置有下面两种处理方法：\n\n**优先级继承**：占用资源的低优先级进程在被抢占时继承申请资源的高优先级进程的优先级，并在释放资源后，优先级将为原来低的优先级；\n\n**优先级天花板协议**：占用资源进程的优先级与所有可能申请该资源的进程的最高优先级相同；","tags":["backend"],"categories":["os"]},{"title":"第十章 进程与线程控制","url":"/os/os-ch10.html","content":"\n## 进程切换\n\n暂停当前运行进程(当前运行进程从运行态变为其他状态)，调度另一个进程(也有可能还是刚刚运行的进程)从就绪状态变成运行状态。\n\n进程切换前，保存被暂停进程的上下文(寄存器、CPU状态)；进程切换后，恢复被调度进程的上下文(寄存器、CPU状态)。\n\n如下是一个进程切换的例子：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 40.png pic40 %}</div>\n\n\n\n为了对进程进行切换，操作系统将相同状态的PCB放置在同一队列。如下图所示：有就绪(进程)队列、等待(进程)队列以及僵尸队列(要退出的进程)。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n当并发的进程数目太多时，使用双向链表来组织PCB使得查找的时间过长，那么这时采用Hash表，Hash值相同PCB组成双向链表，再通过数组将这些双向链表组织起来。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n实现进程调度的函数为schedule。\n\n## 进程创建\n\n对于unix类系统，创建进程采用fork()与exec()两个系统调用来完成；\n\n* fork()将一个进程复制为两个进程；被复制的进程称为父进程，复制得到的进程称为子进程；复制的信息包括父进程的管理结构，线性地址空间与除eax(eax置0)外所有寄存器的值；\n* exec()用新程序来重写当前进程；\n\nQ：在linux系统中，如果任何一个创建的进程都必须(在用户态)通过复制其他进程得到，那么第一个进程是怎么来的呢？\n\nA：第一个进程由操作系统的设计者写好，这个进程就是进程0。\n\n### 创建线程\n\n创建线程使用pthread_create函数；事实上，在Linux系统中，创建线程就是创建进程，只不过通过参数指定使该进程与其他进程共享一些资源(地址空间，文件等)，而堆栈、寄存器这些私有数据则相互独立。因此，pthread_create函数创建线程与fork系统调用创建进程最终都会调用do_fork来执行具体的操作，只是传入的参数不同，从而进行的操作也不同。\n\n下面具体说说创建线程时创建的进程与创建进程时创建的进程的区别；\n\n之前介绍过，每个进程都有一个进程控制块，包含着操作系统管理控制进程运行所用的信息集合；具体实现就是一个结构体，这个结构体存放指向各种信息的指针(也就是说：进程控制块并不直接包含这些信息)；那么，在调用fork创建子进程时，子进程具有父进程的所有可共享信息的拷贝，而使用pthread_create函数创建线程时，创建的子进程的进程控制块只是复制了父进程进程控制块的指向共享信息的指针；\n\n如下图所描述：\n\n<div style=\"width:86%;margin:auto\">{% asset_img 43.png pic43 %}</div>\n\n\n\n注：上图来自极客时间趣谈linux操作系统\n\n现在来分析创建进程的完整过程；\n\n* 分配进程控制块数据结构；\n* 创建进程的内核堆栈；\n* 设置进程的地址空间(如果是创建线程则共享父进程的地址空间)；\n* 修改子进程的状态为不可中断等待状态(还未进行进程加载)；\n\n## 进程加载\n\n将刚刚分配子进程的地址空间重写，其中包括代码段、数据段、堆与栈等等；使用exec调用来实现；\n\n## 进程等待与退出\n\nwait系统调用用于父进程等待子进程的结束；子进程结束时通过exit()向父进程返回一个值，父进程通过wait()接受并处理返回值。\n\n* 当子进程存活时，如果父进程调用了wait，则父进程进入等待状态，等待子进程的返回结果。当子进程结束调用了exit()后，父进程被唤醒，将子进程exit()的返回值作为父进程wait()的返回值；\n* 如果父进程调用wait时已有结束的子进程，wait()立即返回这些已经结束的子进程调用exit()返回值中的一个；\n* 若无子进程存活，wait()立刻返回；\n\nexit被称为有序终止；\n\n* exit()返回的结果作为父进程下一步处理的参数；\n* 进程各种资源的回收(打开的文件，分配的内存空间以及大部分与进程相关的数据结构)；\n* 检查父进程是否存活，若父进程存活，自身进入僵尸状态，等待父进程处理；否则，释放所有的数据结构，进程结束；\n* 清理所有处于僵尸状态的子进程；","tags":["backend"],"categories":["os"]},{"title":"第九章 进程与线程","url":"/os/os-ch9.html","content":"\n## 进程的概念\n\n**进程**：具有一定独立功能的程序在一个数据集合上的一次动态执行过程；\n\n程序是有序代码的集合，进程是程序的执行。\n\n## 进程控制块\n\n**进程控制块(PCB)**：操作系统管理控制进程运行所用的信息集合。包含以下信息：\n\n* 调度进程与处理机使用情况；\n* 进程间通信相关的各种标识；\n* 指向进程映像存储空间的数据结构；\n* 进程使用的系统资源；\n* 数据结构连接信息；\n\n## 进程的状态\n\n进程的生命周期划分：创建、执行、等待、抢占、唤醒与结束；这些不同周期的转换如下图所示：\n\n<div style=\"width:32%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n每种状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (1)  | 系统初始化；<br />用户请求创建一个新进程；<br />正在运行的进程调用了创建进程的系统调用； |\n| (2)  |                       获得CPU的调度；                        |\n| (3)  | 请求并等待系统服务，无法马上完成；<br />启动某种操作，无法马上完成；<br />需要的数据还未到达； |\n| (4)  |  高优先级进程就绪；<br />操作系统给进程分配的时间片已用完；  |\n| (5)  |               使进程进入等待状态的条件被满足；               |\n| (6)  | 正常退出；<br />错误退出(自愿的)；<br />致命错误(强制性)；<br />被其他进程杀死(强制性)； |\n\n## 进程挂起\n\n**进程挂起**：操作系统将进程从内存移到外存(以节省内存占用)；与之对应的，将进程从外存移入内存称为(进程)激活。\n\n在进程的状态中考虑进程挂起后，就多了就绪挂起与等待挂起两种状态；这时各种状态的转换如下图所示：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n&nbsp;\n\n相比上一节的状态转换，增加的状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (7)  | 操作系统根据当前资源状况和性能要求将就绪态进程对换出去成为挂起就绪态； |\n| (8)  |    没有就绪进程或挂起进程的优先级高于就绪态进程的优先级；    |\n| (9)  |           在抢先式分时系统，高优先级挂起进程就绪；           |\n| (10) |                            同(5)                             |\n| (11) |  其他进程释放了足够内存，且本进程在挂起的进程中优先级最高；  |\n| (12) | 操作系统根据当前资源状况和性能要求将等待态进程对换出去成为挂起等待态； |\n\n&nbsp;\n\n最后，操作系统切换进程的示意图如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## 线程的概念\n\n线程是进程的一部分，描述指令流执行状态。它是进程中指令执行流的最小单元，是CPU调度的基本单位。\n\n线程=进程-共享资源(地址空间，文件等)\n\n对进程与线程作一个比较：\n\n|          进程          |                  线程                  |\n| :--------------------: | :------------------------------------: |\n|      资源分配单位      |              CPU调度单位               |\n| 拥有程序执行完整的资源 | 只独享指令流执行必要的资源(寄存器、栈) |\n\n### 用户线程\n\n用户自己实现，操作系统并不支持多线程。\n\n### 内核线程\n\n进程由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止与管理。","tags":["backend"],"categories":["os"]},{"title":"第八章 面向缓存的页置换算法","url":"/os/os-ch8.html","content":"\n## 访问频率置换算法(FBR)\n\n操作系统维护一个如下形式的栈来存放缓存数据：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n&nbsp;\n\n栈分为3个部分：新区域、中间区域与旧区域；每个缓存块都有一个引用计数，算法具体处理如下：\n\n* 访问的数据在栈中：缓存块被移到栈顶，若缓存块不在新区域，将其引用计数加1；\n* 访问的数据不在栈中：在访问完数据之后；栈的旧区域中引用计数最小的缓存块被移出；将访问的数据放到栈顶，其引用计数置1；\n\nFBR算法的问题：需要调整参数。\n\n## LRU-K 2Q页置换算法\n\n考虑一下在进程访问数据时，会有哪些模式的访问：\n\n* 顺序访问：数据块一个接一个被访问，不存在重复访问；\n* 循环访问：所有的数据块按照一定的间隔重复访问；\n* 时间密集访问：最近被访问的数据块是将来最可能被访问的；\n* 概率访问：所有数据块都有固定的概率被访问，且被访问的概率相互独立；\n\n### LRU-K页置换算法\n\nLRU-K算法是LRU算法的扩展；增加了一个数据访问历史记录队列，记录数据被访问的次数以及最近的访问时间戳。\n\n如果[数据]在离开历史记录队列之前被访问了K次，则需要将[数据]加入数据缓存队列：如果缓存队列的长度超过最大缓存长度，则先将缓存队列头部的数据删除，然后在缓存队列的队尾加上[数据]，然后[数据]的访问历史记录从历史记录队列中删除。\n\n若缓存队列的[数据]被访问，则将[数据]放到缓存队列的队尾。\n\n综上，LRU-K页置换算法的示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n其中，LRU-2是综合考虑各种访问模式后的最优选择。\n\n### LRU-2Q页置换算法\n\n进一步改进LRU-2页置换算法；使用两个缓存队列来维护缓存区，示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n数据块第一次被访问时，数据块缓存到FIFO队列的队尾(如果队列没有空闲空间，就删除队列头部的数据)，如果数据块在离开FIFO队列之前被再次访问，则将数据块移到LRU队列的队尾(同样地，如果队列没有空闲空间，就删除队列头部的数据)；若LRU队列的数据块被访问，则将数据块放到LRU队列的队尾。\n\n## LIRS页置换算法\n\n定义两个属性；R(i,t)：从最近一次访问数据块i之后到当前时刻t，被访问的不重复数据块数；IRR(i)：在最近两次访问数据块i之间，被访问的不重复数据块数。\n\n初始时，每个数据块的IRR=inf, R=0；\n\n有数据块(记为i)被访问后，每个数据块的IRR值与R值更新：\n\n* 被访问：IRR(i,t)=R(i,t-1), R=0；\n* 未被访问：IRR(j)不变，R(j,t)=R(j,t-1)+1{最近一次访问数据块j之后到t-1时刻, 数据块i没有被访问过}，j!=i；\n\n**性质1**：每次访问数据块时，除了被访问的数据块，其他数据块的R值均单调不减。\n\nLIRS算法区分IRR值高的数据块与IRR值低的数据块，缓存区分为两个部分：常驻cache与暂驻cache；LIR块(低IRR值的数据块)放在常驻cache，HIR块(高IRR值的数据块)放在暂驻cache；\n\n我们可以看到，**R值其实就是IRR值的一个候选，一旦数据块被访问，它的R值就成为IRR值**；\n\n由于常驻cache与暂驻cache是根据数据块的IRR值进行区分，那么这两个cache的数据块也会因为其IRR值进行调整；因此，当一个HIR块i被访问后，若存在LIR块j，R(j,t)>size且R(j,t)>IIR(i)，则数据块i与数据块j的状态交换。即max{R(j,t)|j in LIR}>max{size, IIR(i)}。\n\nLIRS算法在各种访问模式下均有很好的表现，但是算法要维护两组值(R值与IRR值)使得算法的开销很大；因此，也就有了下面利用栈而不用显式计算R值与IRR值的方法。\n\n<div style=\"width:24%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n维护两个栈：栈S与栈Q；\n\n栈S：LIR块(低IRR值的数据块)与IRR值小于LIR块的最大R值的HIR块(高IRR值的数据块)；\n\n栈Q：常驻cache中的HIR块；\n\n事实上，栈S存放着当前的LIR块与之后有可能成为LIR块的HIR块；下面介绍\"栈裁剪\"操作。\n\n\"栈裁剪\"操作：若栈S底部的LIR块被删除，则一直删除底部数据块直到遇到LIR块。\n\nQ：\"栈裁剪\"操作的合理性是什么?\n\nA：若栈S底部的LIR块被删除，则底部的HIR块将不会成为LIR块。\n\n在证明\"栈裁剪\"操作的合理性之前，注意到如下的性质：\n\n**性质2**：记S栈如下：\n\n```bash\n---------------------------------------\n                q_3 | q_2 | q_1 | q_0 |\n---------------------------------------\n```\n\n那么R(q_i, t)>R(q_i+1, t)，即R(q_i, t)>=R(q_i+1, t)+1。\n\n对栈底部的HIR块i，考虑它再次被访问后：IRR(i)=R(i,t-1)>max{R(j,t-1)|j in LIR} => IRR(i)>=max{R(j,t)|j in LIR}；从而状态交换的条件不成立，因此HIR块不会成为LIR块；\n\n考虑访问各种数据块时算法的反应：\n\n```bash\n|\n|—— LIR块：LIR块移到栈顶，执行\"栈裁剪\"操作；\n|\n|—— HIR块\n     |\n     |—— 在S中：HIR块状态变为LIR块并被移到S栈顶，S栈底LIR块状态变为HIR并从栈S中移到栈Q中，执行\"栈裁剪\"操作；\n     |\n     |—— 不在S中：HIR块移到Q栈顶；\n```","tags":["backend"],"categories":["os"]},{"title":"第七章 全局页面置换算法","url":"/os/os-ch7.html","content":"\n## 工作集置换算法\n\n**工作集**：一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,delta)；t为当前执行时刻，delta为一个页面访问时间窗口，称为工作集窗口；W(t,delta)是时刻t前delta时间窗口内所有访问的页面所组成的集合，|W(t,delta)|就是时刻t前delta时间窗口内访问的页面的数目。\n\n**常驻集**：当前时刻，进程实际驻留在内存中的页面集合。\n\n缺页率与(工作集, 常驻集)的关系：\n\n* 常驻集包含工作集时，缺页率较小；\n* 工作集发生剧烈变动时，缺页率较高；\n* 进程常驻集大小到达一定数目后，缺页率不会明显下降；\n\n**工作集置换算法**：每次访问内存后，换出不在工作集中的页面；\n\n## 缺页率置换算法\n\n**缺页率**：缺页时间间隔的倒数。\n\n**缺页率置换算法**：通过(在发生缺页中断时)调节常驻集大小，使进程的缺页率保持在一个合理的范围内。具体来说，在发生缺页时计算相邻两次缺页的时间间隔delta；对于预先设定的T，若delta>T，操作系统将未被引用的内存页面换出内存，记这些页面的数目为nr，则操作系统收回进程的(nr-1)个未被引用的内存页面，并将缺失页写入剩下的那个未被引用的内存页面；若delta<=T，操作系统为进程申请一个内存页面来写入缺失页(相当于将缺失页增加到工作集中)。\n\n## 抖动与负载控制\n\n**抖动**：并发进程数目太多，使得分配给每个进程的内存页面太少而不能包含工作集；造成了大量缺页，从而操作系统需要频繁地进行置换，降低了CPU的工作效率，进程的运行速度变慢。\n\n操作系统通过调节并发进程数(MPL)来进行负载控制。\n\nCPU利用率与并发进程数的关系大致如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n而图中的Nmax不好确定，因此只能对Nmax作一个估计，使平均缺页间隔时间=缺页异常处理时间的并发进程数，这样可以近似地使系统处于均衡的繁忙状态。","tags":["backend"],"categories":["os"]},{"title":"第六章 局部页面置换算法","url":"/os/os-ch6.html","content":"\n## 页面置换算法概述\n\n根据页面置换算法可借用的外界条件，将页面置换算法分为局部页面置换算法：置换页面的选择范围仅限于当前进程占用的内存页面，全局页面置换算法：置换页面的选择范围是所有可换出的内存页面(并不是所有的内存页面都可以换出内存，比如内核关键代码所在内存页面；因此对这些页面，会将其页表项的锁定位置1，从而操作系统在换出内存页面时就不会考虑这些页面)。\n\n## 局部页面置换算法\n\n下面介绍三种理论上的局部页面置换算法。\n\n* 最优算法：将未来最长时间不访问的页面换出内存；缺页次数最少，但是无法实现。用来评价其他置换算法的效率。\n\n* 先进先出算法：将在内存中驻留时间最长的页面进行置换。易于实现，但是效率很低；甚至会出现Belady现象。\n\n* 最近最久未使用算法：将内存中最长时间未被引用的页面进行置换。\n\n实际实现的算法在上述置换算法的基础上做一些折中，使得既易于实现，效率又不是太差。\n\n### 时钟置换算法\n\n* 各页面组成环形链表，指针指向最先调入的页面；\n* 若要访问的页面在内存中，则将页面对应页表项的A位置1；\n* 若要访问的页面不在内存中，从指针处开始顺序查找，对于访问过的页面，将页面对应页表项的A位置0；直到找到A位为0的页面(可以想一下此时A位为0与页面被访问过的区别)，这就是可以置换的页面；\n\n如下是一个使用时钟置换算法进行内存分配的例子：\n\n{% asset_img 31.jpg pic31 %}\n\n&nbsp;\n\n### 改进的时钟置换算法\n\n由于置换修改过的内存页面需要将该页面的数据写到外存，然后再从外存中读取要换入的页面；这样缺页中断的处理时间几乎是置换未被修改的内存页面的两倍(指令执行的时间可以忽略不计，主要是读取数据的时间)；因此，为了提高缺页中断处理的效率，操作系统应该避免在缺页时置换修改过的内存页面，而是在另外合适的时机将修改过的内存页面的数据写入外存对应位置。\n\n&nbsp;\n\n因此有了改进的时钟置换算法，相比于经典的时钟置换算法，操作系统在内存页面分配，访问，置换时还要再对页表项的D位进行维护；\n\n### 最不常用置换算法\n\n发生缺页时，置换访问次数最少的内存页面；\n\n## Belady现象\n\n在给进程分配的内存页面数目增加之后，使用某个(局部)页面置换算法反而使得发生缺页的次数增加，这一现象称为Belady现象。而先进先出算法就具有Belady现象，下面举例说明。\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  5   |  5   |  3   |  4   |  4   |\n|          |      |  1   |  2   |  3   |  4   |  1   |  2   |  2   |  2   |  5   |  3   |  3   |\n|   头部   |      |      |  1   |  2   |  3   |  4   |  1   |  1   |  1   |  2   |  5   |  5   |\n| 缺页状态 |  √   |  √   |  √   |  √   |  √   |  √   |  √   |      |      |  √   |  √   |      |      |\n\n\n\n此时缺页9次；如果分配4个内存页面：\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  4   |  4   |  5   |  1   |  2   |  3   |  4   |  5   |\n|          |      |  1   |  2   |  3   |  3   |  3   |  4   |  5   |  1   |  2   |  3   |  4   |\n|          |      |      |  1   |  2   |  2   |  2   |  3   |  4   |  5   |  1   |  2   |  3   |\n|   头部   |      |      |      |  1   |  1   |  1   |  2   |  3   |  4   |  5   |  1   |  2   |\n| 缺页状态 |  √   |  √   |  √   |  √   |      |      |  √   |  √   |  √   |  √   |  √   |  √   |\n\n此时缺页10次，分配的内存页面增加，而缺页的次数增加。\n\n最优算法无Belady现象。\n","tags":["backend"],"categories":["os"]},{"title":"第五章 虚拟存储概念","url":"/os/os-ch5.html","content":"\n## 覆盖与交换技术\n\n**覆盖技术**：依据程序的逻辑结构，将程序划分为若干功能独立的模块，将不会同时执行的模块共享同一块内存区域。\n\n**交换技术**：将暂时不能运行的程序换到外存，再将外存中某一进程的数据读入内存。\n\n\n## 局部性原理\n\n程序在执行过程的一段较短时期内，所执行指令的地址与操作数的地址，分别局限于一定区域。具体来说：\n\n* 时间局部性；一条指令在执行后的较短时间内很可能会再次执行，某个内存地址在被访问后的较短时间内很可能会再次访问；\n* 空间局部性；相邻指令访问的内存地址很可能集中在一个较小的区域；\n* 分支局部性；一条跳转指令的两次执行，很可能会跳到相同的内存地址；\n\n局部性原理给虚拟存储技术提供了理论支持。\n\n## 虚拟存储概述\n\n* 在装载程序时，只将指令执行需要的部分页面或段装入内存；\n* 当指令执行时需要的指令或数据不在内存中时(即缺页或缺段)，处理器通知操作系统将相应的页面或者段读入内存；\n* 此外，操作系统还会时刻监控内存中页或段的使用情况，从而将暂时不用的页或段换到外存；\n\n要实现虚拟存储，需要硬件与操作系统的支持；\n\n对硬件：支持虚拟存储的页或段式地址转换机制；\n\n对操作系统：管理内存与外存间页或段的数据的写入；\n\n## 虚拟页式存储管理\n\n概括地说，虚拟页式存储管理就是在页式存储管理的基础上增加请求调页与页面置换。\n\n上一章指出了页表项的结构，但是对其中的控制位并未作解释；在这里我们指出这些控制位在虚拟页式存储管理中所起的作用。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n* P位：存在位；1表示该页在内存中，0表示该页在外存中；\n* A位：访问位；若该页被访问过，A位置1，否则A位置0；\n* D位：修改位；若该页被修改过，D位置1，否则D位置0；\n\n下面分析一些关键时刻，操作系统对这些控制位的处理。\n\n**装载**\n\n操作系统给应用程序分配足够的线性地址空间，而事实上，操作系统只是将应用程序此时执行必要的一部分页面装入内存中，那么这些页面对应页表项的P位置1，而没有装入内存的页面对应页表项的P位置0；\n\n**内存访问**\n\n操作系统会将访问过的内存页面对应的页表项的A位置1；如果指令对该页进行了修改，则需要将该页对应页表项的D位置1；\n\n**缺页**\n\n指令要访问的页面不在内存中，操作系统调用缺页中断服务例程将该页读入内存，并将该页对应页表项的P位置1；\n\n**页面换出内存**\n\n若页面对应页表项的D位为0，则只需要将P位置0即可；否则，操作系统要将内存中的该页写到外存中对应位置；\n\n## 缺页中断\n\n下面详细介绍缺页中断处理例程。发生缺页中断时，操作系统会找到外存中的对应页面，之后在内存中申请一个空闲页面，将外存中的页面装载到内存中，如果内存中此时没有空闲页面，那么需要根据页面置换算法将内存中的某些页面换出内存。具体的页面置换算法在下一章介绍。","tags":["backend"],"categories":["os"]},{"title":"第四章 物理内存管理：非连续内存分配","url":"/os/os-ch4.html","content":"\n## 背景\n\n如果使用连续内存分配，有时不一定有满足要求的一块连续的物理内存；此外，连续内存分配产生的内/外碎片也降低内存分配效率，并且分配了的内存空间无法动态调整。\n\n## 段式存储管理\n\n段的访问机制为[段选择符 : 段偏移量]，MMU通过段选择符索引段描述符表中的段描述符，以此获得段基址；在开启分页机制之前，段基址+段内偏移=物理地址，而在开启分页机制之后，段基址+段内偏移=线性地址；线性地址在下一节介绍。\n\n## 页式存储管理\n\n开启分页机制后，逻辑地址经上述转换得到的是线性地址，线性地址转换为物理地址的原理如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n转换过程中所用到的页表在下一节介绍。此外，页目录表是存放页表地址的页表。\n\n\n## 页表\n\n页表主要用来存放页框地址，MMU通过线性地址中的页表字段索引页表中的页表项，页表项的结构如下图所示：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n可以看出，页表项中除了记录对应页框的物理地址，还存放一些控制位(如存在位P)；\n\n但是在线性地址转物理地址的原理图中可以看到除了页表之外，还有页目录表，这就是下一节要介绍的多级页表。\n\n### 页表自映射\n\n考虑一个非常特殊的页表项：页目录表对应的页表项。\n\n页表也是页，因此页目录表也是页表。因此，页目录表中必然有一个指向页目录表的页表项；如下图所示：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n页目录表对应的页表项的线性地址记为B1|B2|B3；下面解释为何将B1、B2与B3标注在图所示位置。\n\n图中阴影页表项就是指向页目录表的页表项，显然B3应该标注在此；\n\n将页目录表看作一个页，而指向这个页的页目录项就是图中阴影页表项，因此B2应该标注在此；\n\n将页目录表看作一个页表，页目录表中指向这个页表的页目录项就是图中阴影页表项，因此B1应该标注在此；\n\n\n## 快表与多级页表\n\n为提高内存访问效率，会将访问过的页表项缓存到CPU的关联存储器中，这一区域称为快表，相比在页表中查找，在快表中查找会快很多(CPU的处理速度比内存中的访问速度快很多)；于是，在访问内存时，首先在快表中查找页表项，若快表中缓存了此页表项，直接从快表中读取此页表项然后去访问相应的物理地址即可，若快表中未缓存此页表项，接下来则需要通过页表查询页表项，并且将此页表项缓存到CPU的关联存储器中。\n\n&nbsp;\n\n通过间接引用，将线性地址分为若干级，在转换物理地址时，通过各级页表的索引(上一级索引的页表项中的页框地址作为下一级页表的地址)最终找到页表项。得到的页表项中的页框地址加上页内偏移就是要访问的物理内存地址。\n\n如下是两级页表寻址的示意图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n## 页映射机制\n\n&nbsp;\n\n## 开启页表机制\n\n&nbsp;\n","tags":["backend"],"categories":["os"]},{"title":"第二步 传输TCP/IP数据","url":"/cn/cn-step2.html","content":"\n## 创建套接字\n\n### 协议栈的结构\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 套接字：通信控制信息\n\n套接字记录着通信对象的IP地址与端口号、通信的状态等等；总之，套接字中记录了用于控制通信的各种信息，协议栈根据这些信息判断下一步操作。\n\n### socket的内部实现\n\n以下所示是更详细的收发数据示意图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n## 连接服务器\n\n### 连接：通信双方交换控制信息\n\n所谓建立连接，就是为通信双方互相交换控制信息，在套接字中记录这些必要信息并准备数据收发的一系列操作。\n\n### 保存控制信息的头部\n\n在数据包的头部，存放着客户端与服务器相互联络所需的控制信息，这些信息在TCP协议中进行了定义，如下表所示。\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n在连接阶段，通信双方只交换控制信息，此时网络包的结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n通信双方建立连接之后，通信双方开始互相发送数据，此时的网络包结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n### 连接的具体操作\n\n|                           服务器端                           | 方向 |                            客户端                            |\n| :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |\n|                                                              | <    | 创建TCP头部，其中包含表示开始数据收发操作的控制信息；<br /><br />对TCP头部进行初始化设置(源IP与目的IP、源端口与目的端口、SYN位置1、序号设置与窗口大小设置等等)；<br /><br />将TCP头部传给IP层并委托IP层发送给服务器端。 |\n| 服务器端接收到数据，经以太层、IP层解析之后到达TCP层；<br /><br />TCP层根据头部的目的端口号找到连接此请求的套接字，并向该套接字中写入相应的信息；套接字的状态改为正在连接；<br /><br />服务器端也是发送一个TCP头部给客户端(操作与客户端的操作相同，但是有些地方的设置要反过来，比如TCP头部的源IP与目的IP、源端口与目的端口之类)；此外，还要将ACK位置为1，表示已经接收到相应的网络包。 | >    |                                                              |\n|                                                              | <    | 客户端接收到数据，经以太层、IP层解析之后到达TCP层；<br />TCP层通过接收到的TCP头部的SYN位确认连接服务器的操作是否成功；若SYN位为1,(表示连接成功)，此时TCP模块会向套接字中写入服务器的IP地址，端口号等信息；并将套接字的状态设置为连接完毕；<br />同样地，客户端也需要将TCP头部的ACK位置1并将TCP头部传给IP层并委托IP层发送给服务器端。 |\n|    服务器收到客户端第二次发送的网络包，连接操作全部完成。    |      |                                                              |\n\n此后，套接字进入了随时可以收发数据的状态。到这里，也就是connect执行完毕。\n\n## 收发数据\n\n### 请求消息进入协议栈\n\n协议栈收到数据后，先将其存放在内部的发送缓冲区，继续等待应用程序后续的数据；协议栈是否发送数据有以下两个判断要素：\n\n* 缓存的数据包长度是否接近MSS(最大分段大小)。MSS=MTU-ip_head_len-tcp_head_len，MTU(最大传输单元)一般为1500；\n* 等待时间。即使数据包长度还未接近MSS，但是已经等待了一定时间，为避免造成发送延迟，也会将数据包发送出去；\n\n应用程序可以控制数据包发送的时机(长度优先或时间优先)，若应用程序未指定，则由协议栈自行决定。\n\n### 对长数据进行拆分\n\n当应用程序送入协议栈的数据长度大于MSS，数据以MSS个字节为单位进行分组，在每组数据前加上TCP头部后送入IP层，委托IP将数据发送。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n### 网络包的接收确认\n\n每发送一个网络包，都需要进行确认操作。首先，在客户端(发送方)与服务器端(接收方)建立连接时，客户端(发送方)向服务器(接收方)发送的tcp头部使用一个32位的随机数作为序列号；在(发送方)TCP模块拆分数据时，每一数据块前所加的TCP头部的序列号为在上述序列号(32位的随机数)的基础上加上数据块的位置。服务器端(接收方)在收到网络包后，会计算ACK值(序列号+data_len+1)；\n\n&nbsp;\n\n服务器端(接收方)创建一个TCP头部(ACK的值为上述ACK的值，ACK位置1)，然后发送给客户端(发送方)；客户端(发送方)在没有收到某个数据包对应的ACK号之前，数据包会一直保存在发送缓冲区中，如果没有收到某个数据包对应的ACK号，TCP模块会重新发送此数据包。\n\n以下是TCP数据包传输的示意图(简便起见，没有考虑32随机数的初始序列号)。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n同时，TCP的数据收发是双向的，即服务器端作为发送方、客户端作为接收方，也会为网络包的接收确认做上述操作。\n\n如下是TCP数据双向传输的示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n### ACK号等待时间\n\nTCP协议采用动态调整的策略来设置ACK号的等待时间。策略是：在TCP模块发送数据时持续测量ACK号的等待时间，若ACK号的返回变慢，则增大ACK号的等待时间，若ACK号的返回变快，则减小ACK号的等待时间。\n\n### 滑动窗口\n\n接收方告知发送方自己最多能接收的数据，然后发送方根据这个值对发送的数据量进行控制。以下是一个TCP滑动窗口的示例。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### ACK与窗口信息的合并发送\n\nQ1：接收方何时要向发送方发送窗口的更新信息？\n\n答：应用程序从接收缓冲区取出数据后。\n\nQ2：接收方何时要向发送方发送ACK号？\n\n答：收到数据包确认无误后。\n\n为了提高网络的效率，可考虑将这两种信息放入同一tcp头部进行发送。这时，在等待过程中(一种情形是刚刚收到了tcp数据包并确认无误，等待应用程序从接收缓冲区取出数据；另一种情形是应用程序从接收缓冲区取出了数据，等待数据包的到来与确认)，窗口信息或ACK号会有多个值，此时只需要传递最终结果即可。","tags":["backend"],"categories":["cn"]},{"title":"AT&T汇编基础知识","url":"/os/ATwithT.html","content":"\n## 基本语法\n\nAT&T与Inter汇编主要有以下几个不同：\n\n* 寄存器的命名；\n```assembly\nAT&T：%eax                   Intel：eax\n```\n* 源操作数与目的操作数的顺序；AT&T赋值方向为从左向右。\n```assembly\nAT&T：movl %eax, %ebx         Intel：mov ebx, eax\n```\n* 常数与立即数的格式；\n```assembly\nAT&T：movl $12, %ebx          Intel：mov eax, 12\n```\n* 地址；\n```assembly\nAT&T：movl $0xd00d, %ebx      Intel：mov eax, 0xd00d\n```\n* 操作数长度标识；\n```assembly\nAT&T：movw %ax, %bx           Intel：mov bx, ax\n```\n* 寻址方式；\n```assembly\n#通用寻址\nAT&T：imm32(base, ip, scale)   Intel：[base+ip×scale+imm32]\n#直接寻址\nAT&T：foo                      Intel：[foo]\n#寄存器间接寻址\nAT&T：(%eax)                   Intel：[eax]\n```\n\n\n## GCC基本内联汇编\n\n基本内联汇编的格式为：`asm(\"statements\");`\n\n## GCC扩展内联汇编\n\nGCC扩展内联汇编的格式为：\n\n```assembly\nasm [volatile]( Assembler Template\n\t: Output Operands\n\t[ : Input Operands\n\t[ : Clobbers ]])\n```\n\n注：如果不希望汇编语句被gcc优化而改变位置，就需要在asm符号后添加volatile关键词；\n\n**样例**\n\n```assembly\n#define read_cr0() ({ \\\nunsigned int __dummy; \\\n__asm__( \\\n\t\"movl %%cr0, %0\\n\\t\" \\\n\t:\"=r\" (__dummy)); \\\n__dummy; \\\n})\n```\n\n**说明**\n\n* 在`__asm__`的括号内，第一行为汇编程序模板；其中`%0`以占位符作为汇编指令的操作数，GCC将这些占位符与C语言表达式按照出现的顺序相对应。即`%0`对应C语言表达式`__dummy`；\n* 第二行为输出部分；输出部分用来规定输出变量如何与寄存器结合的约束，输出部分可以有多个约束，互相以逗号分开，每个约束以\"=\"开头，接着用一个字母来表示操作数的类型，接着是关于变量结合的约束。在上例中，\"r\"代表任一通用寄存器，其他常用约束字母与含义见下表：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n* 如果有输入部分；输入部分与输出部分相似，但是没有\"=\"；\n* 汇编程序模板为必选项，输入部分与输出部分为可选项；当存在输入部分而不存在输出部分时，需要保留\":\"(代表输出部分，即使输出部分不存在)，而当只存在修改部分时，需要保留\":::\"(代表输出部分、输入部分与修改部分)；\n\n**练习**\n\n扩展内联汇编代码：\n\n```c\nint count=1;\nint value=1;\nint buf[10];\nvoid main()\n{\n    asm(\n        \"cld \\n\\t\"\n        \"rep \\n\\t\"\n        \"stosl\"\n    :\n    : \"c\" (count), \"a\" (value) , \"D\" (buf)\n    );\n}\n```\n\n经过GCC编译之后得到的汇编代码为：\n\n```assembly\nmovl count,%ecx\nmovl value,%eax\nmovl buf,%edi\n#APP\ncld\nrep\nstosl\n#NO_APP\n```","tags":["backend"],"categories":["os"]},{"title":"第一步 浏览器生成消息","url":"/cn/cn-step1.html","content":"\n## 生成HTTP请求消息\n\n### 浏览器解析URL\n\n* HTTP协议的URL格式：`http://[用户名(可省略)]:[密码(可省略)]@[Web服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `http://user:password@www.glasscom.com:80/dir/file1.htm`\n\n* FTP协议的URL格式：`ftp://[用户名(可省略)]:[密码(可省略)]@[ftp服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `ftp://user:password@ftp.glasscom.com:21/dir/file1.htm`\n\n* 计算机本地文件URL格式：`file://[计算机名(可省略)][文件路径名]`，例如：\n\n  `file://localhost/home/user/Desktop/wps-office-prometheus.desktop`\n\n* 发送电子邮件的URL格式：`mailto:[邮件地址]`，例如：\n\n  `mailto:tone@glasscom.com`\n\n浏览器根据开头就能确定是哪种协议，进而根据对应的协议格式对URL进行解析。\n\n例1：解析如下URL\n\n* `http://www.lab.glasscom.com/`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com/what`：若/what是文件，则访问/目录下的what文件，若what是目录，则访问/what目录下的index.html或default.html；\n\n### 生成HTTP请求消息\n\nHTTP请求消息格式如下：\n\n&nbsp;\n\n<div style=\"width:64%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\nHTTP的主要方法及其含义如下图所示：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\nHTTP请求消息中主要的头字段有如下这些：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n## 向DNS服务器查询Web服务器的IP地址\n\n<div style=\"width:64%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n* 客户端将查询消息发送给最近的DNS服务器(地址填写在客户端的TCP/IP设置中)；若该DNS服务器的缓存中存放了`www.lab.glasscom.com`Web服务器的IP地址，则直接返回相应IP地址；\n* 如果该DNS服务器中没有存放`www.lab.glasscom.com`Web服务器的IP地址，就需要从根域向下查找(每台DNS服务器都会保存根域DNS服务器的IP地址，共13个)；\n* 该DNS服务器将查询消息发送给根域DNS服务器，根域DNS服务器根据域名结构判断出该域名属于com域，将com域DNS服务器的IP地址返回该DNS服务器，该DNS服务器再向com域DNS服务器发送查询消息；\n* 一直类似以上步骤，直到查询消息到达目标DNS服务器——com.glasscom.lab域DNS服务器；com.glasscom.lab域中如果存在`www.lab.glasscom.com`这个域名，则目标DNS服务器就会将其IP地址发送给离客户端最近的DNS服务器；否则，目标DNS服务器将\"不存在\"这一结果发送给离客户端最近的DNS服务器；\n* 离客户端最近的DNS服务器将查询结果返回给客户端，同时将此次查询结果缓存，以便下次客户端查询时能够快速响应(DNS服务器缓存的信息都会有一个有效期，过了有效期缓存的信息会被删除)；\n\n## 委托协议栈发送消息\n\n数据通过类似管道的结构来流动：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n收发数据大体分为4个阶段：\n\n* 创建套接字阶段；\n* 连接阶段(将管道连接到服务端的套接字上)；\n* 通信阶段(收发数据)；\n* 断开阶段(断开管道并删除套接字)；\n\n如下示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n**创建套接字阶段**\n\n创建套接字通过调用socket程序组件完成，套接字创建完成后，协议栈(socket程序组件)返回关于此套接字的描述符。\n\n**连接阶段**\n\n连接目的服务器通过调用connect程序组件完成，connect程序组件需接收3个参数：对应套接字的描述符、目的服务器的IP地址与目的端口号(用来指定要连接的服务器端的套接字)。最终，客户端的套接字与服务器端的套接字连接。\n\n**通信阶段**\n\n调用write程序组件将请求消息从客户端的套接字传送到服务器端的套接字。当服务器端接收到请求消息后，将请求消息解析并执行相应的操作，然后向客户端返回响应消息。接收响应消息通过调用read程序组件完成，read程序组件需接收1个参数——接收到的响应消息在内存中的地址，这一内存区域称为接收缓冲区。\n\n**断开阶段**\n\nWeb服务器发送完响应消息后，会主动执行断开操作；断开操作传回客户端之后，客户端调用close程序组件断开连接、删除套接字。\n\n&nbsp;\n\n在HTTP1.0版本中，HTML文档与图片视为独立的对象，每获取一次数据，就要执行一轮创建套接字、连接、通信与断开的操作；因此，如果一个网页中包含多张图片，就必须重复多轮上述操作，因此在HTTP1.1版本中设计了可以在一次连接中收发多个请求与响应的方法，当所有数据都请求完成后，客户端的应用程序会主动执行断开操作。","tags":["backend"],"categories":["cn"]},{"title":"第三章 物理内存管理：连续内存分配","url":"/os/os-ch3.html","content":"\n## 计算机体系结构与内存层次\n\n### 计算机体系结构\n\n<div style=\"width:64%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 内存层次\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n### 操作系统的内存管理方式\n\n**预备知识**\n\n* 物理地址：将内存当作一个数组，内存单元在数组中的索引就是该内存单元的物理地址；\n* 线性地址(虚拟地址)：操作系统提供的一种对内存的抽象；线性地址到物理地址的转换如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n注：寄存器CR3用于存放当前进程正在使用的页目录基地址\n\n* 逻辑地址：形式为[段描述符 : 段偏移量]；逻辑地址到线性地址的转换如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 10.jpg pic10 %}</div>\n\n&nbsp;\n\n**正文**\n\n<div style=\"width:50%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n* 重定位：操作系统把用户程序指令中的相对地址变换成为所在存储中的绝对地址的操作；\n* 分段\n  * 段：段由三个参数定义：段基地址、段限长和段属性；段基地址、段限长以及段的保护属性存储在一个称为段描述符的结构体中。\n  * 分段机制：将虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元；\n* 分页：虚拟地址空间按照固定大小划分成称为页面的若干单元，在物理内存中对应的单元称为页框。\n* 虚拟存储：进程的地址空间中有的页映射到内存，有的页映射到外存。当程序需要访问外存中的数据时，进程产生缺页中断，然后操作系统将这部分数据装入内存之中，然后进程重新执行失败的指令。\n\n## 地址空间与地址生成\n\n### 地址空间的定义\n\n地址空间是一个进程用来寻址内存的一套地址集合；地址空间中的地址为线性地址。\n\n### 地址生成\n\n举例说明如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n地址的生成有如下几种时机：\n\n* 编译时(地址已知)；\n* 加载时；使用重定位表，在加载时生成绝对地址；\n* 执行时；需硬件支持的地址转换；\n\n### 地址检查\n\n以指令`mov %eax, $0xfffa620e`执行时的地址检查为例。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n## 连续内存分配\n\n以下是在内存分配没有其他技术支持条件下的讨论。此时必须对进程分配连续的地址空间。\n\n### 内存碎片\n\n**外碎片**：由于每个进程的寿命不一致，导致有的进程先从内存中退出，有的进程后从内存中退出，从而在进程占用的内存区域之间出现空闲的内存区域，而该内存区域的长度小于所有进程要求的长度，使得该内存区域变得不可用。这样的空闲内存区域称为外碎片。\n\n**内碎片**：分配给进程区域内无法利用的内存。这是由于分配内存时只能分配2的整数次幂长度的内存区域。\n\n### 动态分配\n\n* 最先匹配：将空闲内存区域按照地址排序，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最佳匹配：将空闲内存区域按照长度排序(从小到大)，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最差匹配：将空闲内存区域按照长度排序(从大到小)，将第一个空闲内存区域分配给该进程；\n\n## 碎片整理\n\n通过调整进程占用的分区位置来减少或避免分区碎片。\n\n## 伙伴系统\n\n连续内存分配的实例。\n\n## SLUB分配器\n\n### 概述\n\n针对以下情形：\n\n* 一些内核所用到的结构体等对象远比页要小；\n* 并且这些对象会被频繁地申请与释放；\n* 有些对象仅仅初始化的时间就超过了申请到释放的时间；\n\n为满足这些对象申请内存的需求，需要创造页分配管理器之外的内存分配管理器——SLAB分配器，而SLUB分配器是在SLAB分配器的基础上进一步优化；使得效率更高，(分配器的)内存占用更低；下面介绍SLUB分配器的原理。\n\nSLUB将内存分组管理，每个组包含$2^{3},\\cdots,2^{11}$个字节，在4KB为一页的情形下，还有两个特殊的长度分组(96B，192B)，共11组；\n\n可以这样理解：SLUB相当于零售商，伙伴系统相当于厂家，SLUB从伙伴系统那里\"批发\"内存，然后SLUB再零售出去。\n\n整个SLUB系统结构图如下：\n\n{% asset_img 13.jpg pic13 %}\n\n&nbsp;\n\n整个系统的源头就是数组kmalloc_caches[12]，其中每个数组元素kmem_cache结构体相当于超市，每个超市出售一种特定长度的内存；每个超市有两个部门：仓库(kmem_cache_node)与营业厅(kmem_cache_cpu)，营业厅只保留一个slab(从kmem_cache获取的多个内存页)，营业厅在没有空闲object(特定长度的内存)的情况下会从仓库中换出有空闲object的slab；仓库中存放着被完全使用的slab(full链表存放)与被部分使用的slab(partial链表存放)。\n\n### 申请内存块\n\n**第一次申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 14.jpg pic14 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab有空闲的object时申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 15.jpg pic15 %}\n\n&nbsp;\n\n这里可能会问一个问题，为什么kmem_cache_cpu的slab中被占用的object是分开的，这是因为中间空闲的object被占用后释放了。\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表有slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，再将kmem_cache_cpu的slab换成kmem_cache_node的partial链表中的slab。然后给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 16.jpg pic16 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 17.jpg pic17 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 18.jpg pic18 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表无slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，向伙伴系统申请slab并初始化slab，然后给对象分配object，freelist指向下一空闲的object；\n\n{% asset_img 19.jpg pic19 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 20.jpg pic20 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 21.jpg pic21 %}\n\n### 释放内存块\n\n**释放kmem_cache_cpu的slab上的object**\n\n将该object放入freelist链表即可。\n\n**释放kmem_cache_node上full链表上的object**\n\n先释放该object，那么该object所在slab的状态从full变成partial，因此需要将该object所在slab从full链表中移除，然后将其添加到partial链表。\n\n{% asset_img 22.jpg pic22 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 23.jpg pic23 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(有多个object被分配)上的object**\n\n先释放该object，之后该object所在slab的状态仍为partial。\n\n{% asset_img 24.jpg pic24 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 25.jpg pic25 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(只有一个object被分配)上的object**\n\n先释放该object，之后该object所在slab的状态变成empty，于是还要将该object所在slab也释放。\n\n{% asset_img 26.jpg pic26 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 27.jpg pic27 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 28.png pic28 %}\n\n&nbsp;\n\n**参考链接**\n\n[SLUB算法原理](https://blog.csdn.net/lukuen/article/details/6935068)\n\n[对各种地址更详细地解释](http://bbs.chinaunix.net/thread-2083672-1-1.html)","tags":["backend"],"categories":["os"]},{"title":"第二章 中断、异常与系统调用","url":"/os/os-ch2.html","content":"\n## 基本概念与原理\n\n<div style=\"width:36%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n**系统调用**：应用程序主动向操作系统发出的服务请求；异步响应。\n\n**异常**：非法指令或其他原因导致当前指令执行失败，(如内存出错)后的处理请求；同步响应。\n\n**中断**：来自硬件设备(外设，device)的处理请求。好处：避免CPU不停地去查询外设的状态，提高CPU的运行效率；异步或同步响应。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n## 中断处理机制\n\n* 建立中断服务例程；\n* 设置控制寄存器状态使CPU能够响应中断；\n* 处理中断；\n* 保存与恢复现场；\n\n### 设置CPU可响应中断\n\n* sstaus(硬件)：保存全局中断使能位；\n* sie(硬件)：指出CPU目前能处理或忽略的中断；\n* stvec(硬件)：中断入口地址；\n\n初始化如下：\n\n* 设置sie的TI使能STIE位；\n* 设置sstaus的使能中断SIE位；\n* 实现中断服务总控函数并设置stvec指向该函数的地址；\n\n### 建立中断服务例程\n\n* 初始化\n* 服务例程\n\n### 保存现场&恢复现场\n\n在调用中断服务例程之前，需要保存被中断的应用程序的上下文(也就是所有的寄存器)，具体来说，有如下寄存器：\n\n* x[0-31]：通用寄存器；\n* sstatus：系统状态寄存器；\n* 以及寄存器sepc、scause、stval；\n\n产生中断后，硬件设置如下：\n\n* sepc设置为产生中断后指令的地址；\n* pc设置为stvec(总控中断服务程序的地址)；\n* scause设置为中断的来源；\n* sstatus的SIE位置0以禁用中断；\n* stval保存中断相关的附加信息；\n\n## 系统调用\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n* ecall指令与sret指令用于系统调用；\n* 系统调用存在着堆栈切换与特权级的切换，参数验证(内核无法信任应用程序)以及可能的切换页表、拷贝数据操作；\n\n**具体流程**\n\n* 应用发起请求；\n* 函数库发出系统调用请求(设置系统调用号，再执行ecall指令)；\n* 保存被中断的应用程序的上下文；\n* 硬件设置：\n  * sepc：保存请求后的指令地址；\n  * pc设置为stvec(总控中断服务程序的地址)；\n  * scause设置为ecall from u-mode；\n  * sstatus：SIE位置0以禁用中断；\n  * stval保存中断相关的附加信息；\n* 调用中断服务例程；\n* 恢复被中断的应用程序的上下文；\n* 应用继续执行；","tags":["backend"],"categories":["os"]},{"title":"第一章 操作系统与系统结构&程序设计语言","url":"/os/os-ch1.html","content":"\n## 从OS角度看计算机系统\n\n使用操作系统，在一个CPU上并发的执行多个程序的实例，我们称为进程。在多个进程相互执行时如何做到相互之间不互相影响，保证系统是安全的，这时需要对程序的执行进行**隔离**。这种隔离就需要计算机系统结构给予支持。而这里主要的隔离技术即**虚拟内存**与**特权模式(中断)**。\n\n### 隔离\n\n* 隔离以避免对整个系统的可用性、可靠性、安全产生影响；\n* 运行的程序通常是隔离的单元；\n* 技术1：地址空间。一个程序只能寻址自己的内存，任一程序若无许可，则不能访问不属于自己的内存。\n* 技术2：特权模式（中断机制）。防止应用程序访问设备与敏感的CPU寄存器。使用中断机制进行特权模式的切换。\n\n### 虚拟内存\n\n由操作系统提供的一种对物理内存的抽象。\n\n### 特权模式&中断\n\n* 内核模式(低特权级)\n* 用户模式(高特权级)\n\n\n## Lab1\n\n安装qemu-system\n\n```bash\napt install -y qemu-system\n```\n\n进入ucore/labcodes/lab1文件夹，使用`make`命令编译。\n\n使用qemu-system-x86启动ucore.img但是并不马上执行，以便我们用gdb对其进行远程调试。如无特别说明，以下命令都是在ucore/labcodes/lab1目录下执行。\n\n```bash\nqemu-system-i386 -S -s -hda bin/ucore.img -monitor stdio\n```\n\n再用以下内容替换~/.gdbinit文件\n\n```bash\nfile bin/kernel\ntarget remote :1234\nbreak kern_init\nset arch i8086\n```\n\n接下来运行gdb，效果如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n参考链接：\n\n[清华大学操作系统实验ucore](https://blog.csdn.net/ever_freedom/article/details/105563670)","tags":["backend"],"categories":["os"]},{"title":"攻防世界-密码学-Marijuana","url":"/crypto/xctf-Marijuana.html","content":"\n## 题目信息\n\n这个密码系统的开发者在开发过程中使用率很高，也可以说是非常高。 也许他的想法是错的，这个密码系统是非常容易攻破的。\n\n## 分析\n\nRSA的d很小，但是N有3个因子，使用wiener攻击没破解出来，想用boneh_durfee攻击却发现没法列方程，看了writeup才了解到wiener攻击的变种，[论文链接在此](https://web.math.pmf.unizg.hr/~duje/pdf/dujececc.pdf)；总的来说，记$\\{h_{i}/k_{i}\\}$是$e/N$的连分数收敛列，常规的wiener攻击中$d=k_{i}$，而在wiener攻击的变种中，$d=s\\cdot k_{i}+t\\cdot k_{i-1} , s,t \\in Z$，一般来说，$d$越大，$s,t$的取值范围也越大。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import is_square,sqrt\nfrom Crypto.Util.number import *\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\n\nclass Wiener(object):\n    def __init__(self,N,e,mode):\n        self.N=N\n        self.e=e\n        self.mode=mode\n        return\n\n    def next_frac(self):\n        hi_1,hi_2=1,0\n        ki_1,ki_2=0,1\n        a,b=self.e,self.N\n        r=1\n        while r:\n            p,r=divmod(a,b)\n            hi=p*hi_1+hi_2\n            ki=p*ki_1+ki_2\n            hi_1,hi_2=hi,hi_1\n            ki_1,ki_2=ki,ki_1\n            a,b=b,r\n            yield (hi,ki)\n\n    def two(self):\n        N,e=self.N,self.e\n        for frac in self.next_frac():\n            hi,ki=frac\n            if hi==0:\n                continue\n            # f=t^2-(N-(ki*e-1)/hi+1)*t+N ==> delta=[N-(ki*e-1)/hi+1]^2-4*N\n            t1=(ki*e-1)%hi\n            if not t1:\n                t1=N-(ki*e-1)//hi+1\n                delta=pow(t1,2)-4*N\n                if is_square(delta):\n                    t2=int(sqrt(delta))\n                    if not (t1-t2)%2:\n                        P=(t1-t2)//2\n                        Q=(t1+t2)//2\n                        return P,Q\n        return\n\n    def multi(self,rate):\n        N,e=self.N,self.e\n        pt=getRandomRange(2,N-1)\n        ct=pow(pt,e,N)\n        ki_1,ki_2=0,1\n        for frac in self.next_frac():\n            hi,ki=frac\n            ki_1,ki_2=ki,ki_1\n            if hi==0:\n                continue\n            check=lambda rs: pow(ct,int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2,N)==pt\n            rs=mbruteforce(check,'01',2*rate,method='fixed')\n            if rs:\n                return int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2\n        return\n\n    def attack(self):\n        if self.mode:\n            #when there is no solution, maybe you could take greater action, via increase rate.\n            return self.multi(4)\n        else:\n            return self.two()\n\ndef solve():\n    pubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L)\n    n,e,a,g=pubkey\n    wiener=Wiener(n,e,1)\n    d=wiener.attack()\n    c1,c2=(1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L)\n    k=pow(c1,d,n)\n    K=pow(g,k,a)\n    return long_to_bytes(c2*inverse(K,a)%a)\n\nif __name__=='__main__':\n    print solve()\n```\n程序运行结果如下：\n```Bash\n$ python solve.py \n[-] MBruteforcing: No matches found\n......\n[-] MBruteforcing: No matches found\n[+] MBruteforcing: Found key: \"01110110\"\nASIS{Wiener_at7ack_iN_mUlt1_Prim3_RSA_iZ_f34sible_t0O!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyRSA1","url":"/crypto/xctf-Babyrsa1.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n在伽罗华域上实现RSA还是第一次见，该题是典型的论文题，提出这个idea的paper[链接在此](http://www.diva-portal.se/smash/get/diva2:823505/FULLTEXT01.pdf)；\n\n记模数N的分解为$N=P\\cdot Q , s=(2^{deg(P)}-1)\\cdot (2^{deg(Q)}-1)$，其中$deg(\\cdot)$为多项式的次数；则$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ s$。\n\n## 解题\n\n解题的sage脚本如下：\n```Python\nfrom Crypto.Util.number import *\n\ndef solve():\n    p,q=N.factor()\n    p,q=p[0],q[0]\n    #s is the equivalent of phi from classic RSA\n    s=(pow(2,p.degree())-1)*(pow(2,q.degree())-1)\n    #therefore, d is the private key to decrypt\n    d=inverse_mod(e,s)\n    pp=pow(PR(pc),d,N)\n    return long_to_bytes(R(pp).integer_representation())\n\nif __name__=='__main__':\n    PR=PolynomialRing(GF(2),'x')\n    e=31337\n    N=PR('x^2048 + x^2046 + x^2043 + x^2040 + x^2036 + x^2035 + x^2034 + x^2033 + x^2031 + x^2029 + x^2025 + x^2024 + x^2022 + x^2019 + x^2018 + x^2017 + x^2012 + x^2007 + x^2006 + x^2004 + x^2000 + x^1999 + x^1998 + x^1997 + x^1993 + x^1992 + x^1991 + x^1986 + x^1982 + x^1981 + x^1979 + x^1978 + x^1977 + x^1975 + x^1970 + x^1964 + x^1963 + x^1962 + x^1961 + x^1960 + x^1959 + x^1958 + x^1955 + x^1954 + x^1952 + x^1951 + x^1949 + x^1947 + x^1942 + x^1939 + x^1938 + x^1936 + x^1934 + x^1933 + x^1932 + x^1930 + x^1928 + x^1927 + x^1923 + x^1922 + x^1919 + x^1918 + x^1915 + x^1914 + x^1913 + x^1912 + x^1911 + x^1910 + x^1908 + x^1903 + x^1902 + x^1900 + x^1899 + x^1897 + x^1893 + x^1891 + x^1890 + x^1886 + x^1881 + x^1880 + x^1879 + x^1878 + x^1875 + x^1874 + x^1873 + x^1872 + x^1871 + x^1870 + x^1869 + x^1865 + x^1863 + x^1862 + x^1860 + x^1856 + x^1855 + x^1853 + x^1852 + x^1845 + x^1841 + x^1839 + x^1837 + x^1836 + x^1835 + x^1833 + x^1832 + x^1829 + x^1828 + x^1827 + x^1826 + x^1824 + x^1823 + x^1822 + x^1821 + x^1820 + x^1819 + x^1818 + x^1817 + x^1813 + x^1812 + x^1810 + x^1809 + x^1808 + x^1807 + x^1803 + x^1799 + x^1797 + x^1796 + x^1794 + x^1792 + x^1790 + x^1786 + x^1783 + x^1782 + x^1779 + x^1778 + x^1776 + x^1775 + x^1774 + x^1772 + x^1767 + x^1766 + x^1765 + x^1764 + x^1763 + x^1762 + x^1759 + x^1757 + x^1756 + x^1754 + x^1753 + x^1752 + x^1750 + x^1749 + x^1741 + x^1734 + x^1730 + x^1729 + x^1726 + x^1725 + x^1723 + x^1722 + x^1721 + x^1716 + x^1714 + x^1713 + x^1712 + x^1710 + x^1709 + x^1706 + x^1705 + x^1703 + x^1702 + x^1700 + x^1698 + x^1693 + x^1692 + x^1691 + x^1690 + x^1683 + x^1682 + x^1681 + x^1680 + x^1679 + x^1677 + x^1672 + x^1670 + x^1669 + x^1666 + x^1663 + x^1662 + x^1661 + x^1659 + x^1655 + x^1653 + x^1651 + x^1649 + x^1648 + x^1647 + x^1646 + x^1644 + x^1643 + x^1642 + x^1640 + x^1639 + x^1638 + x^1634 + x^1633 + x^1628 + x^1620 + x^1619 + x^1618 + x^1616 + x^1614 + x^1611 + x^1610 + x^1608 + x^1605 + x^1604 + x^1603 + x^1599 + x^1597 + x^1595 + x^1594 + x^1590 + x^1588 + x^1587 + x^1585 + x^1583 + x^1580 + x^1579 + x^1577 + x^1574 + x^1573 + x^1572 + x^1568 + x^1566 + x^1565 + x^1563 + x^1562 + x^1560 + x^1555 + x^1554 + x^1552 + x^1550 + x^1549 + x^1548 + x^1545 + x^1544 + x^1542 + x^1540 + x^1538 + x^1537 + x^1536 + x^1535 + x^1534 + x^1533 + x^1532 + x^1531 + x^1528 + x^1526 + x^1525 + x^1523 + x^1522 + x^1521 + x^1519 + x^1517 + x^1515 + x^1510 + x^1509 + x^1506 + x^1504 + x^1502 + x^1499 + x^1498 + x^1497 + x^1488 + x^1483 + x^1480 + x^1477 + x^1472 + x^1471 + x^1469 + x^1468 + x^1467 + x^1466 + x^1464 + x^1462 + x^1457 + x^1456 + x^1455 + x^1454 + x^1453 + x^1452 + x^1448 + x^1446 + x^1444 + x^1443 + x^1442 + x^1441 + x^1440 + x^1436 + x^1435 + x^1431 + x^1428 + x^1425 + x^1424 + x^1422 + x^1420 + x^1415 + x^1414 + x^1411 + x^1410 + x^1408 + x^1406 + x^1405 + x^1403 + x^1402 + x^1399 + x^1397 + x^1396 + x^1395 + x^1394 + x^1393 + x^1391 + x^1388 + x^1385 + x^1377 + x^1376 + x^1372 + x^1371 + x^1370 + x^1369 + x^1367 + x^1363 + x^1361 + x^1357 + x^1355 + x^1354 + x^1349 + x^1343 + x^1339 + x^1338 + x^1337 + x^1336 + x^1335 + x^1332 + x^1329 + x^1327 + x^1326 + x^1324 + x^1321 + x^1315 + x^1314 + x^1312 + x^1310 + x^1309 + x^1305 + x^1304 + x^1303 + x^1302 + x^1299 + x^1298 + x^1296 + x^1295 + x^1293 + x^1291 + x^1290 + x^1289 + x^1284 + x^1283 + x^1282 + x^1281 + x^1280 + x^1278 + x^1277 + x^1276 + x^1275 + x^1272 + x^1270 + x^1269 + x^1268 + x^1267 + x^1259 + x^1257 + x^1254 + x^1252 + x^1251 + x^1249 + x^1247 + x^1246 + x^1244 + x^1240 + x^1238 + x^1233 + x^1232 + x^1229 + x^1222 + x^1219 + x^1217 + x^1211 + x^1209 + x^1208 + x^1205 + x^1204 + x^1203 + x^1202 + x^1200 + x^1197 + x^1196 + x^1195 + x^1193 + x^1192 + x^1189 + x^1187 + x^1186 + x^1185 + x^1184 + x^1183 + x^1182 + x^1181 + x^1177 + x^1176 + x^1173 + x^1170 + x^1167 + x^1166 + x^1162 + x^1161 + x^1160 + x^1159 + x^1158 + x^1156 + x^1155 + x^1154 + x^1153 + x^1151 + x^1146 + x^1143 + x^1141 + x^1139 + x^1138 + x^1137 + x^1135 + x^1131 + x^1129 + x^1128 + x^1125 + x^1124 + x^1122 + x^1116 + x^1115 + x^1114 + x^1112 + x^1111 + x^1107 + x^1106 + x^1105 + x^1104 + x^1103 + x^1102 + x^1098 + x^1097 + x^1095 + x^1094 + x^1092 + x^1088 + x^1087 + x^1085 + x^1077 + x^1076 + x^1075 + x^1072 + x^1069 + x^1068 + x^1061 + x^1060 + x^1059 + x^1057 + x^1055 + x^1054 + x^1053 + x^1050 + x^1047 + x^1046 + x^1044 + x^1043 + x^1042 + x^1036 + x^1029 + x^1025 + x^1024 + x^1023 + x^1022 + x^1019 + x^1016 + x^1013 + x^1012 + x^1010 + x^1008 + x^1007 + x^1006 + x^1004 + x^1000 + x^996 + x^995 + x^993 + x^992 + x^989 + x^985 + x^983 + x^978 + x^977 + x^975 + x^972 + x^971 + x^970 + x^969 + x^967 + x^963 + x^957 + x^956 + x^952 + x^950 + x^948 + x^945 + x^942 + x^941 + x^940 + x^938 + x^937 + x^936 + x^935 + x^932 + x^931 + x^930 + x^928 + x^927 + x^926 + x^923 + x^921 + x^918 + x^916 + x^914 + x^913 + x^909 + x^906 + x^905 + x^904 + x^902 + x^897 + x^895 + x^892 + x^889 + x^888 + x^887 + x^886 + x^885 + x^884 + x^882 + x^881 + x^879 + x^876 + x^870 + x^868 + x^867 + x^865 + x^862 + x^861 + x^859 + x^858 + x^856 + x^854 + x^848 + x^847 + x^846 + x^843 + x^839 + x^837 + x^836 + x^832 + x^831 + x^830 + x^829 + x^826 + x^823 + x^821 + x^820 + x^817 + x^815 + x^812 + x^809 + x^808 + x^805 + x^803 + x^802 + x^800 + x^799 + x^797 + x^795 + x^793 + x^792 + x^788 + x^786 + x^784 + x^780 + x^775 + x^774 + x^770 + x^768 + x^766 + x^764 + x^761 + x^760 + x^753 + x^752 + x^751 + x^750 + x^747 + x^744 + x^742 + x^741 + x^737 + x^734 + x^732 + x^728 + x^727 + x^724 + x^722 + x^721 + x^719 + x^717 + x^715 + x^714 + x^713 + x^710 + x^709 + x^705 + x^703 + x^701 + x^698 + x^697 + x^695 + x^690 + x^687 + x^685 + x^684 + x^682 + x^681 + x^680 + x^677 + x^676 + x^674 + x^673 + x^672 + x^671 + x^670 + x^669 + x^665 + x^663 + x^659 + x^652 + x^651 + x^650 + x^649 + x^648 + x^647 + x^646 + x^645 + x^642 + x^640 + x^638 + x^632 + x^631 + x^630 + x^629 + x^627 + x^626 + x^623 + x^622 + x^621 + x^620 + x^616 + x^615 + x^610 + x^605 + x^602 + x^601 + x^600 + x^599 + x^598 + x^596 + x^594 + x^593 + x^591 + x^583 + x^581 + x^579 + x^578 + x^577 + x^576 + x^575 + x^573 + x^572 + x^571 + x^570 + x^569 + x^565 + x^563 + x^562 + x^561 + x^559 + x^557 + x^555 + x^552 + x^551 + x^546 + x^544 + x^542 + x^541 + x^540 + x^539 + x^538 + x^537 + x^535 + x^533 + x^530 + x^527 + x^523 + x^522 + x^520 + x^519 + x^515 + x^513 + x^511 + x^509 + x^507 + x^505 + x^504 + x^503 + x^499 + x^497 + x^496 + x^495 + x^493 + x^492 + x^488 + x^486 + x^481 + x^480 + x^479 + x^478 + x^477 + x^472 + x^470 + x^468 + x^467 + x^464 + x^463 + x^460 + x^459 + x^455 + x^454 + x^453 + x^446 + x^445 + x^444 + x^443 + x^440 + x^438 + x^437 + x^432 + x^431 + x^428 + x^427 + x^426 + x^420 + x^419 + x^416 + x^415 + x^414 + x^413 + x^412 + x^411 + x^405 + x^404 + x^401 + x^396 + x^393 + x^392 + x^391 + x^388 + x^387 + x^383 + x^381 + x^380 + x^377 + x^376 + x^369 + x^364 + x^362 + x^358 + x^357 + x^356 + x^355 + x^353 + x^351 + x^349 + x^340 + x^339 + x^338 + x^337 + x^336 + x^335 + x^334 + x^332 + x^330 + x^328 + x^327 + x^326 + x^324 + x^320 + x^318 + x^316 + x^315 + x^309 + x^302 + x^298 + x^292 + x^291 + x^290 + x^289 + x^287 + x^286 + x^285 + x^284 + x^281 + x^279 + x^278 + x^276 + x^274 + x^273 + x^272 + x^271 + x^267 + x^266 + x^264 + x^263 + x^262 + x^260 + x^259 + x^256 + x^254 + x^253 + x^252 + x^251 + x^249 + x^248 + x^247 + x^245 + x^244 + x^241 + x^239 + x^235 + x^234 + x^233 + x^232 + x^231 + x^230 + x^226 + x^224 + x^221 + x^219 + x^218 + x^216 + x^215 + x^214 + x^209 + x^207 + x^206 + x^202 + x^201 + x^198 + x^197 + x^194 + x^193 + x^192 + x^191 + x^189 + x^188 + x^183 + x^182 + x^181 + x^180 + x^179 + x^178 + x^177 + x^175 + x^172 + x^169 + x^168 + x^166 + x^165 + x^164 + x^163 + x^158 + x^157 + x^153 + x^152 + x^149 + x^147 + x^146 + x^144 + x^140 + x^139 + x^136 + x^128 + x^127 + x^126 + x^124 + x^123 + x^122 + x^121 + x^116 + x^115 + x^113 + x^112 + x^109 + x^108 + x^107 + x^106 + x^104 + x^103 + x^102 + x^101 + x^100 + x^99 + x^97 + x^95 + x^94 + x^93 + x^92 + x^87 + x^84 + x^83 + x^82 + x^80 + x^79 + x^78 + x^76 + x^73 + x^70 + x^69 + x^68 + x^67 + x^66 + x^65 + x^63 + x^60 + x^59 + x^57 + x^55 + x^52 + x^51 + x^47 + x^46 + x^45 + x^43 + x^42 + x^40 + x^36 + x^35 + x^30 + x^29 + x^28 + x^27 + x^23 + x^20 + x^17 + x^14 + x^9 + x^7 + x^3 + 1')\n    R.<a> = GF(2^2049)\n    with open('flag.enc','rb') as f:\n        pc=R.fetch_int(bytes_to_long(f.read()))\n    print solve()\n```\n\n程序运行结果如下：\n```Bash\nsage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{P1ea5e_k33p_N_as_A_inTegeR~~~~~~}jIXXXX\n```\n注：后面XXXX代表不可打印明文。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-oneTimePad2","url":"/crypto/xctf-Onetimepad-2.html","content":"\n## 题目信息\n\n看名字也可以猜出来是oneTimePad的升级版。\n\n## 分析\n\nprocess1：GF(2^128)上的乘法操作；也是oneTimePad的唯一考点。\n\nnextrand：将process2视为$\\{(x_{1},x_{2},x_{3},x_{4})|x_{i}\\in GF(2^{128})\\}$上的乘法操作，则函数最后的tmp1就是$(A,B,0,1)^{N}$；而通过几次尝试，发现$(A,B,0,1)^{N}$有形式$(A^{N},A^{N-1}\\cdot B+\\cdots +A\\cdot B+B,0,1)$，即$(A^{N},B(A^{N}-1)\\cdot (A-1)^{-1},0,1)$而这可通过数学归纳法得到证明(证明很简单，此处略)。此外，$N$更新为$N^{2}$(乘法为GF(2^128)上的乘法操作)。从而得到密钥的更新迭代公式为：$k_{i+1}=k_{i}\\cdot A^{N}+B(A^{N}-1)\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}-B(A-1)^{-1}$，则$k_{i+1}+B\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}$，记$f(k)=k+B\\cdot (A-1)^{-1}$，则$A^{N}=f(k_{i+1})\\cdot f(k_{i})^{-1}$。128位的离散对数问题sage还是可以搞定的！\n\n而由于题目给了一定长度的明文，因此我们也就得到了一定数量的密钥(3个)，使用第2个和第3个密钥恢复出生成第3个密钥的$N$；得到$N$之后进行同样的操作来恢复出加密消息时的密钥流。\n\n注：我恢复的是生成第3个密钥的$N$，需要更新($N\\leftarrow N^{2}$)才能对接下来的密文(第4组起)解密！\n\n## 解题\n\n解题分为两步，第一步解出$N$，使用的sage脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\nif __name__=='__main__':\n    K.<x>=GF(2L^128,modulus=x^128+x^7+x^2+x+1)\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher)\n    cs=[bytes_to_long(cipher[ii:(ii+16)]) for ii in range(0,len(cipher),16)]\n    pre=\"One-Time Pad is used here. You won't know that the flag is flag{\"\n    ps=[bytes_to_long(pre[ii:ii+16]) for ii in range(0,len(pre)-16,16)]\n    ks=[p^^c for p,c in zip(ps,cs)]\n    f=lambda k,a,b: k+b*(a-1)^-1\n    A=0xc6a5777f4dc639d7d1a50d6521e79bfd\n    B=0x2e18716441db24baf79ff92393735345\n    KA,KB=polify(A),polify(B)\n    Kks=[polify(t) for t in ks]\n    tt=f(Kks[2],KA,KB)*f(Kks[1],KA,KB)^-1\n    N=discrete_log(tt,KA)\n    KN=polify(N)\n    print unpolify(pow(KN,2))\n```\n脚本运行结果如下：\n```Bash\n$ sage solve.sage\n139066609048774629292054833219983607544\n```\n注：我最后做了更新操作，因此直接对第四组起的密文解密即可。\n\n第二步，进行同样的操作来恢复出加密消息时的密钥流来解密密文，使用的Python脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\nfrom oneTimePad2 import P,A,B\nfrom oneTimePad2 import process1,process2\n\ndef nextrand(rand):\n    global N, A, B\n    tmp1 = [1, 0, 0, 1]\n    tmp2 = [A, B, 0, 1]\n    s = N\n    N = process1(N, N)\n    while s:\n        if s % 2:\n            tmp1 = process2(tmp2, tmp1)\n        tmp2 = process2(tmp2, tmp2)\n        s = s / 2\n    return process1(rand, tmp1[0]) ^ tmp1[1]\n\ndef keygen():\n    key = bytes_to_long(pre)^bytes_to_long(cipher[0:16])\n    while True:\n        yield key\n        key = nextrand(key)\n\nif __name__=='__main__':\n    N=139066609048774629292054833219983607544\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher[64:])\n    pre=\"on't know that t\"\n    res=''\n    for i, key in zip(range(0,64,16),keygen()):\n        res+= long_to_bytes(bytes_to_long(cipher[i:i+16])^key)\n    print res\n```\n注：为了复用P,A,B以及process1,process2，对oneTimePad2.py做了一定调整，P,A,B的定义放在全局，其他的除了函数定义全部放到`if __name__ == '__main__':`下。\n运行脚本结果如下：\n\n```Bash\n$ python solve.py\non't know that the flag is flag{LCG1sN3ver5aFe!!}.XXXX\n```\n注：后面的字符有不可打印字符因此用XXXX代替。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-root","url":"/crypto/xctf-Root.html","content":"\n## 题目信息\n\n附件是一个流量包。\n\n## 分析\n\n在流量包中找到RSA公钥，由于没有提供任何其他信息，且模数位数很高，只能寄希望于因子之差很小，即采用费马攻击。之后将私钥导入流量包即可找出flag。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import isqrt,square,is_square\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\n\ndef fermat_factors(n):\n    assert n % 2 != 0\n    a = isqrt(n)\n    b2 = square(a) - n\n    while not is_square(b2):\n        a += 1\n        b2 = square(a) - n\n    factor1 = a + isqrt(b2)\n    factor2 = a - isqrt(b2)\n    return int(factor1), int(factor2)\n\ndef solve():\n    N=0x726f6f7400000000000000000000000000000000001b000000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001fffff7777777b00000000000000001ffffffffffffb00000000000000001ffffffffffb0000000000000000001ffffffffffb0000000000000000001ffffffffffffb00000000000000001fffff2222222b00000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb00000000000000265293c4422be3532638feeb2a635e865e5bccd4862d1491f8e46ed41afdab32ab1e913c296c45a723a371cc4ad218d273a494ac501a1c677576b84d3a1700b24e38f3d7c8090c952767f8a9da532eb4496a953fa2b2641f93af58321e491ad6b3e1f6600ea1757635a2d47562dff2f245bfc8ed511420931de246d56334d8897d6465b227f6c095ece1ad994c7551f08dbc21f8b40691ee51f5f72d052d9352062f90b0e7c52c2eb18196c2c985101af4eac67499396c6241ad4f2439ed11f87d67e73a239b865c45d65a61cf0f56082de831b97fb28ae8222a7195e0ec06c08281ffc16e7106e77e68b8c4510424beeb5582fe21cc345f53534682b75c368d73c9\n    E=31337\n    p,q=fermat_factors(N)\n    phi=(p-1)*(q-1)\n    assert GCD(E,phi)==1\n    d=inverse(E,phi)\n    rsakey=RSA.construct((N,E,d,p,q))\n    with open('key.pem','wb') as f:\n        f.write(rsakey.exportKey('PEM'))\n    return\n\nif __name__=='__main__':\n    solve()\n```\n之后将私钥导入流量包，如下图所示：\n\n{% asset_img 1.png pic1 %}\n\n然后返回，快捷键Ctrl-Alt-Shift-S来追踪SSL流，在明文的最后以'666c6167'开头，而它正好是flag的16进制编码。将这串字符进行16进制解码即得到flag。\n```Python\n>>> '666c61673a7768656e5f736f6c76696e675f70726f626c656d735f6469675f61745f7468655f726f6f74735f696e73746561645f6f665f6a7573745f6861636b696e675f61745f7468655f6c6561766573'.decode('hex')\n'flag:when_solving_problems_dig_at_the_roots_instead_of_just_hacking_at_the_leaves'\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyrsa","url":"/crypto/xctf-Babyrsa.html","content":"\n## 题目信息\n\n点击获取在线场景来得到在线场景。\n\n## 分析\n\n就是一个最常规的RSA Oracle，在CTF Wiki中[RSA部分](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_chosen_plain_cipher/)有介绍。\n\n## 解题\n\n交互解题的Python脚本如下：\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\nfrom time import sleep\nfrom Crypto.Util.number import *\n\ne=0x10001\nn=0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db\nc=0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0\n\ndef check(guess,err):\n    for m in range(guess-err,guess+err):\n        if pow(m,e,n)==c:\n            return m\n    return\n\ndef solve():\n    low,high=0,n\n    cnt=0\n    while high-low>4:\n        cnt+=1\n        tt=(pow(2,cnt*e,n)*c)%n\n        r=remote('111.200.241.244',44451)\n        re=r.recv()\n        r.sendline(hex(tt)[2:])\n        re=r.recv().strip('\\n')\n        r.close()\n        if re=='odd':\n            low=(low+high)//2\n        else:\n            high=(low+high)//2\n        print len(bin(high-low))-2\n        sleep(0.5)\n    m=check(low,150)\n    if not m:\n        print 'try again!'\n        return\n    return long_to_bytes(m)\n\nif __name__=='__main__':\n    print(solve())\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-beginners-luck","url":"/crypto/xctf-Beginners-Luck.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n通过对加密脚本的分析可知需通过PNG文件格式与最后的填充破解出密钥，[PNG文件格式详细介绍在此](https://www.cnblogs.com/senior-engineer/p/9548347.html)；大致来说，每个PNG文件的开头都是一串固定的字节来表明其PNG文件格式，你并不需要确切知道这些字节是什么，只需要找一张可正常打开的PNG文件即可！然而，仅通过PNG文件头无法破解密钥的全部24字节，于是还需要借助加密前的填充操作，填充是一串长度相同的字节，且字节的值等于这串字节的长度，通过结合这两点，即可破解出key全部24个字节。\n\n## 解题\n\n如下是解题的Python脚本(找一张可正常打开的PNG文件，命名为sample.png于同目录下)：\n```Python\ndef solve():\n    with open('BITSCTFfullhd.png','rb') as f:\n        d=f.read()\n    with open('sample.png','rb') as f:\n        dd=f.read(24)\n    pre_k=bytes([s^t for s,t in zip(d[:24],dd)])\n    me=bytes([s^t for s,t in zip(pre_k,d[-24:])])\n    L=max(me,key=me.count)\n    end_k=bytes([s^t for s,t in zip(L.to_bytes(1,'little')*L,d[-L:])])\n    key=pre_k[:-L]+end_k\n    ld=len(d)\n    assert not ld%24\n    m=bytes([s^t for s,t in zip(d,key*(ld//24))])\n    with open('FLAG.png','wb') as f:\n        f.write(m[:-L])\n    return\n\nif __name__=='__main__':\n    solve()\n    print('done!')\n```\n程序运行后会在目录下生成FLAG.png，打开即可见flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Handicraft_RSA","url":"/crypto/xctf-Handraft-rsa.html","content":"\n## 题目信息\n\n有人正在他老房子的地下室里开发自己的RSA系统。 证明他这个RSA系统只在他的地下室有效！\n\n## 分析\n\n很明显素数的生成有问题，生成的素数p，其p-1有很多小因子，使用RsaCtfTool即可破解出私钥！\n\n## 解题\n\n```Bash\n$ python3 RsaCtfTool.py -n 21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001 -e 65537 --private\n\n[*] Testing key /tmp/tmpeooqiijv.\n[*] Performing boneh_durfee attack on /tmp/tmpeooqiijv.\n[*] Performing comfact_cn attack on /tmp/tmpeooqiijv.\n[*] Performing cube_root attack on /tmp/tmpeooqiijv.\n[*] Performing ecm attack on /tmp/tmpeooqiijv.\n[*] ECM Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing ecm2 attack on /tmp/tmpeooqiijv.\n[*] ECM2 Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing factordb attack on /tmp/tmpeooqiijv.\n\nResults for /tmp/tmpeooqiijv:\n\nPrivate key :\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHk\nv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP\n4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBb\nzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3X\nECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu4\n4Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQABAoIBAQCEWcr2FXeiRcIS\nit+cYp8QowYyPR4YAfRBsyejcM56+g0WBRQdprh14R2GuXQp7h5BrXOwUQY4ZdnE\n+9caKptpl/hBV222xFXzAMtrp+DqaVye3Kn4kJutJO7JywCBNhP72kFD9odzv02b\nM0vtDB1ZK0ebHoUqmjaOlJYm+a0+OgzRG/VY6PfVs0GWdsSPtbIcautHI/+5V8US\nyG2wRH78JmTobVCLxEmdpjnUNKTM1Vsg/VCatzbkpohrE1cEZHhk+ke9uhyPvIvt\nafOC442Y09eI0vaC24IfgyAVuhOfuU3uik+JT6Vz1x9/53vorAD//wAA//8AAP//\nAAD//wABAoGBAMaX7gnjTwV6mm9o004b07Hk5Ab3PR4oEzniNgtrpP8/3Ed1wpHg\nM54idlm6rYlcLh+XWU4Z7/4v5HaNjbPaRye2tGVfGi+gY+HcrRLbEHUJlhPKUozd\nN6nayALynp7Lso19xaOz6kV86oUw+TFSi1PRnHcV01mJTgAAAAAAAAABAoGBAN2b\nbaKYDQzqBypnO+t/6JQPIvHzY8gC34qdUv7ShqvKgX70QRcFY4BY2C+ZTln0y1jv\ntX3tCwq59dzh1CRpgAfwk5nR2IjA+JLU35vAGB1IVqWmVC/VZ46zOSwy07xCJEy4\nHQ0d+PqANk8Wv2pMFmZZZfDWsYDWAAAAAAAAAAABAoGAK2b69BhEperko6KiQ7jb\nLE7c8xTHu7aAdS8WJqrQ9aQMTWXULzNztITNntCoqpOF1QurzeDnTYNECBDpvjvf\nPzOz+0+slmoUSkGDZdKQpzOAJDUck4KpbqrM+a/ysLvN+xRYxG1Grwcc7h0E6R2k\nK55s9q3DchcK//8AAP//AAECgYAUPbgb28uFXHLfGqLMddhmfaNxegupHyoP3SLR\nh6UpV8vQLrsrQSC/fl3wqw4PBV71dp+bKuWRSz77t9zKnqBFGWJB8HrYsteBgdQS\nw87wDcVsR+70l4dn71LPiKzySxBJuZ9drVkqeD99pdRB/0UkgBHhl5qK7AD//wAA\n//8AAQKBgQCYIKsSiGhJxY9AGaWofVsVe2sgGPHpwj3l2Yv8/PoG5Fpxozy+mzqv\nlDHIzJjsDIhtDeZr2cTkT6ODNM8bswDC62QnG+VUAzltXeN7P/aQzrbEUcGg7zgd\nZzvOJdNjXP9dU/vKGBT9cjjJhvwowfqnDlUVrl12W3AE/jn6U/Xpfg==\n-----END RSA PRIVATE KEY-----\n```\n破解出私钥之后，循环解密多次直到找出flag。如下Python脚本：\n```Python\nfrom base64 import b64decode\nfrom Crypto.Util.number import *\n\ndef solve():\n    N=21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001\n    d=16707734744082089987096183760536140050531071284398222525928539910115274945961673413424053379896538639181783084998088831705326266248972451538621553176990679827738650084993005694971585059194288779236578752505246610328862945930341561242587398577636666631640913502943335996493633579116896296237142465786006038646664937384294577512911411958573147328359278328601128101352047028079357406162063405979398633542591758429760763171350524080583743130797539259640940004907846945847664144924968938380506532950172261068535550048712875992662239788993590417593968724043704420879416184807161738395187599580068732017638891008132810473473\n    C=b64decode(b'eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==')\n    f=open('mes','wb')\n    for _ in range(80):\n        C=long_to_bytes(pow(bytes_to_long(C),d,N))\n        f.write(C+b'\\n\\n')\n    return\n\nif __name__=='__main__':\n    solve()\n```\n在mes中第64行：\n\n```Bash\nthe flag is: ASIS{n0t_5O_e4sy___RSA___in_ASIS!!!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"Paillier同态加密之解密的正确性","url":"/crypto/Correctness-of-decryption-of-Paillier-homomorphic-encryption.html","content":"\n## Paillier同态加密系统\n\n### 符号说明\n\n* p,q为大素数，$p\\neq q$；\n* $n=p\\cdot q$；\n* $\\lambda =(p-1)\\cdot (q-1)$；\n* $B_{\\alpha}=\\{e\\in Z_{n^{2}}^{\\ast}|ord(e)=\\alpha\\cdot n\\}$；\n* $B=\\bigcup_{\\alpha=1}^{\\lambda}B_{\\alpha}$；\n* 函数$L(x,n)=[(x-1)/n]$；\n\n### 密钥生成\n\n* 随机选择指定长度的大素数p,q；(p,q)为私钥；\n* $n=p\\cdot q$；随机选择$g\\in B$；(g,n)为公钥；\n\n### 加密\n\n* 明文m<n，随机选择r<n；\n* 密文$c=g^{m}\\cdot r^{n}\\ \\textrm{mod}\\ n^{2}$；\n\n### 解密\n* 密文$c<n^{2}$；\n* 明文$m=L(c^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)\\cdot L(g^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)^{-1}\\ \\textrm{mod}\\ n$；\n\n## 解密的正确性\n\n对于$g=1+n$的情形，网上已有很多证明解密正确性的推导，而我在这里是希望给出更一般的情形下解密正确性的证明；推导参考提出Paillier同态加密系统的这篇论文：《Public-Key Cryptosystems Based on Composite Degree Residuosity Classes》。\n\n**定义1**：定义映射$\\varepsilon_{g}: Z_{n}\\times Z_{n}^{\\ast}\\mapsto Z_{n^{2}}^{\\ast}$，$\\varepsilon_{g}(x,y)=g^{x}\\cdot y^{n}\\ \\textrm{mod}\\ n^{2}$。\n\n**引理1**：若$g$的阶$ord(g)$是$n$的非零整数倍，则$\\varepsilon_{g}$是双射。\n\n证明：由于$Z_{n}\\times Z_{n}^{\\ast}$与$Z_{n^{2}}^{\\ast}$的元素个数均为$n\\phi(n)$(参考《近世代数》(第三版)杨子胥 第149页 定理1)，因此只需证明$\\varepsilon_{g}$是单射；\n\n假设$\\varepsilon_{g}(x_{1},y_{1})=\\varepsilon_{g}(x_{2},y_{2})$；\n\n则$g^{x_{1}-x_{2}}\\cdot (y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n因此$g^{\\lambda(x_{1}-x_{2})}\\cdot (y_{1}\\cdot y_{2}^{-1})^{\\lambda\\cdot n}\\equiv g^{\\lambda(x_{1}-x_{2})}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n从而$ord(g)|\\lambda(x_{1}-x_{2})$；\n\n又$n|ord(g)\\Rightarrow n|\\lambda(x_{1}-x_{2}) , (n,\\lambda)=1\\Rightarrow n|(x_{1}-x_{2})$；\n\n因此在$x_{1},x_{2}\\in Z_{n}$的意义下，$x_{1}=x_{2}$；\n\n那么$(y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，理由如下：\n\n假设$x^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则：\n$$\n\\begin{cases}\nx^{(p-1)\\cdot q+q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{(q-1)\\cdot p+p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n即：\n$$\n\\begin{cases}\nx^{q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n又$(p,q-1)=1$，$(q,p-1)=1$，从而存在$s,t\\in Z$，使得$p\\cdot s\\equiv 1\\ \\textrm{mod}\\ q-1 , q\\cdot t\\equiv 1\\ \\textrm{mod}\\ p-1$，同理可得：\n$$\n\\begin{cases}\nx\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n由中国剩余定理，$x$在模$n$意义下有唯一解，又1满足上述同余方程组，因此$x\\equiv 1\\ \\textrm{mod}\\ n$\n回到本引理的证明，则有$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，即$y_{1}\\equiv y_{2}\\ \\textrm{mod}\\ n$；\n综上，$\\varepsilon_{g}$是单射，也是双射。\n\n**解密的正确性**\n\n由引理1，存在$(a,b)\\in Z_{n}\\times Z_{n}^{\\ast}$使得$g=(1+n)^{a}\\cdot b^{n}\\ \\textrm{mod}\\ n^{2}$，则：\n\n$g^{\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\cdot b^{n\\cdot\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\equiv 1+na\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n同理，$c^{\\lambda}\\equiv (g^{m}\\cdot r^{n})^{\\lambda}\\equiv [(1+n)^{a}\\cdot b^{n}]^{m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\cdot b^{n\\cdot m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\equiv 1+mna\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n因此，$L(c^{\\lambda})\\cdot [L(g^{\\lambda})]^{-1}\\equiv ma\\lambda\\cdot (a\\lambda)^{-1}\\equiv m\\ \\textrm{mod}\\ n$。","tags":["Paillier"],"categories":["crypto"]},{"title":"使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)","url":"/conf/personal-blog.html","content":"**前言** 系统环境为Ubuntu18.04\n\n## 准备工作\n\n### 安装nodejs\n\n从[node官网](https://nodejs.org/en/download/)下载二进制包(最后下载低一点的版本，这样之后配置主题时成功率更高)并命名为nodejs，再进行如下操作：\n```Bash\n$ sudo mv nodejs /opt/\n$ sudo cp /opt/nodejs/bin/node /usr/local/bin/ && chmod +x /usr/local/bin/node\n```\n在/opt/nodejs/bin目录下还有npm、npx两个sh脚本，试过符号链接到/usr/local/bin/目录下但是运行不了，那就只能在运行它们时使用绝对路径精确指定了:(，将npm换淘宝源以便更快下载：\n```Bash\n$ /opt/nodejs/bin/npm config set registry https://registry.npm.taobao.org\n```\n\n### 安装hexo\n使用npm安装hexo：\n```Bash\n# 这种下载方式不会出错，遇到错误的都懂\n$ sudo /opt/nodejs/bin/npm install --unsafe-perm --verbose -g hexo\n```\n\n## 本地博客部署\n新建一个文件夹用来存放博客数据：\n```Bash\n$ mkdir hexo\n```\n在新建的博客文件夹hexo的父目录初始化hexo：\n```Bash\n$ hexo init hexo\n```\n输出警告“Failed to install dependencies”，继续执行下面命令即可；\n```Bash\n$ cd hexo\n$ /opt/nodejs/bin/npm install\n```\n使用hexo编译静态页面：\n```Bash\n$ hexo generate\n$ hexo server\n```\n然后在浏览器中进入`http://localhost:4000`，就可以看到编译好的静态页面。\n\n## 本地配置博客\n\n下载一个自己觉得好看的主题，比如jsimple；\n```Bash\n$ git clone https://github.com/tangkunyin/hexo-theme-jsimple themes/jsimple\n```\n然后将hexo/_config.yml文件中的`theme: landscape`更改为`theme: jsimple`\n手动安装主题所需依赖`hexo-generator-search`：\n```Bash\n/opt/nodejs/bin/npm install hexo-generator-search --save\n```\n还没到打开网页的时候，还要进行一些文件的配置：\n* scaffolds/post.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\ncategory:\ntags:\ncomments: true\n```\n**注**author、authorLink、authorAbout、authorDesc可以换成自己想写的内容，avatar的/images/favicon.png可以换成自己想换的图片；\n\n* scaffolds/page.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\nlayout: {{ title }}\n```\n\n* _config.yml对应内容(原来有的如果不一样改成与下面一样，没有的添加进去)配置得与如下内容一样：\n```Bash\n# 语言配置\nlanguage:\n    - zh-cn\n\n# URL （注意 permalink 格式。其中timestamp是改了源码加上的，具体参见patch目录文件）\nurl: https://shuoit.net\nroot: /\npermalink: :category/:entitle-:timestamp.html\npermalink_defaults:\n  lang: en\n\n# 搜索配置\nsearch:\n  path: search.json\n  field: all\n  content: true\n  \n# 分类和标签别名\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n**注** 其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n然后重新编译静态页面(由于本文接下来会多次进行下述操作，因此提到\"重新编译静态页面\"就是进行下面操作)：\n```Bash\n$ hexo clean && hexo generate\n$ hexo server\n```\n然后在浏览器进入`http://localhost:4000`，可以看到主题已经应用；在终端按Crtl-C退出继续配置；\n\n## 完善页面\n\n### tag|category\n当我们打开这些页面时都显示`Cannot GET /categories/XXX`，因为这些页面还没创建！因此需要创建这些页面：\n```Bash\n# 经过测试，page category及其子页面可以不用生成，如果一个分类下存在文章，那么该分类页面可以正常显示，否则会出现GET: categorise/XXX错误\n$ hexo new page categories\n$ hexo new page tech -p categories/tech\n$ hexo new page humanity -p category/humanity\n#下面这些页面一定要生成\n$ hexo new page tags\n$ hexo new page help\n$ hexo new page about\n$ hexo new page links\n```\n\n重新编辑静态页面，标签(tag)、分类(category)已经没有问题了！\n\n### 数学公式\n\n卸载原Markdown渲染器，安装`hexo-renderer-kramed --save`这款Markdown渲染器：\n```Bash\n$ /opt/nodejs/bin/npm uninstall hexo-renderer-marked --save\n$ /opt/nodejs/bin/npm install hexo-renderer-kramed --save\n```\n安装了新的Markdown渲染器并没有完全解决公式渲染的问题！接下来修改node_modules/kramed/lib/rules/inline.js的内容—第11行与第20行，分别改为：\n```Bash\n# 第11行，原为escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,改为如下：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n# 第20行，原为em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,改为如下：\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n将主题配置文件_config.yml中的mathjax的enable设置为true，对于需要公式渲染的博客，在开头添加`mathjax: true`，重新编辑静态页面，可以看到该博客内的公式可以被无误渲染！\n\n### 小插曲\n\n正当我兴致冲冲重新编辑静态页面，去看看配置好的另一篇带有数学公式的博客时，神奇的事情发生了，博客页面出现的竟然是hello world！！！整个人发出无数wc，平静下来后在这篇博客的地址栏发现了端倪，地址是这样的：\n```Bash\nhttp://localhost:4000/tech/undefined-undefined.html\n```\n刚看到这个我也不明白是哪里出了问题，不断的研读两篇配置文件，终于找到了一点突破，我们还记得在前面，根据主题作者修改配置文件时有一个`permalink: :category/:entitle-:timestamp.html`，首先是我感觉这有点像地址的构造方式(原谅我还没学过前端，一点小聪明还望大佬勿喷)，category我知道是什么，它就在文章开头设置的，那么基本上就清楚了，地址是根据category、entitle与timestamp三者组合而成的，而我在博客开头压根没有设置什么timestamp，所以地址生成失败，统一生成了undefined-undefined，其实地址这么复杂我也用不到，就自己改成如下：\n```Bash\npermalink: :category/:title.html\npermalink_defaults:\n```\n重新编辑静态页面，终于没问题了！\n\n### 地图(sitemap)\n\n为保证博客可被baidu、Google检索，需安装`hexo-generator-sitemap`插件：\n```Bash\n$ /opt/nodejs/bin/npm install hexo-generator-sitemap --save\n```\n\n### 嵌入图片\n\npost_asset_folder设置为true，对于需要引用图片的博客，首先在与博客的同目录下新建一个与博客名相同的文件夹，想要引用的图片放入该文件夹中，以`{% asset_img 1.png pic1 %}`命令就可以嵌入图片！虽然在Typora中不能显示，但是编辑到博客中可以正常显示。\n\n### 其他\n\n还有一些site_name，头像，cover_title，cover_description等等自己改一下就行了。\n\n## 部署到Gitee\n\n在本地将博客配置得足够满意之后，还要将博客部署到Gitee上面，这样其他人也可以在互联网访问；\n\n### 申请Gitee pages\n\n这个主题必须要求博客是`根目录部署`，就是创建的项目名称与个人空间地址一致，重要的事情说三遍！！！网上大部分教程说的项目名称与用户名一致是因为他们申请Gitee账号后没有更改用户名，从而个人空间地址与用户名一致，因此他们的做法可以正确部署到根目录，但是如果你更改过用户名导致个人空间地址与用户名一致的话，那么这时你创建的项目名称应该与个人空间地址一致，否则就是错误的`根目录部署`！\n\n个人空间地址在：设置-->个人资料-->个人空间地址进行查看。\n\n项目创建好之后，新建一个blog分支；然后开启Gitee Page服务，服务部署到blog分支上，勾选强制使用HTTPS；然后就可以生成Page了，这时我们可以看到什么叫根目录部署了，以我的Gitee Pages服务的地址为例：`https://chu-kangming.gitee.io`；\n\n### 部署到Gitee Pages\n\n安装hexo-deployer-git组件：\n\n```Bash\n/opt/nodejs/bin/npm install hexo-deployer-git --save\n```\n\n我这里假定你电脑上面已经安装git，并且公钥已经添加到了Gitee；修改站点配置文件_config.yml的deploy：\n```Bash\ndeploy:\n  type: git\n  repo: ssh地址\n  branch: blog\n```\n\n使用命令`hexo d`就可以将本地的博客数据部署到Gitee上面，可以看到blog分支下已经有了博客数据，但是，但是你如果这个时候打开Gitee Pages服务的地址它还是404，或者和你本地的博客显示不一致，这时因为Gitee Pages还没有更新(Gitee Pages Pro可以自动更新，但是需要氪金)，你只能手动更新：\n\n{% asset_img 1.png pic1 %}\n\n点击上图的更新，等重新部署完成，再次打开Gitee Pages服务地址，可以看到博客的效果终于和本地的博客效果一致了！\n\n注意：\n* 比如我的search功能好像还有些问题，可以再`hexo d`一次然后再更新一次Gitee Pages，如果还不行可以稍等一会儿再看，毕竟没有氪金，更新起来不会很快，我等第二天早上再去博客时search功能就正常了；\n\n* 每次刷新浏览器时不要用Ctrl-R，一定要用Shift-F5强制刷新；\n\n**参考链接**\n\n[使用Gitee+Hexo搭建个人博客](https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[hexo本地与部署不一致](https://blog.csdn.net/GAI159/article/details/105128186)\n\n[Hexo + Gitee采坑指北](https://www.luogu.com.cn/blog/jelly123/hexo-gitee-cai-keng-zhi-bei)\n\n[渲染公式](https://www.jianshu.com/p/7ab21c7f0674)\n\n[引用图片](https://segmentfault.com/q/1010000019625231)\n\n[sitemap](https://blog.csdn.net/formemorywithyou/article/details/96478453)\n\n","tags":["hexo","gitee","jsimple"],"categories":["conf"]},{"title":"Ubuntu18.04安装ntl库","url":"/conf/Ubuntu1804-installs-the-NTL-library.html","content":"## 安装\n\n首先去[官网](https://www.shoup.net/ntl)下载安装包，下列shell脚本与安装包放到同一目录，赋予此脚本执行权限。另外，我这里默认你的电脑上面已经安装gcc，g++，make。\n\n```Bash\n#apt install -y gcc\n#apt install -y g++\n#apt install -y make\napt install -y autoconf\n\napt install -y m4\napt install -y libgmp-dev\napt install -y libgf2x-dev\n\ntar zxvf ntl-11.4.3.tar.gz\n\nmv ntl-11.4.3 ntl\n \necho -e \"\\033[31m start install ntl \\033[0m\"\ncd ntl/src\n./configure NTL_GF2X_LIB=on\nmake && make check && make install\ncd - >> /dev/null\n \nrm -r ntl\n```\n## 测试\n\n新建一个rand.cpp（顾名思义，是输出随机数）\n\n```C++\n#include <NTL/ZZ.h>\n#include <time.h>\nNTL_CLIENT\nint main()\n{\n\tZZ a,b,c;\n\tSetSeed(to_ZZ(time(NULL)));\n\tRandomLen(a, 32);\n\tRandomLen(b, 32);\n\tc = a + b;\n\tcout << \"a=\" << a << \", b=\" << b << \", c=\" << c << \"\\n\";\n\treturn 0;\n}\n```\n按照官网的介绍，使用如下命令编译：\n```Bash\ng++ -g -O2 -std=c++11 -pthread -march=native rand.cpp -o rand -lntl -lgmp -lm\n```\n其中rand.cpp是c++文件，rand是编译后的可执行文件。程序运行效果如下：\n```Bash\n$ ./rand\na=2298665095, b=3622090486, c=5920755581\n```\n\n**参考链接**：\n[NTL库快速上手中文指南](https://blog.csdn.net/tzwh_86/article/details/9372411#commentBox)\n[A Tour of NTL](https://libntl.org/doc/tour.html)","tags":["Ubuntu","ntl"],"categories":["conf"]},{"title":"git基础使用&gitee","url":"/tech/The-basic-Git-use-with-Gitee.html","content":"## 在网站上初始化\n\n在[码云](https://gitee.com/)上创建项目基本是傻瓜式操作。创建一个名为git-test的私有项目以备后续使用。\n\n本文介绍在本地创建仓库、将仓库上传至服务器以及本地与服务器的交互。\n\n## 在本地创建仓库及相关操作\n\n```Bash\n# 初始化一个Git仓库，则执行命令的目录会作为一个仓库\nmkdir /home/gitee/git-test && cd /home/gitee/git-test\ngit init\n# 那么git-test文件夹将会作为一个仓库\n# 新建一个文件然后将文件添加到Git的暂存区\necho 'Life is beautiful' > README.md && git add \"README.md\"\n# 查看仓库当前文件提交状态(A：提交成功；AM：文件在添加到缓存之后又有改动)\ngit status -s\n# 从Git的暂存区提交版本到仓库，参数-m后为当次提交的备注信息\ngit commit -m \"1.0.0\"\n```\n\n## 本地与服务器的交互\n\n在本地与服务器交互之前，先配置ssh公钥；保证已经安装了ssh(apt install -y ssh)，使用ssh-keygen生成ssh公钥：\n```Bash\ngit config --global user.email 'gitee注册邮箱'\ngit config --global user.name 'gitee用户名'\nssh-keygen -t rsa\n```\n在~/.ssh目录下有一个id_rsa.pub文件，里面的文本以ssh-rsa开头，将这些文本全部复制，转到设置->安全设置->ssh公钥，随便写个标题，将id_rsa.pub中的文本全部复制到公钥下面的框内。\n\n关于项目的ssh地址如何获得，见下图：\n\n{% asset_img 1.png pic1 %}\n\n下面介绍一些本地与服务器的常用交互\n```Bash\n# 在不执行克隆操作时将一个远程仓库添加到本地的仓库\ngit remote add origin ssh地址\n# 如果不需要远程的更新，比如此时远程只是一般性的初始化内容，可使用-f选项进行强制推送(远程仓库默认名为origin)\ngit push origin master -f\n# 克隆服务器中的项目(即在1中新建的名为git-test的项目)到本地\ngit clone ssh地址\n## 文件修改(本地)\n# 修改文件README.md，在文件后面追加一行'local change'\n# 此时查看状态\ngit status -s\n#先将文件添加到Git的暂存区，然后提交\ngit add 'README.md' && git commit -m '1.0.1'\n# 用本地仓库内容更新远程仓库内容\ngit push ssh地址\n# 刷新网站，可以看到服务器上面的内容已经与本地一致\n\n## 文件添加(本地)\n# 创建一个输出hello,world的C文件并将其编译\necho -e '#include <stdio.h>\\n\\nint main()\\n{\\n\\tprintf(\"hello,world\\\\n\");\\n\\treturn 0;\\n}' > hello.c && gcc hello.c -o hello -g\n# 先将新增的文件添加到Git的暂存区\ngit add he*\n# 这里可以查看一下状态\ngit status -s\n# 从Git的暂存区提交版本到仓库\ngit commit -m '1.0.2'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上已经有新增的文件\n\n## 文件移动(本地)\n# 为增强项目文件的组织性，我将上述的两个新增文件移到一个文件夹中\nmkdir Hello && git mv he* Hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.3'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上原来新增的两个文件已经在新建的文件夹下\n\n## 文件删除(本地)\n# 如我要将hello这个可执行文件删除\ngit rm Hello/hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.4'\n# 将更改同步到远程服务器\ngit push ssh地址\n\n# 如果是在网站上对项目做出更改(文件修改、添加、移动与删除)，要将更改同步回本地(即拉取)，使用pull命令\ngit pull origin master\n```\n以上基本上包含了使用git常见问题的解决方案。","tags":["git"],"categories":["tech"]},{"title":"鲲鹏计算专场密码学部分详解","url":"/crypto/HUAWEICTF2021.html","content":"## 平平无奇的RSA\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/HUAWEI/task_task_gHXvFLV)\n\n### 分析\n\n题目由三个小问题组合而成，下面分别对他们进行分析。\n\n**Level 3**\n\n从脚本可得的信息如下：\n\n$N_{3}=p\\cdot q$，$\\phi$是$N_{3}$的欧拉函数；\n\n$s\\cdot sinv\\equiv 1\\ \\textrm{mod}\\ q$，再令$e=4s\\cdot sinv+3$(且要保证$(e,\\phi)=1$)；\n\n给你一组已知明-密文$km,kc$，即$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}$；\n\n那么分解$N_{3}$的步骤如下：\n\n$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}\\Rightarrow kc\\equiv km^{e}\\ \\textrm{mod}\\ p\\Rightarrow kc\\equiv km^{4s\\cdot sinv+3}\\ \\textrm{mod}\\ p$\n\n由欧拉定理可得：$km^{s\\cdot sinv}\\equiv km\\ \\textrm{mod}\\ p$，从而$kc\\equiv km^{4+3}\\ \\textrm{mod}\\ p$，即$kc\\equiv km^{7}\\ \\textrm{mod}\\ p$\n\n则$p|(km^{7}-kc)\\Rightarrow p=(km^{7}-kc,N_{3})$，因此$N_{3}$的一个因子是其与$km^{7}-kc$的公约数，进而分解出$N_{3}$；\n\n分解出$N_{3}$后，解密$c_{3}$得到Level 2的密文，下面分析Level 2。\n\n**Level 2**\n\n从脚本可得的信息如下：\n\n$o,s$是两个随机生成的素数，$t$是$o$的下一个素数，$u$是$s$的下一个素数；\n\n已知$os=o\\cdot s,tu=t\\cdot u$，$N_{2}=o\\cdot s\\cdot t\\cdot u\\Rightarrow tu=N_{2}//os$，这道题在18年强网杯的nextrsa的第四关考察过，[此处](https://www.cnblogs.com/WangAoBo/p/8654120.html)是对其的writeup\n\n**Level 1**\n\n这一层很简单，从$(N_{1}//1323)^{1/4}$往下开始试除即可(第一次写的时候疏忽了，往上试除，程序跑了几分钟都没解出来)。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\n$ python3 solve.py\nflag{4c2fd4e6-44de-445f-8c34-1235464de2de}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"drangon2020密码学部分详解","url":"/crypto/Drangon-2020-Cryptography-Section.html","content":"## Bit_Flip1\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_1)\n\n### 分析\n\n**1.过一遍程序**\n\n* 生成16个随机的字节作为alice_seed，与接收到的flip_str异或取后32个字节(不够在前面加\\x00)即为seed；\n\n* 由于alice = DiffieHellman(flip_str(alice_seed))没有设置prime，因此alice初始化时会调用get_prime()来生成素数；\n\n* 重点来看get_prime()这个函数；它不停的调用getbits(512)直到生成的数是一个素数；\n\n* 来看getbits()的原理：先调用more_bytes()积累足够的“随机”字节，每次调用more_bytes()都会在generated后面加上seed的sha256哈希值(长256比特)；\n\n* seed的更新方式为seed=long_to_bytes(bytes_to_long(seed)+1,32)，在这里简单看作seed的值增1即可；\n\n* generated收集到足够的字节之后，取后num比特作为生成的随机数，未用到的“随机”字节仍然保存在generated中；\n\n* 判断getbits(512)生成的是否为素数，若不是继续调用getbits(512)；\n\n* 得到素数之后，会告知你iter——相对于一次生成就能得到素数，对getbits(512)增加的调用次数(易知每调用一次getbits(512)，seed自增2)；\n\n* 返回prime后；调用getbits()生成64位的mysecret(DH算法的私钥)，然后计算$mynumber\\equiv 5^{mysecret}\\ \\textrm{mod}\\ prime$(DH算法的公钥)，设置shared为1337后，alice的初始化工作完成。\n\nbob=DiffieHellman(urandom(16), alice.prime)按照同样的方式完成初始化工作，只不过此时bob的prime直接使用alice的prime；\n\nalice与bob经密钥协商得到双方都知道的协商密钥(与DH算法略有不同，多了一个与1337的异或操作)，该密钥作为AES的加密密钥对FLAG进行加密。\n\n**2.寻找突破**\n\n我相信程序输出的数据都是有它的作用的，print(\"bob number\", bob.my_number)给出bob的公钥是为了让我们得到prime与secret之后可以同样计算出协商密钥；输出iv与enc_flag作用也很明显；那么程序输出iter就值得注意了，一定是对我们解题有用！\n\n**3.利用iter**\n\n那么我们如何借助iter来获取足够多的信息以致于解出FLAG；iter间接体现了get_prime()调用getbits()的次数！\n\n由于程序会接收我发送的flip_str，因此我们可以改变seed的值，即使我们不知道seed的值，但是这仍然有用！\n\n既然我们不知道seed的值(是因为我们不知道alice_seed的值)，那我们记alice_seed的值为$s_{127}\\cdots s_{1}s_{0}$，我们的考虑这样的情况：\n\n我发送如下两个flip_str：\n\nflip_str_1：空字节\n\nflip_str_2：|$1$|$0$|\n\n那么经bit_flip()就能生成如下2种seed：\n\nseed_1：|$s_{127}$|$\\cdots$|$s_{1}$|$s_{0}$|\n\nseed_2：|$s_{127}$|$\\cdots$|$1\\oplus s_{1}$|$s_{0}$|\n\n由这2个seed生成素数的iter分别记为iter_1与iter_2；\n\n分类讨论：\n\n* $s_{1}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{1}=1$，seed_2+2=seed_1，如果iter_2非0，必有iter_2-iter_1=1；\n\n那么当$iter\\_1\\cdot iter\\_2\\neq 0$时，由于$s_{j}$非0即1，因此此时iter_1-iter_2=1与iter_2-iter_1=1至少(没写错，确实是至少)有一个成立！此时$s_{j}=0\\Rightarrow$iter_1-iter_2=1，因此(原命题的真假性与逆否命题的真假性一致)$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$，即iter_1-iter_2=-1$\\Rightarrow s_{j}=1$。\n\n那如果$iter\\_1\\cdot iter\\_2=0$怎么办？这时根据iter_1-iter_2的值是无法判断$s_{1}$的值的！由于我们只需要保持|seed_1-seed_2|=2即可，因此我们可以改变flip_str前面的字节，这样得到的seed_x(x=1,2)的哈希值与原来显著不同，从而$iter\\_1\\cdot iter\\_2$的值有可能发生改变，不停的改变flip_str前面的字节直到$iter\\_1\\cdot iter\\_2\\neq 0$，就可以由上述分析过程解出$s_{1}$！\n\n一般地，类似于数学归纳法；假设我已经分析出$s_{j-1}\\cdots s_{1}$(这里没写错，$s_{0}$我是没有分析出来的)，借助已经得到的信息分析出$s_{j}$，思路如下：\n\n* 发送如下4种flip_str：\n\nflip_str_1：| $0$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_2：| $1$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\nflip_str_3：| $1$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_4：| $0$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\n那么经bit_flip()就能生成如下4种seed：\n\nseed_1：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_2：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\nseed_3：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_4：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\n由这4个seed生成素数的iter分别记为iter_1、iter_2、iter_3与iter_4；\n\n分类讨论：\n\n* $s_{j}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{j}=1$，seed_3+2=seed_4，如果iter_3非0，必有iter_3-iter_4=1；\n\n那么当$iter\\_1\\cdot iter\\_3\\neq 0$，由于此时$s_{j}$非0即1，因此iter_1-iter_2=1与iter_3-iter_4=1必有一个成立！同样地，$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$；因此，当$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)\\neq 0$时，$iter\\_3-iter\\_4=1\\Rightarrow iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$。\n\n如果$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)=0$，同样地，改变flip_str前面的字节直到进入上述情形!\n\n综上，我给出了对$s_{1}$的分析思路，也给出了由$s_{j-1}\\cdots s_{1}$推出$s_{j}$的分析思路；最终我可以还原出alice_seed除$s_{0}$之外的所有比特位，而$s_{0}$非0即1，因此最后解出的结果与alice_seed的值相差不超过1！\n\n接下来按照同样的方式生成AES密钥，对密文进行解密即可！\n\n### 解题\n\n这道题我并没有在比赛的时候做出来，因此我对task.py的交互方式作了一些改变；flag是自己设置的；上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\nλ python3 solve.py\nb'1\\xbc\\xfa\\x1b+5\\xed1\\x99\\xf7\\xa0\\x07\\x8e\\tQ\\xee'\nDrangon{just_for_test_flag}\n```\n\n## Bit_Flip2\n\n### 题目信息\n\n附件仍然是一个Python脚本，相对于Bit_Flip1只有1行代码不同，它将print(\"bob number\", bob.my_number)这一行注释起来；[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_2)\n\n### 分析\n\n同Bit_Flip1的方法可解出alice_seed，可此时我并不知道bob.my_number；虽然当时想过控制alice.my_secret为0，但是觉得太不切实际，而事实上writeup就是这么做的！这需要你对比特币有一定的了解，知道使用块散列算法(可[参见此处](https://chu-kangming.gitee.io/crypto/Bitcoin-Block-hashing-algorithm.html))可以生成以一定长度的0字节结尾的哈希值。按同样的方法推测出alice_seed后发送特定的flip_str使得alice以特定的seed初始化，使得alice.my_secret为0，那么bob.my_number就对我们解密出flag无关紧要了。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，同样因为题目没有在比赛的时候做出了，flag是我自己设置的；程序运行结果如下：\n\n```Bash\n$ python solve.py\nb'Drangon{just_for_test_flag}\\x00\\x00\\x00\\x00\\x00'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"Bitcoin—块散列算法","url":"/crypto/Bitcoin-Block-hashing-algorithm.html","content":"## BTC Block\n\n[BTC Block](https://live.blockcypher.com/btc/)\n\n{% asset_img 1.png pic1 %}\n\n点击进入Height为658423的哈希值(000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c)\n\n{% asset_img 2.png pic2 %}\n\n## Block hash算法\n\n[Block hash算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)\n\n它有多强大呢？举个例子：\n\n```Python\n>>> from hashlib import sha256\n>>> d=bytes.fromhex('01000000'+'81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000'+'e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b'+'c7f5d74d'+'f2b9441a'+'42a14695')\n>>> h=sha256(d).digest()\n>>> sha256(h).hexdigest()\n'1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000'\n```\n\n通过它构造的消息，其哈希值后面有很长的一段0！想知道上面的消息怎么构造，请往下看：\n\n### 准备工作\n\n* 安装pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n\n* 安装curl工具\n\n如果你用的Linux系统，curl工具可通过命令行安装；\n\n对于我使用的Windows系统，去[官网](https://curl.se/windows/)下载工具包，解压到C:\\Windows\\System32目录下或者将bin目录下的curl.exe的路径加入环境变量；\n\n### 获取构造特定哈希值的信息\n\n对我们想要的哈希值000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c，在命令行运行：\n```Bash\n# curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c > data\n```\n因为返回的消息太多了，因此输出重定向到文件中存下来；我们主要关注的有：ver、prev_block、mrkl_root、time、bits与nonce；这些值提取出来如下：\n```Python\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n```\n注意：ver、time、bits与nonce找最前面的，prev_block与mrkl_root找最后面的，不然算出来的哈希值会不是我们想要的。\n\n接下来，使用我写好的脚本如下，通过将这些信息组合起来就可以构造出消息，其哈希值就是000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c！\n\n```Python\nfrom hashlib import sha256\nfrom binascii import hexlify,unhexlify\nfrom Crypto.Util.number import long_to_bytes\n\n#curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n\ndef num_to_Bytes(n):\n    byte_n=long_to_bytes(n,4)\n    return byte_n[::-1]\n\ndef hex_to_Bytes(h):\n    s=unhexlify(h)\n    return s[::-1]\n    \ndef Bitcoin_demo():\n    d=num_to_Bytes(data['ver'])+hex_to_Bytes(data['prev_block'])+hex_to_Bytes(data['mrkl_root'])+num_to_Bytes(data['time'])+num_to_Bytes(data['bits'])+num_to_Bytes(data['nonce']%pow(2,32))\n    h=sha256(d).digest()\n    return sha256(h).digest()\n\nif __name__=='__main__':\n    ret=Bitcoin_demo()\n    print(hexlify(ret[::-1]))\n```\n\n程序运行结果如下：\n\n```Bash\n# python3 Bitcoin.py\nb'000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"win10正版安装+配置记录","url":"/conf/Win10-legal-installation-configuration-records.html","content":"## 前言\n\n自己以前作为一个电脑小白，重装系统时直接在百度上面搜索，搜到的全是各种下载站，从这些网站上面下载的系统其实已经改过了，安装完之后会给你预装很多软件，你又要花时间把他们删掉，可以说很不方便；去微软官网上面找，如果不知道怎么找，可能很不容易找到，于是写下这篇博客备忘，也方便他人。\n\n## 下载镜像并制作启动盘\n\n安装前，准备好8GB以上的U盘(必须真的是8G以上，U盘质量一定要过关；另外，U盘里面的数据要备份好，制作启动盘会让原来的数据不复存在)\n\n**1.**先去[微软官方镜像下载地址](https://www.microsoft.com/zh-cn/software-download/windows10/)，下载MediaCreationTool；\n\n**2.**以管理员方式，运行MediaCreationTool；首先给出声明与许可条款，选择接受；此时会给你两种操作，升级本机或者创建安装介质，我习惯创建安装介质；\n\n**3.**选择语言、体系结构与版本，直接默认就好；\n\n**4.**选择要使用的介质，我这里选择U盘；插上事先准备好的U盘，如下图点击下一步：\n\n**5.**等待工具下载win10\n\n**6.**创建安装介质\n\n创建完成后，点击完成，工具做一些清理工作就会退出。\n\n打开文件资源管理器，可以看到启动盘已经制作完毕：\n\n## 安装\n\n1.如果安装时鼠标用不了，可以使用tab键进行切换；\n\n2.安装过程中最好联网；\n\n3.删除不常用文件夹\ncmd-->regedit\n3D对象：HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->MyComputer\n->NameSpace->{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}\n音乐：{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}\n\n4.“开始”关掉设置、图片。\n\n\n## 安装常用软件\n\n[360zip国际版](https://www.360totalsecurity.com/zh-cn/360zip/)\n\n[百度网盘](http://pan.baidu.com/download)\n\n[Clover](http://en.ejie.me/)\n\n```Bash\n注：我们知道win10下面的文件资源管理器打开多个位置时是多个窗口，这个插件就可以以多标签页来管理，特别好用。\n但是你要忍受经常的广告的骚扰\n```\n\n[Chrome浏览器](https://www.google.cn/intl/zh-CN/chrome/)\n\n[TIM](https://office.qq.com/download.html)\n\n```Bash\n注：窗口设置和微信差不多，感觉比QQ好用。\n```\n\n[迅雷&迅雷影音](https://www.xunlei.com/)\n\n[腾讯会议](https://meeting.tencent.com/download-center.html?from=1001)\n\n[cmder](https://cmder.net/)\n\n```Bash\n控制台模拟器，让你有一种用上Linux终端的感觉。\n更改快捷键Ctrl-T(新建标签页)为Crtl-Shift-T，避免与ctags的快捷键冲突。\n```\n\n[WPS](https://pc.wps.cn/)\n\n```Bash\n记得在“我的电脑”隐藏网盘。\n```\n\n[Python3.6.4](https://www.python.org/downloads/windows/)\n\n```Bash\n注：安装的时候注意勾选添加到环境变量；将python改成python3以与python2程序区分；\nwin10菜单搜索[管理应用执行别名]，关闭下面两个按钮[应用安装程序])；\n安装ctf密码学常用python库。\n```\n\n[VirtualBox](https://www.virtualbox.org/wiki/Downloads)\n\n[Vim](https://github.com/vim/vim-win32-installer/releases)\n\n```Bash\n添加环境变量：右键此电脑->属性->高级系统设置->环境变量，选中Path，并点击编辑，新建->填写vim程序的路径，点击3个确定才算成功添加；\n在安装vim的文件夹下有一个_vimrc文件，备份好之后写上自己的配置)；\n安装ctags插件：http://ctags.sourceforge.net；像ctags58.zip这种名称是支持win10的，下载下来之后只需要将ctags.exe复制到vim的安装目录下即可！\n```\n\n[yafu](https://sourceforge.net/projects/yafu/files/)\n\n```Bash\n强大的因子分解工具。\n```\n\n[Sagemath](https://github.com/sagemath/sage-windows/releases)\n\n[Curl](https://curl.se/windows/)，利用URL规则在命令行下工作的文件传输工具。\n\n[Telegram](https://desktop.telegram.org/)\n\n另外在win10应用商店里有几个不错的应用：微信、网易云音乐，淘宝。\n\nIDA Pro、SSR就看自己了。\n\n注：安装IDA Pro之后会顺带安装python2.7，同样将其安装的路径加入环境变量。","tags":["windows"],"categories":["conf"]},{"title":"ByteCTF2020密码学部分详解","url":"/crypto/BytectF2020-cryptography-section-details.html","content":"## noise\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/noise)\n\n### 分析\n\n穷举通过proof_of_work之后，我们来看代码逻辑：\n\n*   secret=getrandbits(1024)，注意他自己实现的getrandbits(1024)实际上是生成长1017~1024位的随机数；\n*   对上述生成的secret，服务器最多只会与你交互64次；\n*   若op为'god'，服务器会返回num * getrandbits(992) % secret，这里num也由我指定；\n*   若op为'bless'，服务器会判断num与secret是否相等，若相等服务器返回FLAG。\n\n由于我至少要留一次交互机会发送我计算出的secret，因此我必须在63次交互内计算出secret！为下面叙述方便，声明如下记号：\n\n*   第 i 次发送的num记为$n_{i}$；\n*   第 i 次getrandbits(992)记为$g_{i}$；\n*   第 i 次接收的num * getrandbits(992) % secret记为$c_{i}$。\n\n记secret为$m$，则：\n\n$c_{i} \\equiv n_{i}\\cdot g_{i}\\ \\textrm{mod}\\ m,i=1,\\cdots ,63$\n\n即存在$k_{i}\\in Z$，$n_{i}\\cdot g_{i}=c_{i}+k_{i}\\cdot m$\n\n对等式两边模$n_{i}$则有：\n\n$c_{i}+k_{i}\\cdot m \\equiv 0\\ \\textrm{mod}\\ n_{i}$\n\n若我能够控制$k_{i}=1$，那么：\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n同时得到多个如上形式的等式可考虑使用中国剩余定理解出$m$！\n\n### 利用$n_{i}$控制$k_{i}$\n\n$m$有$1/2$的概率长1024比特，$g_{i}$有$1/2$的概率长992比特；此时，要控制$k_{i}=1$，即：\n$$\n\\left\\{\n\\begin{aligned}\nn_{i}\\cdot g_{i} &>m \\\\\nn_{i}\\cdot g_{i} &<2m\n\\end{aligned}\n\\right.\n$$\n对上式两边取对数：\n$$\n\\left\\{\n\\begin{aligned}\nlog(n_{i})+log(g_{i}) &>log(m) \\\\\nlog(n_{i})+log(g_{i}) &<log(m)+1\n\\end{aligned}\n\\right.\n$$\n记$log(g_{i})=991+\\alpha,log(n_{i})=32+\\beta,log(m)=1023+\\gamma;\\alpha,\\beta,\\gamma \\in (0,1)$(其中$X=2^{\\alpha},Y=2^{\\gamma}$服从$[1,2]$上的均匀分布)。上式改写为：\n$$\n\\left\\{\n\\begin{aligned}\n\\alpha+\\beta &>\\gamma \\\\\n\\alpha+\\beta &<1+\\gamma\n\\end{aligned}\n\\right.\n$$\n综上，$P(k_{i}=1)=P(\\alpha+\\beta>\\gamma,\\alpha+\\beta<1+\\gamma)=P(2^{\\beta}\\cdot X>Y,2^{\\beta-1}\\cdot X<Y)$\n\n直观地看，$\\beta$越大越有利于约束条件$\\alpha+\\beta>\\gamma$而不利于约束条件$\\alpha+\\beta<1+\\gamma$，反之，$\\beta$越小越有利于约束条件$\\alpha+\\beta<1+\\gamma$而不利于约束条件$\\alpha+\\beta>\\gamma$。\n\n注意到我可以判断是否满足约束条件$\\alpha+\\beta>\\gamma$—若$n_{i}\\cdot g_{i}<m$则$c_{i}=n_{i}\\cdot g_{i}$从而$c_{i}\\equiv 0\\  \\textrm{mod}\\ n_{i}$。\n\n由此，我选择$n_{i}$时应该尽量满足约束条件$\\alpha+\\beta<1+\\gamma$，即$\\beta$应尽量小，为何不设置$\\beta$为0，理由如下：\n\n当$\\beta=0$时，$P(k_{i}=1)=P(\\alpha>\\gamma,\\alpha<1+\\gamma)=P(\\alpha>\\gamma)=1/2$；\n\n由上述：$n_{i}$长$33$比特，而$m$长$1024$比特；由中国剩余定理可知：我们需要32个如下形式的同余式才能解出$m$！\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n要得到如上形式的同余式，即需要$k_{i}=1$，而$P(k_{i}=1)=1/2$，那么我得到$32$个如上形式的同余式“平均”需要$64$次交互，从而我没有发送secret的交互机会。\n\n综上，$\\beta$应在大于0的前提下尽量小！\n\n### 值得注意的地方\n\n通过2.1，我知道了$n_{i}$值多大时可以解出$m$，结合中国剩余定理，同余式的模数之间是互素的，即我选择的$n_{i}$需两两互素，因此$n_{i}$不是取确定的值而是在一定的取值范围内取素数！\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本，程序运行(成功时)结果如下：\n\n```bash\n$ python3 solve.py\n[+] Opening connection to 182.92.153.117 on port 30101: Done\n[+] MBruteforcing: Found key: \"l9a\"\nsuccess!\n95613903744255213782277288259288084531700829576284706991256294359734535087821985034716432798049279163174069238632678362676474782669781482301447573436852554131343117198284150657465643396718720128642929008328391123641254705186541184339088382138616985634723733544083949806487213357784626124965521562172300016682\nb'CONGRATULATIONS ByteCTF{Noise_i5_rea11y_ANN0YING}\\n'\n[*] Closed connection to 182.92.153.117 port 30101\n```\n\n注：此程序并非次次运行都能解出secret\n\n## threshold\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/threshold)\n\n### 分析\n\n程序又臭又长，但其实考点特别简单，稍微使用一下欧拉定理即可！我来分析一下程序的逻辑：\n\n在类TSM2初始化时：\n\n$pks \\equiv [(sk+1)\\cdot sks]^{n-2}\\ \\textrm{mod}\\ n$\n\n接着在output_p1函数中：\n\n$s \\equiv (d_{1}\\cdot k_{1}\\cdot s_{2}+d_{1}\\cdot s_{3}-r)\\ \\textrm{mod}\\ n$\n\n其中$d_{1}=sks$，而$r,s_{2},s_{3}$均由我指定，那么我令$r=s_{2}=0,s_{3}=1$，则得到的$s$即为$d_{1}$在模$n$下的值，即：\n\n$s \\equiv sks\\ \\textrm{mod}\\ n$\n\n注意到$n$是素数，欧拉函数$\\phi(n)=n-1$，显然$(n-2,n-1)=1$，即存在$x\\in Z,x\\cdot (n-2)\\equiv 1\\ \\textrm{mod}\\ \\phi(n)$\n\n由欧拉定理：$pks^{x}\\equiv [(sk+1)\\cdot sks]^{(n-2)x}\\equiv (sk+1)\\cdot sks\\ \\textrm{mod}\\ n$\n\n因此$(sk+1)\\equiv pks^{x}\\cdot sks^{-1}\\equiv pks^{x}\\cdot s^{-1}\\ \\textrm{mod}\\ n$，而密钥$sk$是小于阶$n$的，因此解出密钥$sk$，有了密钥干什么不行呢，按照程序的要求，对消息b'Hello, Welcome to ByteCTF2020!'签名即可！\n\n### 解题\n\n略","tags":["ctf"],"categories":["crypto"]},{"title":"Ubuntu安装metasploit-framework(方便安全可秒全网现有各种方法)","url":"/conf/Ubuntu-Installs-Metasploit-Framework-Easy-Secure-Instable.html","content":"## 前言\n\n做项目需要用到metasploit-framework这款强大的渗透工具，学长给的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)下载起来巨慢，重新在网上找方法：网上几乎都是添加Kali源来安装metasploit-framework，但是自己手残在apt update后加了一条apt upgrade -y，然后电脑开始下很多奇奇怪怪的东西直到电脑完全动不了，最后只能重装Ubuntu！所以总结一下网上在Ubuntu安装metasploit-framework的两种方法要么慢，要么危险。\n\n## deb包安装\n\n推荐一种安全又快捷的方法，使用deb包进行安装：[deb包链接在此](https://apt.metasploit.com/)；翻到最下面，可以看到有metasploit-framework的deb包\n\n\n\n选择最新版的下载下来，使用gdebi来安装deb包即可\n```Bash\nsudo gdebi metasploit-framework_6.0.13+20201023102229~1rapid7-1_amd64.deb\n```\n可以看看安装好的效果：\n\n\n## 后记\n\n我来说一下上面的deb包链接是怎么找到的；从上述的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)开始，下面的Installing\n\n\n点击the free installer,再到下面的Linux manual installation\n\n\nhttps://apt.metasploit.com 就是deb包的链接。","tags":["Ubuntu","msf"],"categories":["conf"]},{"title":"return2libc实验","url":"/tech/Return2libc-experiment.html","content":"**前言**\n[实验程序GitHub链接](https://github.com/coderall/return-to-libc-attack)\n注：实验环境为Ubuntu16.04的32位虚拟机(virtualbox)\n\n## 预备工作\n关闭地址随机化，否则攻击失败\n```Bash\nsudo sysctl -w kernel.randomize_va_space=0\n```\n{% asset_img 1.png pic1 %}\n\n## 任务1—查找libc函数的地址\n编译retlib.c，设置-fno-stack-protector关闭ubuntu上StackGuard保护机制，设置-z -execstack/noexecstack可打开或关闭可执行栈的机制，使用gdb来获取当前system()与exit()的地址\n```Bash\nsudo gcc retlib.c -fno-stack-protector -z noexecstack -o retlib -g\nsudo chmod 4755 retlib\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np system\np exit\nq\n```\n{% asset_img 2.png pic2 %}\n\n我们可以看到system()函数的地址是0xb7e43da0，exit()函数的地址是0xb7e379d0，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 3.png pic3 %}\n\n改完之后：\n\n{% asset_img 4.png pic4 %}\n\n## 任务2—将shell字符串放入内存中\n创建环境变量MYSH来记录/bin/sh路径，编译getenv.c，运行getenv程序获取/bin/sh的地址\n```Bash\nexport MYSH=\"/bin/sh\"\ngcc getenv.c -z noexecstack -o getenv -g\n./getenv MYSH ./retlib\n```\n{% asset_img 5.png pic5 %}\n\n可以看到/bin/sh的地址为0xbffffe41，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 6.png pic6 %}\n\n改完之后：\n\n{% asset_img 7.png pic7 %}\n\n## 任务3—找出栈溢出地址相对buffer的偏移\n\n下面我们介绍  *(long *) &buf[24] = 0xb7e5f430 ;   //  system()  中的24是怎么得到的；\n首先你应该对return to libc的原理有一定了解(不了解先参见[此处](https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/index.html))(原理看完就可以回来了，实验部分这里讲得更清楚^_^)\n这里的24就是栈溢出地址相对buffer的偏移；一种有用的办法是这样做的：生成较长的由a-zA-Z组成的随机字符串(比如我生成长100的这样的字符串)，将它写入badfile文件，然后用gdb调试retlib程序；\nrand.py程序如下：\n```Python\nfrom string import ascii_letters as al\nfrom random import randint\n\nX=[randint(0,51) for _ in range(100)]\nprint ''.join([al[x] for x in X])\n```\n\n```Bash\npython rand.py >> badfile\ngdb -q retlib\n#进入gdb命令行\nr\n```\n\n{% asset_img 8.png pic8 %}\n\n不用设置断点，直接运行然后会发生栈溢出错误，并且告诉你栈溢出的地址，在我调试的过程中，栈溢出的地址为0x4a4c4e49，把这个地址转换为字符串并反转是INLJ(之所以要反转是因为地址的表示为大端表示)，INLJ在上述生成的随机字符串中的索引就是24，说明栈溢出地址相对buffer的偏移为24；\n\n## 任务4—利用缓冲区溢出漏洞\n编译exploit.c，攻击，进入/bin/sh程序\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n{% asset_img 9.png pic9 %}\n\n## 任务5—增加调用setuid进行提权\n首先按照同样的方式获取setuid()函数的地址，然后更改程序exploit.c；\n```Bash\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np setuid\nq\n```\n{% asset_img 10.png pic10 %}\n\n可以看到setuid()函数的地址为0xb7eba2e0，使用上述得到的地址更改程序exploit.c，改完之后：\n\n{% asset_img 11.png pic11 %}\n\n重新编译exploit.c然后进行攻击(如果攻击失败，尝试：重启->关闭地址随机化->export MYSH=\"/bin/sh\"，然后重新执行下面三行命令)\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n攻击结果如下：\n{% asset_img 12.png pic12 %}","tags":["ret2libc"],"categories":["tech"]},{"title":"Makefile初探","url":"/tech/The-Makefile-que.html","content":"## 背景\n\n如果做过工程，或者读过一些优秀的开源代码的话；了解.c文件需要分开写，每个.c文件实现特定的一小部分功能，另外还有一些.h文件，这种文件主要引用一些头文件，声明一些函数(虽然函数可以直接定义无需声明，但是先声明再定义是一个好习惯，另外一些虚函数是仅仅声明而不定义的)与宏；这些.c文件再被不同的目录组织；以上就是工程一般的框架，这些.c文件既可能依赖.h文件，也可能依赖其他.c文件，单单一行gcc的编译命令已经解决不了，这时需要Makefile来指导编译过程！\n\n## 语法规则\n\n目标文件：依赖文件\n|tab|编译规则\n\n注：|tab|代表一个tab键\n\n## Demo\n\n我的文件组织如下：\n```Bash\n.\n├── include\n│   └── head.h\n├── Makefile\n└── src\n    ├── add.c\n    ├── div.c\n    ├── master.c\n    ├── mul.c\n    └── sub.c\n```\n\nhead.h的代码如下：\n```C\n#include <stdio.h>\n\nint add(int a,int b);\n\nint sub(int a,int b);\n\nlong mul(long a,long b);\n\nfloat div(float a,float b);\n```\n\nadd.c的代码如下：\n```C\n#include \"head.h\"\n\nint add(int a,int b)\n{\n\treturn a+b;\n}\n```\n差不多这个意思，其他的代码就自己完善吧；\n\n最后master.c代码如下：\n```C\n#include \"head.h\"\n\nint main()\n{\n\tint a,b;\n\ta=12;\n\tb=3;\n\tprintf(\"%d add %d = %d\\n\",a,b,add(a,b));\n\tprintf(\"%d sub %d = %d\\n\",a,b,sub(a,b));\n\tlong ma,mb;\n\tma=12;\n\tmb=3;\n\tprintf(\"%ld mul %ld = %ld\\n\",ma,mb,mul(ma,mb));\n\tfloat fa,fb;\n\tfa=12;\n\tfb=3;\n\tprintf(\"%f div %f = %f\\n\",fa,fb,div(fa,fb));\n\treturn 0;\n}\n```\n\n下面是Makefile文件：\n```Makefile\nmaster:rely1.o rely2.o rely3.o rely4.o rely5.o\n\tgcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nrely1.o: src/master.c include/head.h\n\tgcc -c -I include src/master.c -o src/master.o\nrely2.o: src/add.c include/head.h\n\tgcc -c -I include src/add.c -o src/add.o\nrely3.o: src/sub.c include/head.h\n\tgcc -c -I include src/sub.c -o src/sub.o\nrely4.o: src/mul.c include/head.h\n\tgcc -c -I include src/mul.c -o src/mul.o\nrely5.o: src/div.c include/head.h\n\tgcc -c -I include src/div.c -o src/div.o\n.PHONY:clean\nclean:\n\tfind . -name '*.o'  | xargs rm -f\n```\n\n下面make生成可执行文件：\n```Bash\n$ make && make clean\ngcc -c -I include src/master.c -o src/master.o\ngcc -c -I include src/add.c -o src/add.o\ngcc -c -I include src/sub.c -o src/sub.o\ngcc -c -I include src/mul.c -o src/mul.o\ngcc -c -I include src/div.c -o src/div.o\ngcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nfind . -name '*.o'  | xargs rm -f\n```\n\nmake clean会执行Makefile文件中clean下的命令，它会清除所有的目标文件(.o文件)，因为已经不需要了！\n\n我们测试一下可执行文件是否正确执行：\n```Bash\n$ ./master\n12 add 3 = 15\n12 sub 3 = 9\n12 mul 3 = 36\n12.000000 div 3.000000 = 4.000000\n```\n\n注：可以看到Makefile中的rely1.o等等只是代号，真正目标文件的名称设定由编译规则指定。","tags":["makefile"],"categories":["tech"]},{"title":"i春秋\"巅峰极客\"2020密码学部分详解","url":"/crypto/I-Spring-and-Autumn-Peak-Geek-2020-Cryptography-in-detail.html","content":"## tryecc\n\n### 题目信息\n\n附件是一个sage脚本与一个文本文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/iCHUNQIU/tryecc)在此\n\n### 分析\n\n$$\nE_{1}: y^{2}\\equiv x^{3}+ax+c\\ \\textrm{mod}\\ N\n$$\n\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ N\n$$\n\n我们总结一下已知量和未知量：\n\n| 已知            | 未知      |\n| :-: | :-: |\n| $N,C,P_{1},P_{2},P_{3},P_{4}$ | $A,B,m_{1},m_{2}$ |\n\n那么已知$P_{1}(x_{1},y_{1}),P_{2}(x_{2},y_{2})$就可以计算出$a,b$：\n$$\ny_{1}^{2}\\equiv x_{1}^{3}+a\\cdot x_{1}+c\\ \\textrm{mod}\\ N\n$$\n$$\ny_{2}^{2}\\equiv x_{2}^{3}+a\\cdot x_{2}+b\\ \\textrm{mod}\\ N\n$$\n\n$$\na=(y_{1}^{2}-x_{1}^{3}-c)\\cdot x_{1}^{-1}\\ \\textrm{mod}\\ N\n$$\n\n$$\nb=y_{2}^{2}-x_{2}^{3}-a\\cdot x_{2}\\ \\textrm{mod}\\ N\n$$\n\n\n\n好在$x_{1}$在模$N$下有逆，于是$a,b$就可以解出，到此得到了$E_{1},E_{2}$；\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n$$\nP_{4}=m_{2}\\cdot P_{2}\\ in\\ E_{2}\n$$\n\n\n\n丢到sgaemath里面去解离散对数，结果发现解不出来！\n\n但是发现$N$不是素数，用yafu分解一下$N$，发现$N$是两个素数的乘积，记为$N=p\\cdot q$，那么椭圆曲线$E_{2}$可重写为\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\\cdot q\n$$\n这样$E_{2}$上的点也满足下面两个等式：\n$$\nE_{p}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\n$$\n\n\n即$E_{2}$上的点同时在$E_{p}$与$E_{q}$上(试了一下，我们可以求解$P_{3},P_{4}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数)\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n 则有：\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{p}\n$$\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{q}\n$$\n\n\n\n那是不是意味着我们解出$P_{3}$在椭圆曲线$E_{p}$上关于基点$P_{2}$的离散对数就是$m_{1}$呢？非也！我们解出的只是$m_{1}\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})$，即$m_{1}$模了$P_{2}$在椭圆曲线$E_{p}$上的阶之后的值！\n\n要想解出$m_{1}$，需要将$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数结合起来！\n$$\nm_{1}\\equiv s_{p}(1)\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})\n$$\n$$\nm_{1}\\equiv s_{q}(1)\\ \\textrm{mod}\\ order_{E_{q}}(P_{2})\n$$\n\n\n\n这里$s_{p}(1),s_{q}(1)$分别是$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数；\n\n使用中国剩余定理解上述方程组即可解出$m_{1}$，同理解出$m_{2}$\n\n### 解题\n\n上述链接中的solve.sage为解题的脚本；程序运行结果如下(运行时间有点长，稍微等一下)：\n\n```Bash\n$ sage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{de7a89ab1d074ef3930fb3054c0e3ac8}\n```\n\n## 后记\n\n一直在等师傅们关于密码学题目的writeup，结果一直没有找到；就只能把自己唯一做出来的一道题目的writeup写一下。","tags":["ctf"],"categories":["crypto"]},{"title":"Sagemath在ctf密码学中的使用","url":"/crypto/Use-of-Sagemath-in-CTF-Cryptography.html","content":"## 基本的环和域\n\n```Python\n#整数域,有理数域和实数域\nZZ(3)\nQQ(0.25)\nRR(2^0.5)\n#复数域\nCC(1,2)\n#生成虚数单位i\ni=ComplexField().gen();(2+i)*(4+3*i)\n\n#构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环\n#定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域\nR.<w>=PolynomialRing(ZZ);R\n(1 + w)^3\n\n#有限环\nRN=IntegerModRing(63)\nFR=Integers(17);FR\n#自身的代数扩展;exR=FR[w]/(w^2+3)\nexR=FR.extension(w^2+3)；exR\n#以python整数的形式返回所有可逆元素的列表\nFR.list_of_elements_of_multiplicative_group()\n#假设环的乘法群是循环的，返回这个环的乘法群的生成元\nFR.multiplicative_generator()\n#返回这个环的一个随机元素\nFR.random_element()\n#上述几种方法对如下的域同样支持\n\n#有限域\n#素数域\nG1=GF(37);G1\n#伽罗瓦域\nG2=GF(3^5);G2\n```\n\n## 数论基本函数\n\n```Python\n#同时求商与余数\nq,r=divmod(12,5)\n\n#求公约数\nd=gcd(12,5)\n\n#扩展的欧几里得算法\nd,u,v=xgcd(12,5)\n\n#12在模5下的逆\nu=inverse_mod(12,5)\n\n#生成[lb,ub)之间的随机素数,注意ub在前,lb在后,lb可缺省为0\n#可通过这种方式生成128位的随机素数\np=random_prime(2L**128,2L**127)\n\n#判断是否为素数\nis_prime(65537)\n\n#第20个素数\nnth_prime(20)\n\n#计算x^y mod n\nz=power_mod(12,5,17)\n\n#欧拉函数\neuler_phi(111)\n\n#中国剩余定理,A=[a1,...,an],M=[m1,...,mn]\n#ai=x mod mi,i=1,...,n\ncrt([1,2,3,4],[7,5,12,23])\n\n#求自身的n次根\nFR(12).nth_root(7,all='True')\n\n#求多项式的根，roots方法必须作用在域上\nR.<x>=PolynomialRing(G1)\nxt=G1(12)\nyt=xt^6\nf=x^6-yt\nf.roots()\n```\n\n## 线性代数\n\n```Python\n#定义矩阵，默认定义在实数域\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#定义在其他域上的矩阵，如有限域\nA = matrix(GF(13),[[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#可以看到两个逆矩阵不一样\n\n#定义向量，定义在有限域，默认定义在实数域\nw = vector(GF(13),[1,1,4,3])\nY=A*w;Y\nZ=w*A;Z\n\n#解线性方程组AX=Y\nX = A.solve_right(Y);X\n#也可以使用符号\\\nA\\Y\n#解线性方程组XA=Y\nX = A.solve_left(Z);X\n\n#格基约减\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\n#LLL算法\nA.LLL()\n#BKZ算法\nA.BKZ()\n```\n\n## 离散椭圆曲线\n以国密SM2算法使用的椭圆曲线为例；\n\n```Python\np=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF',16)\na=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC',16)\nb=ZZ('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93',16)\n#有限域GF(p)上的椭圆曲线y^2 = x^3 + a*x + b mod p\nE=EllipticCurve(GF(p),[0,0,0,a,b])\n#基点\ng=E([ZZ('32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7',16),ZZ('bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0',16)])\n#基点的阶\nn=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123',16)\n#生成密钥\nsk=random_prime(2*n//3,n//3)\n#生成公钥\nG=sk*g\n```\n\n## 离散对数\n\n前言：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是'+'与'\\*'，默认为'\\*'；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。\n\n```Python\n#通用的求离散对数的方法\nx=discrete_log(a,base,ord,operation)\n\n#求离散对数的Pollard-Rho算法\nx=discrete_log_rho(a,base,ord,operation)\n\n#求离散对数的Pollard-kangaroo算法(也称为lambda算法)\nx=discrete_log_lambda(a,base,bounds,operation)\n\n#小步大步法\nx=bsgs(base,a,bounds,operation)\n```\n\n## coppersmith算法\n\n[coppersmith算法介绍链接](https://www.cnblogs.com/coming1890/p/13506057.html)\n\n使用sage实现coppersmith相关攻击，[GitHub链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n最后，sage的[官方文档链接](https://doc.sagemath.org/html/en/reference/)","tags":["ctf","sagemath"],"categories":["crypto"]},{"title":"Elgamal&RSA小结","url":"/crypto/Elgamal-RSA-summary.html","content":"## 前言\n\n要解决的问题：$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但$(e,\\phi(N))>1$)。\n\n## 分类讨论\n\n首先给出求解方程($q,e$为素数)$y\\equiv x^{e}\\ \\textrm{mod}\\ q^{k}$的[Python脚本](https://github.com/KangMing-ux/AllRootModqk)\n\n注：当$k=1$时，可(使用Sagemath)直接在有限域$GF(q)$上对$y$开$e$次方；\n\n### $N=p^{a}$\n\n记$g=(e,\\phi(N)),e_{1}=e/g$，则$(e_{1},\\phi(N))=1$，因此可以计算$d_{1}\\equiv e_{1}^{-1}\\ \\textrm{mod}\\ \\phi(N)$；$c^{d_{1}}\\equiv m^{e\\cdot d_{1}}\\equiv (m^{g})^{d_{1}\\cdot e_{1}}\\equiv m^{g}\\ \\textrm{mod}\\ N$，从而可得$m^{g}\\ \\textrm{mod}\\ p^{a}$，接下来使用上述工具求解(最多有$g$个解)。\n\n### $N=p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}}$\n$c\\equiv m^{e}\\ \\textrm{mod}\\ N\\Rightarrow c\\equiv m^{e}\\ \\textrm{mod}\\ (p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}})$，则有\n$$\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n记$\\phi_{i}=\\phi(p_{i}^{a_{i}})$，$g_{i}=(e,\\phi_{i})$，$e_{i}=e/g_{i}$，$d_{i}\\equiv e_{i}^{-1}\\ \\textrm{mod}\\ \\phi_{i}$\n$$\nm^{g_{1}}\\equiv c^{d_{1}}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm^{g_{k}}\\equiv c^{d_{k}}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n这时处理的方式不唯一；我们只考虑那些$g_{i}$很小的线程同余方程，不妨设$g_{1},\\cdots,g_{t}$很小；\n\n(1)$g_{1}=\\cdots =g_{s}=r$，$s\\leqslant t$(不妨设前$s$个$g_{i}$相等)\n\n利用中国剩余定理求解前$s$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$下的解；当$m^{r}<p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$时，直接对解开$r$次方即得$m$；\n\n(2)一般情况，$g_{i}(i=1,\\cdots,t)$很小但是大多数各不相同\n\n那么首先对每个方程组利用上述工具求解(记$x_{i}$为第$i$个方程的解，此时大多数方程组有多个解，每个方程组的解最多有$g_{i}$个)\n\n$$\nm\\equiv x_{1}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm\\equiv x_{k}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n\n利用中国剩余定理求解前$t$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{k}^{a_{t}}$下的解；当$m<p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}$时，$m$必在这些解中。\n\n注：其实这里也解释了为什么考虑那些$g_{i}$很小的线程同余方程，我们最多要求解$g_{1}\\cdots g_{t}$个这样的方程组，每个方程组会求出一个解；如果$g_{i}$很大，那么候选的解太多；但是我们要保证$p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}>m$。","tags":["rsa","elgamal"],"categories":["crypto"]},{"title":"攻防世界-密码学-onetimepad","url":"/crypto/xctf-Onetimepad.html","content":"## 题目信息\n\n附件中包含实现加密的Python脚本，与密文文件。\n\n## 分析\n\n### 有限域$GF(2^{n})$\n\n构造有限域$GF(2^{n})$时，首先需要$GF(2)$上次数为n的本原多项式$g(x)$；对于$GF(2^{n})$上的每个元素$a$，都可以用一个次数不超过$n$的多项式$f_{a}$表示：$f_{a}(x)=\\sum_{i=0}^{n-1}a_{i}\\cdot x^{i}$，其中$a_{n-1}\\cdots a_{0}$是$a$的二进制表示；从而$GF(2^{n})$上的四则运算定义如下：\n\n* 加法：对于$a,b\\in GF(2^{n})$，它们的多项式表示分别为$f_{a},f_{b}$，记$f_{c}=f_{a}+f_{b}$(其中系数的加法为$GF(2)$上的加法，即异或运算)，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a+b$的值；\n\n* 减法：由于$GF(2)$上的加法与减法等价，因此对于$a,b\\in GF(2^{n})$，$a+b=a-b$；\n\n* 乘法：同样地，$a,b$的多项式表示$f_{a},f_{b}$，记$f_c=f_{a}\\cdot f_{b}\\ \\textrm{mod}\\ g$，由于多项式$g$的次数为$n$，故多项式$f_{c}$的次数不超过$n$，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a\\cdot b$的值；\n\n* 除法：先介绍(乘法)逆元，本原多项式是一种具有特殊性质的不可约多项式，对GF(2)上任意次数不超过$n$的多项式f，都存在$GF(2)$上次数不超过n的多项式$h$，使得$f\\cdot h \\equiv 1\\ \\textrm{mod}\\ g$；与$f$作除法等价于与$f$的逆元$h$作乘法；\n\n### process(m,k)\n\n考虑$t^{2},t\\in GF(2^{256})$，构造$GF(2^{256})$的本原多项式为$g=x^{256}+x^{10}+x^{5}+x^{2}+1$，记$t$的二进制表示为$t_{n-1}\\cdots t_{0}$，则$t$的多项式表示$f_{t}(x)=\\sum_{i=0}^{n-1}t_{i}\\cdot x^{i}=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})$，考虑$t^{2}$：\n\n$f_{t}^{2}\\ \\textrm{mod}\\ g$\n\n$=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})\\cdot f_{t}\\ \\textrm{mod}\\ g$\n\n$=((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n$=((((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n我们再来对比函数process(m,k)：\n\n```Python\ndef process(m, k):\n    tmp = m ^ k\n    res = 0\n    for i in bin(tmp)[2:]:\n        res = res << 1;\n        if (int(i)):\n            res = res ^ tmp\n        if (res >> 256):\n            res = res ^ P\n    return res\n```\nres=res<<1代表乘以x，多项式的系数全体左移一位；\n\nif (int(i)):res^=tmp等价于res^=int(i)*tmp，代表$+t_{i}\\cdot f_{t}$；\n\nif (res>>256):res^=P代表模本原多项式g；\n\n综上，process(m,k)实际上实现了$GF(2^256)$上的元素$m$与$k$之和的平方$(m+k)^{2}$；\n\n### 解密过程\n\n$k_{2}=(k_{1}+secret)^{2},k_{3}=(k_{2}+secret)^{2}$(在GF(2^256)上的运算)\n\n$c_{1}=m_{1}\\oplus k_{1},c_{2}=m_{2}\\oplus k_{2},c_{3}=m_{3}\\oplus k_{3}$，其中$c_{i}(i=1,2,3),m_{i}(i=1,2)$已知\n\n则$k_{2}=m_{2}\\oplus c_{2},k_{3}=m_{3}\\oplus c_{3}$，可解出secret：$secret=k_{3}^{1/2}+k_{2}$(在GF(2^256)上的运算)\n\n接下来解出$k_{1}$：$k_{1}=k_{2}^{1/2}+secret$(在GF(2^256)上的运算)\n\n然后解出flag(即$m_{1}$)：$m_{1}=c_{1}\\oplus k_{1}$\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,long_to_bytes\n\nK.<x>=GF(2L**256,modulus=x^256+x^10+x^5+x^2+1)\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\ndef solve():\n    cip1=polify(0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07f)\n    cip2=polify(0x630eb4dce274d29a16f86940f2f35253477665949170ed9e8c9e828794b5543c)\n    cip3=polify(0xe913db07cbe4f433c7cdeaac549757d23651ebdccf69d7fbdfd5dc2829334d1b)\n    msg2=polify(bytes_to_long('I_am_not_a_secret_so_you_know_me'))\n    msg3=polify(bytes_to_long('feeddeadbeefcafefeeddeadbeefcafe'))\n    secret=cip2+msg2+(cip3+msg3).sqrt()\n    key1=(cip2+msg2).sqrt()+secret\n    msg1=cip1+key1\n    return long_to_bytes(unpolify(msg1))\n\nif __name__=='__main__':\n    print 'flag{'+solve()+'}'\n```\n\n程序运行结果如下：\n```Bash\n$ sage solve.sage\nflag{t0_B3_r4ndoM_en0Ugh_1s_nec3s5arY}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-sleeping-guard","url":"/crypto/xctf-Sleeping-Guard.html","content":"## 题目信息\n\n点击还原比赛场景后，会给出镜像服务器的ip以及连接端口。且提示：“只有真正的hacker才能看到这张图片”\n\n## 分析\n\n连接上服务器之后，服务器返回的数据看上去像base64编码，对此，解码即可；根据题目的提示，flag藏在图片中，解码后文件头数据不是png,jpg,bmp文件头格式(说明不是直接解码这么简单)，也不是zip,rar,7z文件头格式(说明不是将图片加密压缩)；实际上，原比赛的此题还有一个Python脚本，大致意思是使用长度为12的密钥与图片数据进行(循环)异或加密，有了这个信息之后，尝试使用各种图片格式的文件头与加密数据进行异或得到密钥，使用png格式的文件头与加密数据进行异或时，得到的结果“很像”密钥；接下来使用密钥解密即可。\n\n## 解题\n\n首先从服务器接收全部的数据，再进行base64解码(将解码后的数据存入文件data)；\n\n然后通过png文件头解出密钥，然后通过密钥解密，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom binascii import unhexlify\nfrom Crypto.Util.strxor import strxor\n\ndef enc(data,key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve(data):\n    head=unhexlify('89504e470d0a1a0a0000000d49484452')\n    key=strxor(head,data[:16])\n    with open('sleeping-guard.png','wb') as f:\n        f.write(enc(data,key[:12]))\n\nif __name__=='__main__':\n    with open('data','rb') as f:\n        solve(f.read())\n```\n\n最后解密出图片\n\n{% asset_img 1.png pic1 %}","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-streamgame1","url":"/crypto/xctf-StreamGame1.html","content":"## 题目信息\n\n附件给出实现流加密的Python脚本与一段输出的密钥流。\n\n## 分析\n\n通过对加密脚本的理解，可得本题的LFSR模型：\n{% asset_img 1.png pic1 %}\n\n其中 $a_{n-1},a_{n-2},\\cdots,a_0$ 为程序中 mask 的二进制位，当 $a_i=1$ 时，将 $b_i$ 输入异或运算，否则 $b_i$ 不输入异或运算；根据模型我们可以得到如下等式：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{1}   & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nb_{0}   & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n其中的加法为异或，因为$a_{n-1} =1$，将上式重写如下：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n由异或性质：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n再将等式“还原”：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nk_{2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nk_{n-1} & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{n} & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n计算的顺序由下至上，即可解出初始状态的所有比特位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom gmpy2 import c_div\n\ndef lfsr(R,mask):\n    output = (R << 1) & 0xffffff    \n    i=(R&mask)&0xffffff             \n    lastbit=0\n    while i!=0:\n        lastbit^=(i&1)    \n        i=i>>1\n    output^=lastbit\n    return (output,lastbit)\n\ndef cal(s,mask):\n    lm=len(bin(mask))-2\n    R=int(s[-1:]+s[:-1],2)\n    ss=''\n    for j in range(lm,0,-1):\n        (_,tk)=lfsr(R,mask)\n        ss=str(tk)+ss\n        R=int(s[j-2]+str(tk)+bin(R)[2:].rjust(lm,'0')[1:-1],2)\n    return ss\n\ndef solve():\n    mask=0b1010011000100011100\n    lm=len(bin(mask))-2\n    with open('key','rb') as f:\n        stream=f.read(c_div(lm,8))\n    s=''.join([bin(256+ord(it))[3:] for it in stream])\n    flag='flag{'+cal(s[:lm],mask)+'}'\n    return flag\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{1110101100001101011}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"GACTF2020密码学部分详解","url":"/crypto/GACTF2020-Cryptography-Section.html","content":"### 前言\n\n比赛网址：[GACTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=147&hash=cf494a33-0f22-4e85-a48d-7a02efeedc90.event)\n[writeup参考链接](https://0xdktb.top/2020/08/30/WriteUp-GACTF2020-Crypto/)\n\n## ezAES\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF/ezAES)的challeng.py。\n\n### 分析\n\n整体浏览Python脚本后，可得此题考察CBC分组加密工作模式；总结一下脚本给出的信息：\n* key给出前14位(key长16位，即最后2位未知)\n* message的长度为86字节，因此明文最后一组填充10个'\\n'\n* 密文最后一组给出后10个字节\n\n因此，可穷举key的最后2位，每一位考虑所有可打印字符，有100种可能，因此穷举key的最后2位有$10^{4}$种可能，处于合理范围；对每一个key，解密最后一组密文，将解密出的明文后10位与上一组密文后10位异或，若异或后均为'\\n'，则说明穷举出正确的key；\n解出正确的key之后，可按照同样的方式计算出SECRET，从而获取整个明文；\n已知所有明文之后，由CBC工作模式：$m_{i}=D(c_{i};key)\\oplus c_{i-1},i=n,\\cdots,1$，其中$c_{0}=IV$，那么已知最后一组密文，就可以递推出IV：$c_{i-1}=D(c_{i};key)\\oplus m_{i},i=n,\\cdots,1$\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本；\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n[+] MBruteforcing: Found key: \"pd\"\n9j_for_aes_cbc!!\n```\n\n## what_r_the_noise\n\n### 题目信息\n\n噪音太大，听不见，China:124.71.145.165:9999(现在应该已经失效了)。\n\n### 分析\n\n大致意思是服务器返回的数据是加入了噪声的，让你去掉噪声，解出正确的明文；有点概率论知识应该想到获取多次数据取平均值。\n\n### 解题\n\n解题的Python脚本在[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/what_r_the_noise)中；\n\n解出的flag可能不完全正确，但是你基本可以猜出是什么单词了！\n\n最后得到flag为gactf{you_know_much_about_differential_privacy}\n\n## da Vinci after rsa\n\n### 题目信息\n\n附件中包含两个文本文件encryption与output；encryption中是一列数，output给出“RSA公钥”与密文；[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/da_Vinci_after_rsa)\n\n### 分析\n\nda Vinci翻译了一下(英语不好)是达芬奇，这既然是密码学题目，自然去查了一下达芬奇密码，发现这是一本书，在网上不停地查这本书，找到一个片段，“打乱的数字”一下引起我的注意，后面马上提到“斐波那契数列”，回去一看，encryption中的那一列数确实是打乱的斐波那契数列，到此encryption的作用弄明白了；\n\n接下来将公钥的模数N放到yafu中分解，得到三个因子；但是我想，不怕，和RSA问题一样求解$d\\equiv e^{-1}\\ \\textrm{mod}\\ \\phi(N)$即可解出$m\\equiv c^{d}\\ \\textrm{mod}\\ N$，编好程序运行时发现$e$在$\\phi(N)$下没有逆，这一下子就不知道怎么办了，其实这样的方程也是有办法求解的，[求解思路链接在此](https://chu-kangming.gitee.io/crypto/Elgamal-RSA-summary.html)\n\n解出的$m$虽然有多个，但是flag每个字符都是可见字符，这样最后只剩下一个$m$，这还不是flag；花括号内正好25个字符，encryption中正好25个数，按照一样的规则打乱花括号内的25个字符即得到真正的flag；\n\n### 解题\n\n上述GitHub备份链接中的solve.sage脚本为解题的sage脚本；\n\n程序运行结果如下：\n\n```Bash\n$ sage solve.sage\nflag{w5awd4fa994f87_dwad3123_2}\n```\n\n## elgamal_rsa\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/elgamal_rsa)\n\n### 分析\n\n$g^{q}\\equiv 1\\ \\textrm{mod}\\ p,h\\equiv g^{d}\\ \\textrm{mod}\\ p$\n\n$c_{1}\\equiv g^{r_{1}}\\ \\textrm{mod}\\ p,c_{2}\\equiv m\\cdot h^{r_{1}}\\ \\textrm{mod}\\ p$\n\n$c_{11}\\equiv g^{r_{2}}\\ \\textrm{mod}\\ p,c_{22}\\equiv m\\cdot h^{r_{2}}\\ \\textrm{mod}\\ p$\n\n其中，$r_{2}\\equiv (B\\cdot r_{1}+A)\\ \\textrm{mod}\\ q$\n\n这里的$m$就是$secret$，$secret$是下面“RSA”加密的模数，因此首先要解出$secret$，这也是很好解的；\n\n$c_{2}^{B}\\cdot h^{A}\\equiv (m\\cdot h^{r_{1}})^{B}\\cdot h^{A}\\equiv m^{B}\\cdot h^{B\\cdot r_{1}+A}\\equiv m^{B-1}\\cdot c_{22}\\ \\textrm{mod}\\ p$\n\n$m^{B-1}\\equiv c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1}\\ \\textrm{mod}\\ p$，计算$t\\equiv (B-1)^{-1}\\ \\textrm{mod}\\ (p-1)$\n\n那么$(c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1})^{t}\\equiv m\\ \\textrm{mod}\\ p$\n\n解出$secret$后，放到yafu里面分解(因子是真的多，一度怀疑自己解错了)，[求解flag的思路链接](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出secret；第二步，求解方程$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但是$(e,\\phi(N))>1$)；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n329380824451982777596468080979390700896875051159309053251427777390225223390054462862874890632092714850180031743329031313028975903871751004003831036860000454098274963081490031808010876171935539110201531253322208564941373067673598629247111527738724700328114569409692796434368030258427126193825227856160081569366870307559297674909108870298864572520476006338972072593434914773857347865349086098662711283463352902488164071184362082990162654586995346553108747183805073294471613391819978413596510467204977114038549473397779377039088475929677184284430986636686769839308217865627271293739711926018699557041530631349486791876338842184994986024157099233298972714917732995013317087756483\n```\n\n```Bash\n$ sage step2.sage\nyou_4re_good_at_b0th_el94mal_and_rs4\n```\n\n## babycrypto\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/babycrypto)\n\n### 分析\n\n在GF(p)上定义的点集$\\{(x,y)|x,y\\in GF(p)\\}$上定义加法\"+\"：$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}x_{2}-y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})$，定义乘法\"$\\cdot$\"：$k\\cdot (x,y)=(x,y)+\\cdots +(x,y)$\n\n给出基点g，$A=a\\cdot g,B=b\\cdot g$，给出A,B；\n\n$shared=b\\cdot A$，再利用shared生成AES密钥进行加密；\n\np未知！！！先介绍Edwards曲线E：$x^{2}+y^{2}\\equiv 1+dx^{2}y^{2}\\ \\textrm{mod}\\ p$，曲线上的加法定义为$(x_{1},y_{1})+(x_{2},y_{2})=((x_{1}y_{2}+x_{2}y_{1})/(1+dx_{1}x_{2}y_{1}y_{2}),(x_{1}x_{2}-y_{1}y_{2})/(1-dx_{1}x_{2}y_{1}y_{2}))$\n\n令d=0，则E：$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，则加法重写为$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}y_{2}+x_{2}y_{1},x_{1}x_{2}-y_{1}y_{2})$\n\n若我们设定d=0，那么$A(x_{1},y_{1}),B(x_{2},y_{2})$满足方程$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，求$x_{1}^{2}+y_{1}^{2}-1$与$x_{2}^{2}+y_{2}^{2}-1$的公约数，则p是其最大素因子；\n\n下面考虑如何解出b，这是一个离散对数问题，难点是sage并未实现Edwards曲线及其运算；\n\n给出一个有用的结论：$\\{(x,y)|x,y\\in GF(p),x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p\\}$与$H=F_{p}(w)/(w^{2}+1)$(有限域$F_{p}$上的多项式在模$w^{2}+1$下的剩余环)同构，同构映射$\\sigma :E\\rightarrow H$，$\\sigma((x,y))=x+yw$\n\n在sage中通过extend函数就可以生成H，从而可以求解此离散对数问题；\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出p；第二步，解出b然后以同样的方式生成AES密钥再对消息进行解密；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n435393448000740628395634230535241428961470055780764193459123534837759996\n```\n\n使用yafu分解，可得到p(在solve.sage中有给出)\n\n```Bash\n$ sage solve.sage\ngactf{354b6ce4c03387a828a3c30061213204}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-xor_game","url":"/crypto/xctf-XOR-GAME.html","content":"## 题目信息\n\n题目给出实现加密的程序，且指出明文是一首诗。\n\n## 分析\n\n先总结一下有用的信息：\n* 明文是有意义的英文，即明文均为可见字符且明文中的各字母出现的频率接近统计规律(在够长的一段话里，各个字母的占比大致稳定，并且这个稳定值已经用巨大的语料库统计出来了，这就是字母频率)\n\n* 密钥均为可见字符\n\n* 加密时对密钥进行了重用\n\n解决方案可分为程序分析与如果人工分析两部分；\n(1)程序分析：穷举密钥的长度，对每一长度的密钥，筛选密钥每一位可行的字符集合(要求此密钥位为可见字符，且那些被此密钥位解密出的明文位亦为可见字符)，如果密钥某一位可行的字符集合为空，则说明当前穷举的长度不是密钥的长度，这一步结束之后，可确定密钥的长度，以及密钥每一位可能的字符值；\n\n注：就实际情况来看，如果穷举的长度不是密钥的长度，几乎一定会有密钥某一位可行的字符集合为空。\n\n接下来，利用词频分析对密钥每一位进行爆破：对密钥的每一位，使用上一步得到的候选字符集中不同字符将解密出不同的明文，其中各字母出现的频率也不会相同，计算各字母出现的频率分布与统计规律的相似程度，选择相似程度最高的字符作为此密钥位。\n\n注：相似度计算公式：$score=\\sum_{i=1}^{26}p_{i}*q_{i}$，其中$p_{i}$是明文中第$i$个字母出现的频率，$q_{i}$是已统计出的第$i$个字母的频率。$q_{i}$的值见下面的程序。\n\n(2)人工分析：经过(1)，可猜对大部分密钥位，之后再结合解密出的明文对错误的密钥位进行修正。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.strxor import strxor\nfrom string import printable\nfrom base64 import b64decode\n\nfreq={'e':0.12702,'t':0.09056,'a':0.08167,'o':0.07507,\n        'i':0.06966,'n':0.06749,'s':0.06327,'h':0.06094,\n        'r':0.05987,'d':0.04253,'l':0.04025,'c':0.02782,\n        'u':0.02758,'m':0.02406,'w':0.02360,'f':0.02228,\n        'g':0.02015,'y':0.01974,'p':0.01929,'b':0.01492,\n        'v':0.00978,'k':0.00772,'j':0.00153,'x':0.00150,\n        'q':0.00095,'z':0.00074\n        }\n\ndef frequency(msg):\n    global freq\n    cnum=[len([s for s in msg if s==cc or s==cc.upper()]) for cc in freq.keys()]\n    csum=sum(cnum)\n    if csum==0:\n        return 0\n    return sum([x*y for x,y in zip(freq.values(),cnum)])/csum\n\ndef analysis(ks,cip):\n    lks=[len(sk) for sk in ks]\n    lc=len(cip)\n    step=len(lks)\n    key=[]\n    for ii,sk in enumerate(ks):\n        scores=[frequency(''.join([strxor(cip[ind],ik) for ind in range(ii,lc,step)])) for ik in sk]\n        key.append(sk[scores.index(max(scores))])\n    return key\n\ndef guessK(cip,low=4,high=33):\n    lc=len(cip)\n    for step in range(low,high):\n        ks=[]\n        for c1 in range(step):\n            optK=list(printable[:-6])\n            optK=[ik for ik in optK if ik not in \"{}'\\\"`^\"]\n            for ind in range(c1,lc,step):\n                tt=optK[:]\n                for ik in tt:\n                    if not strxor(cip[ind],ik) in printable:\n                        optK.remove(ik)\n            if len(optK)==0:\n                break\n            ks.append(optK[:])\n        if len(ks)<step:\n            continue\n        return analysis(ks,cip)\n\ndef enc(data, key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve():\n    with open('cipher.txt','r') as f:\n        cip=b64decode(f.read())\n    key=guessK(cip)\n    lc=len(cip)\n    lk=len(key)\n    while 1:\n        while 1:\n        print('\\033[1;31m'+''.join(key)+'\\033[0m')\n        msg=enc(cip,''.join(key))\n        out=['['+str(ii/lk)+']['+msg[ii:(ii+lk)]+']' for ii in range(0,lc-lk,lk)]\n        out.append('['+str(lc/lk)+']['+msg[-(lc%lk+lk):-(lc%lk)]+']')\n        if lc%lk:\n            out.append('['+str(lc/lk+1)+']['+msg[-(lc%lk):]+']')\n        print ''.join(out)\n        if raw_input('\\033[1;31m need correction(y) or not(n)\\033[0m')=='n':\n            break\n        row=int(raw_input('\\033[1;31m row \\033[0m'))\n        col=int(raw_input('\\033[1;31m col \\033[0m'))\n        cor=raw_input('\\033[1;31m correction \\033[0m')\n        key[col]=strxor(cip[row*lk+col],cor)\n    with open('msg','w') as f:\n        f.write(msg)\n    print('\\033[1;31m'+''.join(key)+'\\033[0m')\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```txt\n$ python solve.py\nxo7_is_,nte,estingn@f\n[0][\nL,fe, 1hin~and li(h1][1][-o#f ti(e a0d timeoa\"][2][ai+\nFri3olo+s tire#e6][3][s\n*ne\nIehea,d the *c-][4][o,efromethe~valley< $][5][ndethe -ear*\nOpen ;oe][6][th  lon ly -oul ofos,][7][ck)e ha7ves*ing\nRe?e$][8][t *utri\"htl', but .l6][9][o 7epea1 th; well--e,][10][ngeof\nE3ent+ally s8a<][11][in\" in 1he :esert  a6][12][isOI be)iev; I am\no7][13][n $s th  br7ght su\"m ][14][r #lowe7s\nD1 not w&t-][15][er d un!efe?ted fi*r<][16][ d mon 7uleTHeart =a1][17][e $nd b7eat6ing toob ][18][arethe )oad~of theoc0][19][mb rsom \nBo,ed\nTwoEIe][20][he$rd t-e m+sic, f=o(][21][ t-e mo*n a0d carc.s6][22][\nA0xili$ry ;xtremeoa ][23][st-etic,sm <ait tooc$][24][pt0re m,styTFillin( 1][25][heeinte+se 2ife, b:te][26][al6o fi)lin9 the p:r ][27][\nT-ere $re ?lways \"e(][28][or,es t-rou9hout t'ee][29][ea7th\nIebel7eve I .mO][30][Di d asethe~quiet -e$][31][ut< of $utu3n leav*sO][32][Sh ng i6 no* chaosc 6][33][mo.e ge6tur;\nEven 8i)][34][t $lso 7eta7ned bo!ee][35][pr*udlyeQin9 Feng \"u6][36][cl \nOcc0lt\n\nhree\nIoh ][37][arelovei I <elieveoi+][38][ l*ve\nL*ve 7s a po le][39][ofestru\"gli0g bluebg7][40][ee+ alg$e\nA- desol.t ][41][ m,cro-'urs* of wi!dO][42][Bl edin\" th,ough m6 3][43][ei+s\nYe$rs -tation*de][44][inethe 'eli;f\nFourEIe][45][be)ieveetha* all c.ne][46][he$r\nEv n a0ticipa;ee][47][di6cret , I~met th* *][48][th r th ir 1wn\nSom* &][49][anenot \"ras. the m m ][50][ntOLefteto *he Eas; 1][51][o \"o We6t, *he dea+ (][52][us1 noteret+rn to !o2][53][he7e\nSe , I~wear Z.ne][54][Fl*werseon 3y headc ,][55][n #ull 'loo3 alongot-][56][e 2ay a)l t6e way\n\tr ][57][qu ntlyemis-ed som*,e][58][bu1 als* de;ply mo9e!][59][ b< win!, f,ost, s!o2][60][ o7 rai+\nFi(e\nPraj!ae][61][Pa7amit$, s1on as <o*][62][n $s\nli#e b; beaut&f0][63][l )ike 6umm;r flow*r6][64][ a+d de$th 2ike au;u(][65][n )eave6\nAl-o careoa'][66][n )eave6\nAl-o careoa'][67][ou1 wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 2\ncorrection: i\nxor_is_,nte,estingn@f\n[0][\nLife, 1hin~and li(h1][1][-off ti(e a0d timeoa\"][2][ain\nFri3olo+s tire#e6][3][s\none\nIehea,d the *c-][4][o, fromethe~valley< $][5][nd the -ear*\nOpen ;oe][6][the lon ly -oul ofos,][7][ckle ha7ves*ing\nRe?e$][8][t outri\"htl', but .l6][9][o repea1 th; well--e,][10][ng of\nE3ent+ally s8a<][11][ing in 1he :esert  a6][12][is\nI be)iev; I am\no7][13][n as th  br7ght su\"m ][14][r flowe7s\nD1 not w&t-][15][ered un!efe?ted fi*r<][16][ demon 7uleTHeart =a1][17][e and b7eat6ing toob ][18][ar the )oad~of theoc0][19][mbersom \nBo,ed\nTwoEIe][20][heard t-e m+sic, f=o(][21][ the mo*n a0d carc.s6][22][\nAuxili$ry ;xtremeoa ][23][sthetic,sm <ait tooc$][24][pture m,styTFillin( 1][25][he inte+se 2ife, b:te][26][also fi)lin9 the p:r ][27][\nThere $re ?lways \"e(][28][ories t-rou9hout t'ee][29][earth\nIebel7eve I .mO][30][Died asethe~quiet -e$][31][uty of $utu3n leav*sO][32][Sheng i6 no* chaosc 6][33][moke ge6tur;\nEven 8i)][34][t also 7eta7ned bo!ee][35][proudlyeQin9 Feng \"u6][36][cle\nOcc0lt\n\nhree\nIoh ][37][ar lovei I <elieveoi+][38][ love\nL*ve 7s a po le][39][of stru\"gli0g bluebg7][40][een alg$e\nA- desol.t ][41][ micro-'urs* of wi!dO][42][Bleedin\" th,ough m6 3][43][eins\nYe$rs -tation*de][44][in the 'eli;f\nFourEIe][45][believeetha* all c.ne][46][hear\nEv n a0ticipa;ee][47][discret , I~met th* *][48][ther th ir 1wn\nSom* &][49][an not \"ras. the m m ][50][nt\nLefteto *he Eas; 1][51][o go We6t, *he dea+ (][52][ust noteret+rn to !o2][53][here\nSe , I~wear Z.ne][54][Flowerseon 3y headc ,][55][n full 'loo3 alongot-][56][e way a)l t6e way\n\tr ][57][quentlyemis-ed som*,e][58][but als* de;ply mo9e!][59][ by win!, f,ost, s!o2][60][ or rai+\nFi(e\nPraj!ae][61][Paramit$, s1on as <o*][62][n as\nli#e b; beaut&f0][63][l like 6umm;r flow*r6][64][ and de$th 2ike au;u(][65][n leave6\nAl-o careoa'][66][n leave6\nAl-o careoa'][67][out wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 7\ncorrection: t\nxor_is_inte,estingn@f\n[0][\nLife, thin~and li(h1][1][-off time a0d timeoa\"][2][ain\nFrivolo+s tire#e6][3][s\none\nI hea,d the *c-][4][o, from the~valley< $][5][nd the hear*\nOpen ;oe][6][the lonely -oul ofos,][7][ckle harves*ing\nRe?e$][8][t outrightl', but .l6][9][o repeat th; well--e,][10][ng of\nEvent+ally s8a<][11][ing in the :esert  a6][12][is\nI believ; I am\no7][13][n as the br7ght su\"m ][14][r flowers\nD1 not w&t-][15][ered undefe?ted fi*r<][16][ demon ruleTHeart =a1][17][e and breat6ing toob ][18][ar the load~of theoc0][19][mbersome\nBo,ed\nTwoEIe][20][heard the m+sic, f=o(][21][ the moon a0d carc.s6][22][\nAuxiliary ;xtremeoa ][23][stheticism <ait tooc$][24][pture mistyTFillin( 1][25][he intense 2ife, b:te][26][also fillin9 the p:r ][27][\nThere are ?lways \"e(][28][ories throu9hout t'ee][29][earth\nI bel7eve I .mO][30][Died as the~quiet -e$][31][uty of autu3n leav*sO][32][Sheng is no* chaosc 6][33][moke gestur;\nEven 8i)][34][t also reta7ned bo!ee][35][proudly Qin9 Feng \"u6][36][cle\nOccult\n```\n\n\n\n```txt\nhree\nIoh ][37][ar love, I <elieveoi+][38][ love\nLove 7s a po le][39][of struggli0g bluebg7][40][een algae\nA- desol.t ][41][ micro-burs* of wi!dO][42][Bleeding th,ough m6 3][43][eins\nYears -tation*de][44][in the beli;f\nFourEIe][45][believe tha* all c.ne][46][hear\nEven a0ticipa;ee][47][discrete, I~met th* *][48][ther their 1wn\nSom* &][49][an not gras. the m m ][50][nt\nLeft to *he Eas; 1][51][o go West, *he dea+ (][52][ust not ret+rn to !o2][53][here\nSee, I~wear Z.ne][54][Flowers on 3y headc ,][55][n full bloo3 alongot-][56][e way all t6e way\n\tr ][57][quently mis-ed som*,e][58][but also de;ply mo9e!][59][ by wind, f,ost, s!o2][60][ or rain\nFi(e\nPraj!ae][61][Paramita, s1on as <o*][62][n as\nlife b; beaut&f0][63][l like summ;r flow*r6][64][ and death 2ike au;u(][65][n leaves\nAl-o careoa'][66][n leaves\nAl-o careoa'][67][out what ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 11\ncorrection:  \nxor_is_interestingn@f\n[0][\nLife, thin and li(h1][1][-off time and timeoa\"][2][ain\nFrivolous tire#e6][3][s\none\nI heard the *c-][4][o, from the valley< $][5][nd the heart\nOpen ;oe][6][the lonely soul ofos,][7][ckle harvesting\nRe?e$][8][t outrightly, but .l6][9][o repeat the well--e,][10][ng of\nEventually s8a<][11][ing in the desert  a6][12][is\nI believe I am\no7][13][n as the bright su\"m ][14][r flowers\nDo not w&t-][15][ered undefeated fi*r<][16][ demon rule\nHeart =a1][17][e and breathing toob ][18][ar the load of theoc0][19][mbersome\nBored\nTwoEIe][20][heard the music, f=o(][21][ the moon and carc.s6][22][\nAuxiliary extremeoa ][23][stheticism bait tooc$][24][pture misty\nFillin( 1][25][he intense life, b:te][26][also filling the p:r ][27][\nThere are always \"e(][28][ories throughout t'ee][29][earth\nI believe I .mO][30][Died as the quiet -e$][31][uty of autumn leav*sO][32][Sheng is not chaosc 6][33][moke gesture\nEven 8i)][34][t also retained bo!ee][35][proudly Qing Feng \"u6][36][cle\nOccult\nThree\nIoh ][37][ar love, I believeoi+][38][ love\nLove is a po le][39][of struggling bluebg7][40][een algae\nAs desol.t ][41][ micro-burst of wi!dO][42][Bleeding through m6 3][43][eins\nYears station*de][44][in the belief\nFourEIe][45][believe that all c.ne][46][hear\nEven anticipa;ee][47][discrete, I met th* *][48][ther their own\nSom* &][49][an not grasp the m m ][50][nt\nLeft to the Eas; 1][51][o go West, the dea+ (][52][ust not return to !o2][53][here\nSee, I wear Z.ne][54][Flowers on my headc ,][55][n full bloom alongot-][56][e way all the way\n\tr ][57][quently missed som*,e][58][but also deeply mo9e!][59][ by wind, frost, s!o2][60][ or rain\nFive\nPraj!ae][61][Paramita, soon as <o*][62][n as\nlife be beaut&f0][63][l like summer flow*r6][64][ and death like au;u(][65][n leaves\nAlso careoa'][66][n leaves\nAlso careoa'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 18\ncorrection: g\nxor_is_interesting!@f\n[0][\nLife, thin and ligh1][1][-off time and time a\"][2][ain\nFrivolous tirele6][3][s\none\nI heard the ec-][4][o, from the valleys $][5][nd the heart\nOpen toe][6][the lonely soul of s,][7][ckle harvesting\nRepe$][8][t outrightly, but al6][9][o repeat the well-be,][10][ng of\nEventually swa<][11][ing in the desert oa6][12][is\nI believe I am\nBo7][13][n as the bright summ ][14][r flowers\nDo not wit-][15][ered undefeated fier<][16][ demon rule\nHeart ra1][17][e and breathing to b ][18][ar the load of the c0][19][mbersome\nBored\nTwo\nIe][20][heard the music, fro(][21][ the moon and carcas6][22][\nAuxiliary extreme a ][23][stheticism bait to c$][24][pture misty\nFilling 1][25][he intense life, bute][26][also filling the pur ][27][\nThere are always me(][28][ories throughout thee][29][earth\nI believe I amO][30][Died as the quiet be$][31][uty of autumn leavesO][32][Sheng is not chaos, 6][33][moke gesture\nEven wi)][34][t also retained bonee][35][proudly Qing Feng mu6][36][cle\nOccult\nThree\nI h ][37][ar love, I believe i+][38][ love\nLove is a poole][39][of struggling blue-g7][40][een algae\nAs desolat ][41][ micro-burst of windO][42][Bleeding through my 3][43][eins\nYears stationede][44][in the belief\nFour\nIe][45][believe that all cane][46][hear\nEven anticipatee][47][discrete, I met the *][48][ther their own\nSome &][49][an not grasp the mom ][50][nt\nLeft to the East 1][51][o go West, the dead (][52][ust not return to no2][53][here\nSee, I wear Zane][54][Flowers on my head, ,][55][n full bloom along t-][56][e way all the way\nFr ][57][quently missed some,e][58][but also deeply move!][59][ by wind, frost, sno2][60][ or rain\nFive\nPrajnae][61][Paramita, soon as so*][62][n as\nlife be beautif0][63][l like summer flower6][64][ and death like autu(][65][n leaves\nAlso care a'][66][n leaves\n```\n\n\n\n```txt\nAlso care a'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 20\ncorrection: t\nxor_is_interesting!@#\n[0][\nLife, thin and light][1][-off time and time ag][2][ain\nFrivolous tireles][3][s\none\nI heard the ech][4][o, from the valleys a][5][nd the heart\nOpen to ][6][the lonely soul of si][7][ckle harvesting\nRepea][8][t outrightly, but als][9][o repeat the well-bei][10][ng of\nEventually sway][11][ing in the desert oas][12][is\nI believe I am\nBor][13][n as the bright summe][14][r flowers\nDo not with][15][ered undefeated fiery][16][ demon rule\nHeart rat][17][e and breathing to be][18][ar the load of the cu][19][mbersome\nBored\nTwo\nI ][20][heard the music, from][21][ the moon and carcass][22][\nAuxiliary extreme ae][23][stheticism bait to ca][24][pture misty\nFilling t][25][he intense life, but ][26][also filling the pure][27][\nThere are always mem][28][ories throughout the ][29][earth\nI believe I am\n][30][Died as the quiet bea][31][uty of autumn leaves\n][32][Sheng is not chaos, s][33][moke gesture\nEven wil][34][t also retained bone ][35][proudly Qing Feng mus][36][cle\nOccult\nThree\nI he][37][ar love, I believe in][38][ love\nLove is a pool ][39][of struggling blue-gr][40][een algae\nAs desolate][41][ micro-burst of wind\n][42][Bleeding through my v][43][eins\nYears stationed ][44][in the belief\nFour\nI ][45][believe that all can ][46][hear\nEven anticipate ][47][discrete, I met the o][48][ther their own\nSome c][49][an not grasp the mome][50][nt\nLeft to the East t][51][o go West, the dead m][52][ust not return to now][53][here\nSee, I wear Zan ][54][Flowers on my head, i][55][n full bloom along th][56][e way all the way\nFre][57][quently missed some, ][58][but also deeply moved][59][ by wind, frost, snow][60][ or rain\nFive\nPrajna ][61][Paramita, soon as soo][62][n as\nlife be beautifu][63][l like summer flowers][64][ and death like autum][65][n leaves\nAlso care ab][66][n leaves\nAlso care ab][67][out what has]\nneed correction(y) or not(n)n\nxor_is_interesting!@#\n```\n\n","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-equation-2","url":"/crypto/xctf-Equation-2.html","content":"## 题目信息\n\n题目描述“RSA私钥上面的部分被屏蔽了请恢复私钥并解密文件”，附件给出私钥编码的截图，但是只能看见最后5行。\n\n## 分析\n\n### OpenSSL私钥结构\n\n私钥信息按如下顺序排列：\nversion | pad | n | pad | e | pad | d | pad | p | pad | q | pad | x1 | pad | x2 | pad | x3\n其中，pad是填充信息，各pad并不同，$x_{1}= d\\ \\textrm{mod}\\ (p-1),x_{2}= d\\ \\textrm{mod}\\ (q-1),x_{3}=p^{-1}\\ \\textrm{mod}\\ q$，填充pad用来注释接下来的大数的(字节)长度，\\x02为pad开头的标记，有时后面接\\x81或\\x82，这用来标记长度值所占用的字节(\\x81代表占用1个字节，\\x82代表占用2个字节)，有时后面不接\\x81或\\x82而直接放置长度；\n例：\\x02\\x03代表接下来的大数的字节长度为3个字节；\\x02\\x81\\x80，首先，\\x81代表长度占用1个字节，因此\\x80就是长度值，即128，表明接下来的大数的字节长度为128个字节。\n\n将私钥信息按照上述顺序排列好之后，再进行base64编码。\n\n### 利用已知信息恢复私钥\n\n截图可见编码为\n```Bash\nOs9mhOQRdqW2cwVrnNI72DLcAXpXUJ1HGwJBANWiJcDUGxZpnERxVw7s0913WXNtV4GqdxCzG0pG5EHThtoTRbyX0aqRP4U/hQ9tRoSoDmBn+3HPITsnbCy67VkCQBM4xZPTtUKM6Xi+16VTUnFVs9E4rqwIQCDAxn9UuVMBXlX2Cl0xOGUF4C5hItrX2woF7LVS5EizR63CyRcPovMCQQDVyNbcWD7N88MhZjujKuSrHJot7WcCaRmTGEIJ6TkU8NWt9BVjR4jVkZ2EqNd0KZWdQPukeynPcLlDEkIXyaQx\n```\n\n解码后结合OpenSSL私钥结构分析可得：x1,x2,x3为已知；但是仅有x1,x2,x3并不能恢复出p,q与d，若我们假设e为常用的指数3,65537等等，则可试出p与q：\n\n$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)(q-1)$\n则有$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$与$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n由$x_{1}$与$x_{2}$的定义可得$x_{1}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$，$x_{2}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n因此$(p-1)|(x_{1}\\cdot e-1)$；\n记$x_{1}\\cdot e-1=r_{1}\\cdot (p-1)$；\n由于$x_{1}= d\\ \\textrm{mod}\\ (p-1)$，则$x_{1}<(p-1)$；\n几乎可以看做$x_{1}\\cdot e=r_{1}\\cdot (p-1)$，那么必有$r_{1}<e$；\n同理可得$r_{2}<e$，其中$x_{2}\\cdot e-1=r_{2}\\cdot (q-1)$\n可以看到，$r_{i}<e,i=1,2$，从而可使用试除法求出$r_{i},i=1,2$；\n则$p=(x_{1}\\cdot e-1)/r_{1}+1,q=(x_{2}\\cdot e-1)/r_{2}+1$；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,isPrime,inverse\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\ndef genKey(X1,X2,X3):\n    e=65537L\n    N1=X1*e-1\n    N2=X2*e-1\n    for r in range(e):\n        if N1%(e-r)==0:\n            p=N1/(e-r)+1\n            if isPrime(p):\n                break\n    for r in range(e):\n        if N2%(e-r)==0:\n            q=N2/(e-r)+1\n            if isPrime(q):\n                break\n    N=p*q\n    phi=(p-1)*(q-1)\n    d=inverse(e,phi)\n    assert inverse(q,p)==X3\n    return RSA.construct((N,e,long(d),p,q))\n\ndef solve():\n    X1=bytes_to_long('\\xd5\\xa2%\\xc0\\xd4\\x1b\\x16i\\x9cDqW\\x0e\\xec\\xd3\\xddwYsmW\\x81\\xaaw\\x10\\xb3\\x1bJF\\xe4A\\xd3\\x86\\xda\\x13E\\xbc\\x97\\xd1\\xaa\\x91?\\x85?\\x85\\x0fmF\\x84\\xa8\\x0e`g\\xfbq\\xcf!;\\'l,\\xba\\xedY')\n    X2=bytes_to_long('\\x138\\xc5\\x93\\xd3\\xb5B\\x8c\\xe9x\\xbe\\xd7\\xa5SRqU\\xb3\\xd18\\xae\\xac\\x08@ \\xc0\\xc6\\x7fT\\xb9S\\x01^U\\xf6\\n]18e\\x05\\xe0.a\"\\xda\\xd7\\xdb\\n\\x05\\xec\\xb5R\\xe4H\\xb3G\\xad\\xc2\\xc9\\x17\\x0f\\xa2\\xf3')\n    X3=bytes_to_long('\\xd5\\xc8\\xd6\\xdcX>\\xcd\\xf3\\xc3!f;\\xa3*\\xe4\\xab\\x1c\\x9a-\\xedg\\x02i\\x19\\x93\\x18B\\t\\xe99\\x14\\xf0\\xd5\\xad\\xf4\\x15cG\\x88\\xd5\\x91\\x9d\\x84\\xa8\\xd7t)\\x95\\x9d@\\xfb\\xa4{)\\xcfp\\xb9C\\x12B\\x17\\xc9\\xa41')\n    rsa_key=genKey(X1,X2,X3)\n    key= PKCS1_v1_5.new(rsa_key)\n    with open('flag.enc','rb') as f:\n        return key.decrypt(f.read(),'')\n\nif __name__=='__main__':\n    print solve()[:-1]\n```\n\n注：这里之所以猜测e为65537而不是3是因为$r_{i}<e,i=1,2$，如果e=3可能情况太少。\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n0ctf{Keep_ca1m_and_s01ve_the_RSA_Eeeequati0n!!!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-SM","url":"/crypto/xctf-SM.html","content":"## 题目信息\n\n附件中包含一个Python脚本sm.py，3个文本文件。\n\n## 分析\n\n读完一遍sm.py后，可以确定解题的思路是先由ps与r解出bchoose，再由bchoose按照同样的过程计算出密钥key，最后进行AES解密求出flag。首先看生成r的代码：\n\n```Python\nr=0\nfor i in range(512):\n    if bchoose[i]=='1':\n        r=r^ps[i]\n```\n\n即$r=\\sum_{i=1}^{512}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$(此处的加法是异或)；虽然生成方式类似背包加密，但是由于ps具有很好的性质，我们不使用破解背包加密的方法来解此题；我们来分析生成ps的gen512num函数：\n\n```Python\ndef gen512num():\n    order=[]\n    while len(order)!=512:\n        tmp=randint(1,512)\n        if tmp not in order:\n            order.append(tmp)\n    ps=[]\n    for i in range(512):\n        p=getPrime(512-order[i]+10)\n        pre=bin(p)[2:][0:(512-order[i])]+\"1\"\n        ps.append(int(pre+\"0\"*(512-len(pre)),2))\n    return ps\n```\n\norder是1,2,...,512的一个随机的排列，对ps[i]:首先生成一个长度为512-order[i]+10的素数，去掉此素数的最后10位，同时在尾部追加一个二进制位1，最后在后面填充0使得长度为512；我们首先考虑生成r的最后1个二进制位，ps中只有1个数最后1位为1，其余数最后1位均为0，那么最后1位为1的数如果没有“加入”异或运算，那么r的最后1位一定为0，否则，一定为1，这样我们通过r的最后1位就可以推断出bchoose的第j位(记order[j]=1)。接下来，$r\\oplus (\\textrm{bchoose[j]}\\cdot \\textrm{ps[j]})=\\sum_{i\\neq j}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$，在{ps[i]| i$\\neq$j}中，只有1个数倒数第2位为1，同理，可推断出bchoose的第k位(记order[k]=2)，直到推断出bchoose所有位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\n\ndef cal_k():\n    with open('ps','r') as f:\n        ps=[long(x) for x in f.read().split('\\n')[:-1]]\n    with open('r','r') as f:\n        r=long(f.read())\n    pbits=[bin(x).rfind('1')-2 for x in ps]\n    bc=['0']*512\n    for le in range(512):\n        ind=pbits.index(511-le)\n        tt=bin(r)[2:].rjust(512,'0')[511-le]\n        if tt=='1':\n            bc[ind]='1'\n            r^=ps[ind]\n    return long(''.join(bc),2)\n\ndef solve():\n    with open('ef','rb') as f:\n        ef=b64decode(f.read())\n    key=long_to_bytes(int(md5(long_to_bytes(cal_k())).hexdigest(),16))\n    aes_obj = AES.new(key, AES.MODE_ECB)\n    return aes_obj.decrypt(ef)\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{shemir_alotof_in_wctf_fun!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decode_The_File","url":"/crypto/xctf-DECODE-THE-FILE.html","content":"## 题目信息\n\n附件是一个文本文件，里面有658行base64编码。\n\n## 分析\n\n先将附件中每行base64编码进行解码，得到一个Python脚本。但其实信息并非隐藏在解码后的数据中，而是隐藏在编码中。首先介绍[base64编码的原理](https://chu-kangming.gitee.io//tech/B32-64-encode-explanation.html)，当需要编码的数据剩下1或2字节时，编码与解码过程如下：\n{% asset_img 1.png pic1 %}\n\n\n可以看到，即使$a_{i} \\neq 0$，解码过程也能正确进行；从而可以使用$a_{i}$传递一些信息。因此，只要我们将编码中的$a_{i}$提取出来，就可以解出flag。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom string import uppercase,lowercase,digits\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('encode','r') as f:\n        codes=f.read()\n    Lc=codes.split('\\n')[:-1]\n    base=uppercase+lowercase+digits+'+/'\n    re2=[]\n    for code in Lc:\n        if '==' in code:\n            re2.append(bin(base.find(code[-3]))[2:].rjust(6,'0')[2:])\n        elif '=' in code:\n            re2.append(bin(base.find(code[-2]))[2:].rjust(6,'0')[4:])\n    ret=''.join(re2)\n    return long_to_bytes(long(ret[:ret.rfind('1')+1],2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nROIS{base_GA_caN_b3_d1ffeR3nT}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-简单流量分析","url":"/crypto/xctf-Simple-Traffic-Analysis.html","content":"## 题目信息\n\n题目背景：运维人员在日常安全检查的时候发现现场某设备会不时向某不知名ip发出非正常的ICMP PING包。这引起了运维人员的注意，他在过滤出ICMP包分析并马上开始做应急处理很可能已被攻击的设备，附件给出可疑流量包。\n\n## 分析\n\n流量分析题，分析的方法基本上有：binwalk、查找一些可疑字符串或16进制数据，排序流量包的长度(最长的流量包一般很可疑)；当我们对流量包的长度进行排序时，发现流量包最短90字节，最长也不过164字节，其中的data段数据长度从48到122，而ascii表中第48至122个字符为0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz，于是将每个流量包的长度转换为对应字符，然后连接成一段长字符串，看上去像base64编码，对字符串进行base64解码即可!\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom pyshark.capture.file_capture import FileCapture\nfrom base64 import b64decode\nfrom sys import argv\n\ndef solve(file_name):\n    packets=FileCapture(input_file=file_name)\n    res=''\n    for packet in packets:\n        for pkt in packet:\n            if pkt.layer_name=='icmp' and int(pkt.type,16):\n                res+=chr(int(pkt.data_len))\n    return b64decode(res)\n\nif __name__=='__main__':\n    print solve(argv[1])\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py fetus_pcap.pcap\n::\\nmongodb:!:17843:0:99999:7:::\\nubuntu:$6$LhHRomTE$M7C4n84UcFLAG{xx2b8a_6mm64c_fsociety}::\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-shanghai","url":"/crypto/xctf-Shanghai.html","content":"## 题目信息\n\n题目给出提示“维吉利亚密码”，密文在附件中。\n\n## 分析\n\n由于维吉利亚密码加密时密钥重用，导致可通过分析密文进行破解；由于明文中存在一些出现频率很高的单词：the,and,for,with等等，因此很有可能这些单词再次被同样的密钥加密，从而生成同样的密文，其间隔一定是密钥长度的倍数，因此可通过对密文进行分析得到密钥的长度；另外，由于这些密文对应着那些出现频率高的明文，因此可破解出密钥；自己写了一个[工具](https://gitee.com/chu-kangming/CTFs-Crypto/tree/tool/TRA/Virginia-analysis)来求解这类问题。\n\n## 解题\n\n如下是我使用工具的解题过程，注释是我自己加的，并非程序的输出\n```Bash\n$ python solve.py shanghai.txt\n# 先寻找密文中多次出现(本程序设定的至少3次)的词汇，并计算它们之间的距离，这有助于分析出密钥的长度\nword:  bju\ndistance:  [1078, 2222, 154, 814, 132, 264]\nthe minimum distance:  132\n\nword:  glv\ndistance:  [660, 408, 186, 374, 88, 66, 836, 44, 649, 110, 880, 88, 209, 66]\nthe minimum distance:  44\n\nword:  vxz\ndistance:  [1936, 154, 264, 253, 121, 517, 154, 440, 11, 220, 66]\nthe minimum distance:  11\n\nword:  bni\ndistance:  [22, 979, 2002, 583, 165, 132, 22]\nthe minimum distance:  22\n\nword:  xpg\ndistance:  [11, 396, 660, 2409, 11, 374, 37, 51, 572]\nthe minimum distance:  11\n\nword:  jcm\ndistance:  [1595, 88, 99, 297, 781, 11, 22, 110, 66, 231, 627]\nthe minimum distance:  11\n\nword:  zlr\ndistance:  [286, 583, 583, 154, 22, 154, 22, 407, 55, 396, 1155]\nthe minimum distance:  22\n\nword:  klm\ndistance:  [594, 308, 605, 2145, 231, 297, 44, 44, 198]\nthe minimum distance:  44\n\nword:  mfr\ndistance:  [44, 99, 99, 715, 1884, 536]\nthe minimum distance:  44\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  tyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  yiz\ndistance:  [165, 968, 550, 275, 220, 2167, 246, 106]\nthe minimum distance:  106\n\nword:  opk\ndistance:  [66, 1342, 385, 11, 1771, 583, 374]\nthe minimum distance:  11\n\nword:  tyi\ndistance:  [165, 968, 488, 62, 275, 220, 37, 1639, 491, 352]\nthe minimum distance:  37\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  pkv\ndistance:  [297, 33, 407, 1221, 572, 88]\nthe minimum distance:  33\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  xui\ndistance:  [638, 682, 77, 154, 55, 649, 363, 143]\nthe minimum distance:  55\n\nword:  tui\ndistance:  [55, 1628, 154, 286, 787, 797]\nthe minimum distance:  55\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n#到此我们应该也能看出，密钥的长度为11\n#接下来，进行已知明文攻击\n```\n```Bash\n#密文中有一段：frxnimp 1914 qil 1940，猜测是between 1914 and 1940\nplaintext:betweenand\ncipher:frxnimpqil\npossible key:enereicqvi len:10\n#如果需要更多的明-密文对分析，则输入y；否则，已计算出密钥，则可以进行解密你需要解密的内容\ntry more plain-cipher(y) or start decrypt(n)y\nplaintext:the\ncipher:opk\npossible key:vig len:3\ntry more plain-cipher(y) or start decrypt(n)n\nkey:enereicqvig\ncipher:jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}'\nfgyf, '{' rnh 'jacpnzpdzszsjupanwglh' ebv '}'\ndpps, '{' erb 'xfpnligqmwtgohnywntyl' ypa '}'\nbnyj, '{' ref 'rtuajgphzjxacmawuwkly' cjo '}'\nolws, '{' irs 'vnifwenqqwkewafjsutcl' pni '}'\ntyuq, '{' rif 'irctbrloznxrautofsrlc' cam '}'\nhdho, '{' prw 'vegnpwymxwoenynckfpjl' tnz '}'\nbrmb, '{' npf 'mrtrjkdzvuxvalrwykchj' cem '}'\nflag, '{' and 'vigenereisveryeasyhuh' and '}'\nspuu, '{' fab 'trxrailsnftcaprnwsvzu' ylm '}'\nfcyo, '{' tfo 'rpginvpmbkgayyiajwpnz' ljk '}'\nwpls, '{' ntt 'enereicqvylnwwrrwjthn' qwi '}'\n```\n\n解出flag为flag{vigenereisveryeasyhuh}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-OldDriver","url":"/crypto/xctf-OldDriver.html","content":"## 题目信息\n\n附件是一份密文，其中包含10组RSA密钥-密文对。\n\n## 分析\n\nRSA秘钥的指数e=10，这些特征暗示低加密指数广播攻击；当加密一份消息给多人时，$c_{i}=m^{e} \\ \\textrm{mod}\\ N_{i},i=1,\\cdots,k$，当$k \\geq e$时，可由中国剩余定理求解$m^{e}$，再开方即得明文$m$。\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import mpz,iroot\n\ncip_keys=[\n{\"c\": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, \"e\": 10, \"n\": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803},\n{\"c\": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, \"e\": 10, \"n\": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193},\n{\"c\": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, \"e\": 10, \"n\": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623},\n{\"c\": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, \"e\": 10, \"n\": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723},\n{\"c\": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, \"e\": 10, \"n\": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493},\n{\"c\": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, \"e\": 10, \"n\": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949},\n{\"c\": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, \"e\": 10, \"n\": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043},\n{\"c\": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, \"e\": 10, \"n\": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047},\n{\"c\": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, \"e\": 10, \"n\": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553},\n{\"c\": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, \"e\": 10, \"n\": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}\n]\n\ncips=[]\nkeys=[]\n\nfor cip_key in cip_keys:\n\tcips.append(cip_key['c'])\n\tkeys.append(cip_key['n'])\n\nsol=crt(cips,keys)\nmsg,flag=iroot(mpz(str(sol)),mpz(str(10)))\nprint msg\nprint flag\nprint long_to_bytes(long(msg))\n```\n\n程序运行效果如下：\n\n```Bash\n$ sage wp.sage\n854589733786598088127099154138504953368140761371523704656865879247874533963639770706597129057405\nTrue\nflag{wo0_th3_tr4in_i5_leav1ng_g3t_on_it}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decrypt-the-Message","url":"/crypto/xctf-Decrypt-the-Message.html","content":"## 题目信息\n\n题目要求我们解密附件中的信息；打开附件，里面是一首诗，最后给出需要解密的信息。\n\n## 分析\n\n此题考察[Poem加密](http://wmbriggs.com/post/1001/)；举例说明加密过程。\n诗：for my purpose holds to sail beyond the sunset, and the baths of all the western stars until I die.\n明文：We have run out of cigars, situation desperate.\n从诗中选择5个词for,sail,all,stars,die，将这些词中的每个字母排序(相同的不合并)，即：\n```Bash\n f  o  r  s  a  i  l  a  l  l  s  t  a  r  s  d  i  e\n 6 12 13 15  1  7  9  2 10 11 16 18  3 14 17  4  8  5\n```\n上表共有18个字母，将明文以18个字母一组分成若干行，最后一行未满之处用a,b,...进行填充，即\n```Bash\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n w e h a v e r u n o  u  t  o  f  c  i  g  a\n r s s i t u a t i o  n  d  e  s  p  e  r  a\n t e a b c d e f g h  i  j  k  l  m  n  o  p\n```\n\n再根据第一个表将各列置换，即eud tdj ...，最后连接起来生成密文。\n\n破解的思路就是从诗中穷举各种取词情况，然后进行解密，然后选择可读的“明文”，已有人写好破解的[工具](https://github.com/abpolym/crypto-tools/tree/master/poemcode)\n\n## 解题\n\n将诗与密文分别存为poem.txt，cip.txt并移到与poemcode.py同目录下，使用工具破解：\n\n```Bash\n$ python poemcode.py poem.txt cip.txt\n...\nifytuothikcrnyptorapyisheansnweroyoturprbletheyoulodnotnowkwhatourrobemiuasbcdfgheijklnoprst\nifyouthinkcryptographyistheanswertoyourproblemthenyoudonotknowwhatyourproblemisabcdefghijklmnopqrstu\npakprictiyorhftyselorohyphurbeewterunhwooaywtooonrbpofjhsgkeilncmbrt\n...\n```\n中间的为明文。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析1","url":"/crypto/xctf-Industrial-Protocol-Analysis-1.html","content":"## 题目信息\n\n工业网络中存在异常，尝试通过分析PCAP流量包，分析出流量数据中的异常点，并拿到FLAG。flag形式为 flag{}，流量包在附件。\n\n## 分析\n\n将流量包的长度排序(由大到小)，第一个流量包的长度为10120，比第二长的流量包超过太多，猜测有问题；一段乱码之后，data=\"data:image/png;base64,后面是一段很长的base64编码。\n\n## 解题\n\n先将流量包中的base64编码复制到文本文件data.txt中，再进行解码，最后将解码的数据写入png文件，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\n\nwith open('data.txt','r') as f:\n    da=f.read()\n\ndata=b64decode(da)\n\nwith open('flag.png','w') as g:\n    g.write(data)\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-fanfie","url":"/crypto/xctf-fanfile.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一段长34的字符串。\n\n## 分析\n\n文本中的字符串看上去像base32编码，加填充后解码得乱码；很多时候比赛的名称是解密的谜面，对字符串BITSCTF进行base32编码得字符串IJEVIU2DKRDA====，与文本中的字符串MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI进行对比，发现字符I两次对应M，猜测是移位密码或仿射密码，加密运算的有限集为{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,2,3,4,5,6,7}，不理解的可以参见[对base编码的介绍](https://www.cnblogs.com/coming1890/p/13503574.html),尝试之后得加密方式为仿射密码，求得解密式为$x=5y+12\\ \\textrm{mod}\\ 32$。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b32decode\n\ndef solve():\n    s='MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'\n    dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n    msg=''.join([dic[(5*dic.find(x)+12)%32] for x in s])\n    return b32decode(msg+'='*(8-len(msg)%8))\n\nif __name__=='__main__':\n    #python solve.py\n    print solve()\n```\n\n运行程序得如下结果：\n```Bash\n$ python solve.py\nBITSCTF{S2VyY2tob2Zm}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-ecb,_it’s_easy_as_123","url":"/crypto/xctf-ECB-it-is-easy-as-123.html","content":"## 题目信息\n\n附件提供了背景介绍(Somebody leaked a still from the upcoming Happy Feet Three movie, which will be released in 4K, but Warner Bros. was smart enough to encrypt it. But those idiots used a black and white bmp format, and that wasn't their biggest mistake. Show 'em who's boss and get the flag.)，与一个bmp文件。\n\n## 分析\n\n根据背景介绍，原图片应该是bmp格式，经ecb工作模式加密得ecb.bmp；由于ecb工作模式不会掩盖明文的统计规律，因此只要能够修复ecb.bmp就可以见到明文，要修复ecb.bmp，则要求文件的前128字节为bmp文件格式特有的字节。\n\n## 解题\n\n将ecb.bmp的前128字节替换为bmp文件格式特有的字节，则可以见到明文信息，实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\nwith open('ecb.bmp','rb') as f:\n    data=f.read()\npre=0x424d76483f00000000007600000028000000000f000070080000010004000000000000483f00000000000000000000000000000000000000000000008000008000000080800080000000800080008080000080808000c0c0c0000000ff0000ff000000ffff00ff000000ff00ff00ffff0000ffffff00ffffffffffffffffffffL\nout=long_to_bytes(pre)+data[128:]\n\nwith open('out.bmp','wb') as g:\n    g.write(out)\n```\n\nout.bmp可被照片查看器打开，从而见到flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-safer-than-rot13","url":"/crypto/xctf-Safer-Than-Rot13.html","content":"## 题目信息\n\n附件是一个文本文件，题目名称safer-than-rot13。\n\n## 分析\n\n由题目名称safer-than-rot13，先对密文进行rot13置换；依然看不出任何逻辑，再进行词频分析,找到flag。\n\n## 解题\n\n对密文进行rot13置换：\n\n```Bash\ncat cry100 | tr A-Za-z N-ZA-Mn-za-m > dec100\n```\n\n再进行[词频分析](https://quipqiup.com/)，找到flag为NO THIS IS NOT CRYPTO MY DEAR。","tags":["xctf"],"categories":["crypto"]},{"title":"ctf密码学常用python库","url":"/crypto/CTF-cryptography-uses-Python-libraries.html","content":"## pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n这个库是实现各种算法和协议的密码模块的集合，包含Cipher，Hash，Protocol，PublicKey，Signature，Util这些子包；\n\n### Cipher子包\n\n实现了分组加密(AES，DES，DES3，CAST，Blowfish，RC2)，流加密(RC4，XOR)与公钥加密(RSA PKCS#1与PKCS#1 OAEP，这两个区别在于加密前对数据的填充不同)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nkey = b'Sixteen byte key'\niv = Random.new().read(AES.block_size)\ncipher = AES.new(key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\nprint msg.encode('hex')\n```\n\n有时在解RSA的题时，已经知道了密钥，解出来的flag却是乱码，也许是加了一些填充如OAEP，PKCS#1导致的；这时就需要使用对应的秘钥解密；如下是一个PKCS#1填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度-11\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom gmpy2 import invert\nfrom base64 import b64decode\n\ncip='bT633yPu4dOHEL66eKCHjg6cZb09CElt2mSSQZkRDHk='\n\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461L\ne=65537L\n#http://factordb.com/\np=275127860351348928173285174381581152299L\nq=319576316814478949870590164193048041239L\nphi=(p-1)*(q-1)\nd=invert(e,phi)\n\nprivkey=RSA.construct((n,e,long(d),p,q))\n\n#原生RSA\nprint privkey.decrypt(b64decode(cip))\n\n#PKCS#1填充\nkey= PKCS1_v1_5.new(privkey)\nprint key.decrypt(b64decode(cip),'')\n```\n\n再举个OAEP填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度减去41；你可以试一下在下面代码中的明文中多加一个字符运行就会报错。\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom base64 import b64encode,b64decode\n\nrsa_key=RSA.generate(1024)\nkey=PKCS1_OAEP.new(rsa_key)\ncip=b64encode(key.encrypt('PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}abcdef'))\nprint cip\n\nmsg=key.decrypt(b64decode(cip))\nprint msg\n```\n\n### Hash子包\n\n实现了哈希算法(MD2，MD4，MD5，RIPEMD，SHA，SHA224，SHA256，SHA384，SHA512，HMAC，hashalgo)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Hash import MD2\nh = MD2.new()\nh.update(b'Hello')\nprint h.hexdigest()\n```\n\n但是没有实现SHA1，要使用SHA1，需要导入hashlib库，正好验证一下Google之前给出的求得两个 sha1 值一样的pdf对：https://shattered.io/\n\n```Python\nfrom hashlib import sha1\n\nwith open('shattered-1.pdf','rb') as f1:\n    da1=f1.read()\nwith open('shattered-2.pdf','rb') as f2:\n    da2=f2.read()\n\nprint sha1(da1).hexdigest()\nprint sha1(da2).hexdigest()\n```\n\n### PublicKey子包\n\n实现了公钥加密和签名算法(RSA，DSA，ElGamal)；文档给出的例子：\n\n```Python\nfrom Crypto.PublicKey import RSA\nkey0 = RSA.generate(2048)\nwith open('mykey.pem','w') as f:\n    f.write(key0.exportKey('PEM'))\n\nwith open('mykey.pem','r') as g:\n    key = RSA.importKey(g.read())\n```\n\n### Util子包\n\n实现了各种有用的模块和功能(Util.number：数论函数，Util.randpool：随机数生成，Util.RFC1751：在128位键和可读的字串之间进行转换，Util.asn1：对ASN.1 DER编码的最小支持)；自己写个例子如下：\n\n```Python\nfrom Crypto.Util import number\ns='this is a demo'\n#字节转换为long型整数\nls=number.bytes_to_long(s)\n\nbits=8*len(s)\n#生成长度为bits的素数\ngp=number.getPrime(bits)\n\n#生成长度小于bits的随机数\ngri=number.getRandomInteger(bits)\n \n#生成长度为bits的随机数\ngrnbi=number.getRandomNBitInteger(bits)\n\n#生成长度不超过bits的随机数\ngrn=number.getRandomNumber(bits)\n \n#生成grn与2*grn之间的随机数\ngrr=number.getRandomRange(grn,2*grn)\n\n#生成强的素数（gsp-1，gsp+1均至少具有一个大的素因子）\ngsp=number.getStrongPrime(1024)\n\n#计算gri在模grn下的逆\niin=number.inverse(gri,grn)\n\n#判断iin是否为素数\nip=number.isPrime(iin)\n\n#long型整数转换为字节\ntb=number.long_to_bytes(ls)\n```\n\n由于这个库很多函数都很有用，因此我们直接使用\n```Python\nfrom Crypto.Util.number import *\n```\n来导入这个包的所有函数。\n\n## pwntools库\n\n```Bash\npip3 install pwntools -i https://pypi.douban.com/simple\n```\n\n这个库内容很多，只介绍比赛中用到的。\n\n### mbruteforce函数\n\n多线程穷举函数，详细定义如下：mbruteforce(func, alphabet, length, method='upto', start=None, threads=None)，其中，\n* func输入参数为字符串，输出布尔值，mbruteforce穷举直到func输出True；\n* alphabet为组成输入参数字符串的字符集合；\n* length指定输入参数字符串的长度上界；\n* method默认为'upto'，指定穷举的字符串长度从1增大到length；另外两个选项为'fixed'、'downfrom'，fixed'指定穷举的字符串长度仅为ength，'downfrom'指定穷举的字符串长度从length减小到1；\n* start=(N,i)，就是把搜索空间分成N块从第i块开始穷举；默认为(1,1)\n* threads指定穷举时的线程数，默认值是内核的数量；\n\n举个例子：\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\nmbruteforce(lambda x: x == 'hello','helo',5,method='fixed')\n```\n\n### remote类\n\n用来与服务器交互；常用函数的用法注释到如下脚本中。\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\n\n#创建到远程主机的TCP或udp连接，主机为cn.bing.com，连接主机的端口为443\n#ssl=True代表用SSL包装套接字\nr=remote('cn.bing.com',443,ssl=True)\n\n#向主机发送数据，只不过数据只能是一行\nr.sendline('GET /')\n\n#向主机发送数据，数据可以是多行\nr.send(b'\\r\\n\\r\\n')\n\n##上面两行代码等价于r.send(b'GET /\\r\\n\\r\\n')\n\n#从主机接收4个字节的数据\nre=r.recvn(4)\nprint re\n\n#从主机一直接收数据直到'Please'出现\nre=r.recvuntil('Please')\nprint re\n\n#从主机一直接收数据，最多接收4096字节\nre=r.recv()\nprint re\n\n#关闭连接\nr.close()\n```","tags":["ctf","python"],"categories":["crypto"]},{"title":"RSA攻击大全及其实现","url":"/crypto/RSA-attack-Daquo-and-its-implementation.html","content":"## RSA攻击大全\n\n### 模数分解\n\n* Small q：模数N有小素数因子；\n* fermat：模数N的因子p与q非常接近；\n* 模不互素：给出多组公钥，但是其中的模数共用了素因子；\n\n### 针对指数进行攻击\n\n* 小公钥指数攻击：指数很小；\n* 低加密指数广播攻击：相同的消息发送给多个接收者，且加密指数较低；\n\n### 针对私钥进行攻击\n\n* 维纳攻击：指数很大(理论上$d<N^{0.25}$此攻击起作用)；\n* Boneh-Durfee攻击：同样针对指数很大的情形，理论上$d<N^{0.29}$此攻击起作用；\n\n### Coppersmith相关攻击\n\nCoppersmith算法用于求解模$N$多项式$F(X)$($X$为单变量、二元变量甚至多元变量)所有小整数根($\\big\\|X\\big\\|<cN^{\\beta^{2}/\\delta}$，其中$\\delta$为多项式$F$的次数，假设$N$具有不小于$N^{\\beta}$的因子)\n\n* 明文高位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其高位$m_{b} \\cdots m_{t+1}$泄露，记$m'=m_{b} \\cdots m_{t+1}0 \\cdots 0$，则$m'$已知，但$\\Delta m=m_{t} \\cdots m_{1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其高位$p_{b} \\cdots p_{t+1}$泄露，记$p'=p_{b} \\cdots p_{t+1}0 \\cdots 0$，则$p'$已知，但$\\Delta p=p_{t} \\cdots p_{1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 明文低位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其低位$m_{t} \\cdots m_{1}$泄露，记$m'=m_{t} \\cdots m_{1}$，则$m'$已知，但$\\Delta m=m_{b} \\cdots m_{t+1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+2^{t}X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其低位$p_{t} \\cdots p_{1}$泄露，记$p'=p_{t} \\cdots p_{1}$，则$p'$已知，但$\\Delta p=p_{b} \\cdots p_{t+1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+2^{t}X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n[GithHub实现链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n## 攻击工具\n\n### RsaCtfTool\nGitHub链接：[RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)\n\n在Ubuntu18.04下的安装RsaCtfTool(进入RsaCtfTool目录下)：\n\n```Bash\napt install -y libgmp-dev\napt install -y libmpfr-dev\napt install -y libmpc-dev\npip3 install gmpy2 -i https://pypi.douban.com/simple\npip3 install -r requirements.txt -i https://pypi.douban.com/simple\n```\n\n### yafu\n\n我认为最强大的分解因子的工具。\n\n### 在线分解因子网站\n\n[factordb](http://factordb.com/)","tags":["rsa"],"categories":["crypto"]},{"title":"b32&64encode详解","url":"/tech/B32-64-encode-explanation.html","content":"以前只是用这些函数，从没想过这些编码的原理；还是因为一道ctf题让我好好的了解了一下这些编码方式！\n\n## b32encode\n\n我们知道每个字节是8比特，b32encode将5个字节分成8块，每块前三位补0，从而将5个字节扩展为8个字节；那么扩展后的每个字节的值不超过32，与32个字符\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"对应，有时我们发现编码的字符串中还有\"=\"这个字符，但是它是填充字符，以上就是b32encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,digits\nfrom base64 import b32encode\n\ndef my_b32encode(s):\n    base=uppercase+digits[2:8]\n    assert(len(s))==5\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==40\n    sbs=[bs[5*ind:5*(ind+1)] for ind in range(8)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b32encode('BITSC')\n    print b32encode('BITSC')\n```\n\n## b64encode\n\nb64encode将3个字节分成4块，每块前两位补0，从而将3个字节扩展为4个字节；那么扩展后的每个字节的值不超过64，与64个字符 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"对应，同样地，\"=\"作为填充字符，以上就是b64encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,lowercase,digits\nfrom base64 import b64encode\n\ndef my_b64encode(s):\n    base=uppercase+lowercase+digits+'+/'\n    assert len(s)==3\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==24\n    sbs=[bs[6*ind:6*(ind+1)] for ind in range(4)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b64encode('BIT')\n    print b64encode('BIT')\n```","tags":["encode"],"categories":["tech"]},{"title":"WMCTF2020密码学部分详解","url":"/crypto/WMCTF2020-Cryptography-Part-Detail.html","content":"比赛网址：[WMCTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=146&hash=684a58cc-1140-4937-99f2-ef347d777d9f.event)\n\n## piece_of_cake\n\n### 题目信息\n附件是一个py脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/piece_of_cake)中的task.py。\n\n### 分析\n\neat_cake函数中的各个变量的定义如下：\n\n* $p,q$为512位随机素数，$ph=(p-1) \\cdot (q+1),N=p \\cdot q,d=e^{-1}\\ \\textrm{mod}\\ ph$\n\n* $cake$为768位随机素数，$q$重新赋值为1536位随机素数，将$d$的值赋给$f$，$g$为随机素数，$g$的位数等于$q$的位数减去$f$的位数再减去1\n\n* $h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$，$r$为512位随机素数，$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n由：\n$$\nh=f^{-1} \\cdot g\\ \\textrm{mod}\\ q\n$$\n可得：\n$$\nf \\cdot h \\equiv g\\ \\textrm{mod}\\ q\n$$\n即存在$t\\in Z$，使得：\n$$\nf \\cdot h-t \\cdot q=g\n$$\n构造矩阵$M$如下：\n$$\nM=\\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix}\n$$\n则有：\n$$\n\\begin{pmatrix}\nf & -t\n\\end{pmatrix} \\cdot \\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix} = \\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$$\n则$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$是格$L(M)$上的短格基，因此有可能可使用LLL算法或BKZ算法求出，这里说有可能求出，因为在解题时并不是每次都能找到短格基$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$\n假设我们求出的短格基为$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$，再由公式$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n则：\n\n$$\nf \\cdot c \\equiv f \\cdot (r \\cdot h+cake) \\equiv (r \\cdot g+f \\cdot cake)\\ \\textrm{mod}\\ q\n$$\n\n\n从而：\n\n$$\n(r \\cdot g+f \\cdot cake)= f \\cdot c\\ \\textrm{mod}\\ q\n$$\n\n\n两边模$g$可得：\n\n$$\nf \\cdot cake \\equiv (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n于是：\n\n$$\ncake=f^{-1} \\cdot (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n注意，上面等式中$f^{-1}$是$f$在$g$下的逆，不能与括号内的$f$抵消。\n\n### 解题\n\n上述链接中的solve.sage为解题的sage脚本。\n\n### 备注\n\n此exp并不能保证次次成功！不过它的有效性不可否认，上述链接中的test.sage即可验证。\n\n以下是我对test.sage四次的运行结果：\n\n```Bash\n$ sage test.sage\nsuccess! 48 -th\n$ sage test.sage\nsuccess! 2 -th\n$ sage test.sage\nsuccess! 50 -th\n$ sage test.sage\nsuccess! 24 -th\n```\n\n从而验证了解题脚本solve.sage的有效性。\n\n## babySum\n\n### 题目信息\n\n附件是两个py脚本与一个json文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/babySum)中的task.py与check.py。\n\n### 分析\n\ntask.py告诉我们生成data中数据的逻辑，其实很好理解：生成$n=120$个150位的随机数，组成数组$A$，从中选$k=20$个相加生成和$s$；\n\n记数组$A=[a_{1},\\cdots,a_{n}]$，check.py读入120个数$b_{1},\\cdots,b_{n}(b_{i}={0,1})$，其中20个为1，另外100个为1，检验$\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$，如果等式成立，就打印出flag。\n\n到这里我们共有3个约束条件：\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\\\\\n\\\\\nb_{i}=0,1;i=1,\\cdots,n\n\\end{cases}\n$$\n遇到这种问题一般转化为格基约减问题，构造矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & a_{1} & 1 \\\\\n  & 1 &   &   & a_{2} & 1 \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & a_{n} & 1 \\\\\n  &   &   &   & -s & -k &\n\\end{pmatrix}\n$$\n\n\n那么$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n即通过格基约减可以求出$b_{1},\\cdots,b_{n}$。\n\n理想很丰满，现实很骨感！\n\n约减后的格基无法达到我们需要的结果！直到看到writeup，这里需要记住一个很有用的技巧，可类比约束优化问题对约束条件的处理，当不满足如下约束条件时\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\n\\end{cases}\n$$\n\n\n\n\n加大“惩罚”，我们重新设计格基矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & N \\cdot a_{1} & N \\\\\n  & 1 &   &   & N \\cdot a_{2} & N \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & N \\cdot a_{n} & N \\\\\n  &   &   &   & -N \\cdot s & -N \\cdot k &\n\\end{pmatrix}\n$$\n其中$N=[\\sqrt{n}]$，此时仍然有$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n然后就是比较玄学的问题，对同一格，改变格基矩阵行的顺序，约减的结果也会不同，官方的writeup就是不断打乱格基矩阵的行，然后进行格基约减；再就是为了更快得到结果，需要进行多线程编程；上述链接中的solve.sage为解题的sage脚本；官方设置的8个线程，我自己改成6个线程，跑了几次，基本上都是20分钟左右出结果。\n\n```Bash\n$ sage solve.sage   \n(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)\ncost time:  0:25:27\n```","tags":["ctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-说我作弊需要证据","url":"/crypto/xctf-Need-proof-that-I-cheated.html","content":"## 题目信息\n\n题目背景为在一次考试中两名学生作弊，给出他们的RSA公钥，附件两者通信的pcapng流量包。\n\n## 分析\n\n鉴于Alice与Bob的密钥位数如此地低，通过yafu或者去[factordb](http://factordb.com/)立马就分解出模数，进而计算出私钥。\n\n用wireshark打开流量包，按下Ctrl+Alt+Shift+T快捷键来追踪TCP流(并保存下来，比如我保存为data.txt)；通过数据格式应该可以确定是base64编码后的数据格式，那么先解码前三个看看编码的数据；\n```Bash\nSEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;\nSEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;\nSEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;\n```\n\nDATA应该是密文，但是另外两个数据也很重要，SEQ是明文的顺序，SIG是对明文的签名；因此对保存的TCP流依次解码，使用Bob的私钥对密文DATA解密，再验证SIG是否为Alice对明文的签名，如果是则放到明文列表的第SEQ位置；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom gmpy2 import invert,powmod\nfrom base64 import b64decode\n\ndef solve():\n    N1=0x53a121a11e36d7a84dde3f5d73cfL\n    N2=0x99122e61dc7bede74711185598c7L\n    e=0x10001L\n#   p1,q1=38456719616722997L,44106885765559411L\n    p2,q2=49662237675630289L,62515288803124247L\n    \n#   phi1=(p1-1)*(q1-1)\n    phi2=(p2-1)*(q2-1)\n#   d1=invert(e,phi1)\n    d2=invert(e,phi2)\n    \n#   rsa_key1=RSA.construct((N1,e,long(d1),p1,q1))\n    rsa_key2=RSA.construct((N2,e,long(d2),p2,q2))\n\n    with open('data.txt','r') as f:\n        data=f.read()\n\n    cips=data.split('\\n')\n    res=['']*len(cips)\n    for cip in cips[:-1]:\n        data=b64decode(cip)\n        seq=int(data[(data.find('= ')+2):data.find(';')])\n        cipher=data[(data.find('x')+1):data.find('L')]\n        sig=data[(data.rfind('x')+1):data.rfind('L')]\n        msg=rsa_key2.decrypt(long(cipher,16))\n        if msg==powmod(long(sig,16),e,N1):\n            res[seq]+=chr(msg)\n    return res\n\nif __name__=='__main__':\n    #python solve.py\n    print ''.join(solve())\n```\n\n运行结果如下：\n\n```Bash\n$ python solve.py\nflag{n0th1ng_t0_533_h3r3_m0v3_0n}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Easy one","url":"/crypto/xctf-Easy-One.html","content":"## 题目信息\n\n题目这样描述：“破解密文，解密msg002.enc文件”，并且提供附件下载，附件中有4个文件：encryptor.c、msg001、msg001.enc与msg002.enc。\n\n## 分析\n\nencryptor.c向我们展示了加密的原理,\n\n```C\nc = (p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;\n```\n对明文的每个字符p，按照上述代码生成密文c，之后t更新为p，i增1，再加密下一个字符。只不过，当我写了对应的解密程序进行解密时，得到的明文是乱码。\n\n我用encryptor.c重新加密了一遍msg001，发现得到的密文与所给的msg001.enc不同，结合加密程序分析，怀疑t的初值或者k被“做了手脚”，我首先穷举了t的256个初值，发现加密的结果均与msg001.enc不同，那么应该是真正加密所用的k并不是encryptor.c展示的k，所以第一步应该解出真正加密所用的k，根据加密原理，k的每一个字符x都能通过下式求出，也就是考察已知明密文求解密钥。\n\n```Python\nx=(ord(c)-ord(m)-ii*ii)&0xff\nx^=t\n```\n\n## 解题\n\n由密文求明文的程序很简单，难点在于你需要先通过msg001、msg001.enc求解出真正加密所用的密钥。\n\n```Python\ndef get_true_key(msg_data,cip_data):\n    xs=''\n    ii,t=0,0\n    for m,c in zip(msg_data,cip_data):\n        x=(ord(c)-ord(m)-ii*ii)&0xff\n        x^=t\n        t=ord(m)\n        ii+=1\n        xs+=chr(x)\n    return xs[:(xs[1:].find(xs[0])+1)]\n\ndef test(msg_data,cip_data,o_k):\n    tt=0\n    cip=''\n    lk=len(o_k)\n    for ii,m in enumerate(msg_data):\n        c=(ord(m)+(o_k[ii%lk]^tt)+ii*ii)&0xff\n        cip+=chr(c)\n        tt=ord(m)\n    return all(x==c for x,c in zip(cip,cip_data))\n\ndef solve():\n    with open('msg001','r') as f:\n        msg_data=f.read().strip()\n    with open('msg001.enc','r') as f:\n        cip_data=f.read().strip()\n    with open('msg002.enc','r') as f:\n        data=f.read().strip()\n    k=get_true_key(msg_data,cip_data)\n    print 'the true key is : ',k\n    o_k=[ord(c) for c in k]\n    assert test(msg_data,cip_data,o_k)\n    t=0\n    msg=''\n    for ii,c in enumerate(data):\n        p=(ord(c)-ii*ii-(o_k[ii%28]^t))&0xff\n        t=p\n        msg+=chr(p)\n    with open('msg002','w') as f:\n        f.write(msg)\n    return msg\n\nif __name__=='__main__':\n#   python solve.py\n    print solve().strip()\n```\n\n解出加密所用密钥，破解密文：\n\n```Bash\n$ python solve.py\nthe true key is : VeryLongKeyYouWillNeverGuess\nThe known-plaintext attack (KPA) is an attack model for cryptanalysis where the attacker has samples of both the plaintext (called a crib), and its encrypted version (ciphertext). These can be used to reveal further secret information such as secret keys and code books. The term \"crib\" originated at Bletchley Park, the British World War II decryption operation. \nThe flag is CTF{6d5eba48508efb13dc87220879306619}\n```\n简要介绍了已知明文攻击之后，后面给出flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-wtc_rsa_bbq","url":"/crypto/xctf-WTC-RSA-BBQ.html","content":"## 题目信息\n\n附件是一个压缩包，解压之后还是一个压缩包，再解压(禁止套娃!!!)得一个文件夹，里面包含公钥(key.pem)与密文(cipher.bin)信息。\n\n## 分析\n\n使用openssl查看公钥信息：\n\n```Bash\nopenssl rsa -pubin -in key.pem -text -modulus\n```\n\n发现模数很大，8587位；本来分解模数无脑丢到yafu里面分解就行，但是几个小时都没有分解出来，去[factordb](http://factordb.com/)也分解不出来；回顾针对RSA的各种攻击，对本题可以使用的剩下Small q,费马分解(p与q接近)，试着用费马分解时分解成功。\n\n## 解题\n\n使用工具[RSACTFTool](https://github.com/Ganapati/RsaCtfTool)进行分解,将key.pem与cipher.bin移到与RsaCtfTool.py同目录下：\n\n```Bash\nsudo python3 RsaCtfTool.py --publickey key.pem --uncipherfile cipher.bin --attack fermat\n```\n\n在明文最后给出flag为flag{how_d0_you_7urn_this_0n?}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-banana-princess","url":"/crypto/xctf-Banana-Princess.html","content":"## 题目信息\n\n附件给出一个PDF文件，但是用阅读器打开显示文件已损坏。\n\n## 分析\n\n用vim打开PDF文件，开头为%CQS-1.5，既然是PDF文件，那就找找CQS与PDF的关系，首先想到的是凯撒密码，结果发现这三个字母均在字母表中相隔13，另外PDF文件中的小写字母也需要进行解密替换。\n\n## 解题\n使用Shell，一行就可以完成解密：\n\n```Bash\n$ cat cip.pdf | tr A-Za-z N-ZA-Mn-za-m > msg.pdf\n```\n\n结果发现flag被遮住了，另存为图片，flag可见，为BITSCTF{save_the_kid}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-你猜猜","url":"/crypto/xctf-Guess.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一串16进制数据。\n\n## 分析\n\n504B0304开头一般代表zip数据(另外还有526172211a0701开头代表rar数据，377abcaf271c开头代表7z数据)，于是将这一串16进制数据另存为一个zip文件，不用说，压缩时肯定进行了加密，使用fcrackzip工具进行破解。\n\n## 解题\n\n首先使用Python将16进制数据另存为一个zip文件：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\ns=0x504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000\nwith open('data.zip','wb') as f:\n    f.write(long_to_bytes(s))\n```\n\n再使用fcrackzip工具破解密码：\n\n```Bash\n$ fcrackzip -b -c '1' -l 4-8 -u data.zip\n\nPASSWORD FOUND!!!!: pw == 123456\n```\n解密得到flag.txt，里面保存着flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-sherlock","url":"/crypto/xctf-Sherlock.html","content":"## 题目信息\n\n附件是网页上的一篇文章，先复制到txt中保存。\n\n## 分析\n\n如下是文章开头：\n\n```Bash\n(additional editing by jose menendeZ)\n\nthE adventuRes Of\nsherlOck holmes\n\nby\n\nsir arthur coNan doylE\n```\n\n奇怪之处是有些位置不应该使用大写字母，但是使用了大写字母，推断这些大写字母是用来传递消息的。将文章中的所有大写字母提取出来，得到一串全部由ZERO与ONE组成的字符串，ZERO替换为数字0，ONE替换为数字1，从而得到一个二进制表示的数，再将此数转换为字符串即可。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom string import uppercase\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('paper','r') as f:\n        data=f.read()\n    cip=''\n    for c in data:\n        if c in uppercase:\n            cip+=c\n    cip=cip.replace('ZERO','0')\n    cip=cip.replace('ONE','1')\n    return long_to_bytes(long(cip,2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nBITSCTF{h1d3_1n_pl41n_5173}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-告诉你一个秘密","url":"/crypto/xctf-Tells-you-a-secret.html","content":"## 题目信息\n\n附件为两行数字与字母组成的字符串。\n\n## 分析\n\n字符串中的字母均未超过E，猜测是16进制编码，于是先将字符串进行16进制解码，解码之后看上去像base64编码，于是接着进行base64解码，得到两段全由字母组成的字符串，并且被空格隔开，每小段字符串包含3-4个字母，解密的方法就在眼前——键盘，每小段字符串的字母围起来的字母就是明文。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom base64 import b64decode\n\ndef solve():\n    cips=[\n            '636A56355279427363446C4A49454A7154534230526D6843',\n            '56445A31614342354E326C4B4946467A5769426961453067'\n            ]\n    msgs=[]\n    for cip in cips:\n        msgs.append(b64decode(cip.decode('hex')))\n    return msgs\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行程序得到如下结果：\n\n```Bash\n$ python solve.py\n['r5yG lp9I BjM tFhB', 'T6uh y7iJ QsZ bhM ']\n```\n\n接下来在键盘上找每小段字符串的字母围起来的字母，得到flag为tongyuan。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-flag in your hand","url":"/crypto/xctf-Flag-in-Your-Hand.html","content":"## 题目信息\n\n题目给了两个文件：index.html与script-min.js。\n\n## 分析\n\n先分析index.html的逻辑，第58行：\n\n```HTML\n<input type=\"button\" value=\"Get flag!\" onclick=\"getFlag()\" />\n```\n\n结合浏览器打开index.html的效果，我们知道点击 'Get flag!' 按钮时会调用getFlag()函数；\n\ngetFlag()函数的定义在第32行：\n```JavaScript\nfunction getFlag() {\n\tvar token = document.getElementById(\"secToken\").value;\n\tic = checkToken(token);\n\tfg = bm(token);\n\tshowFlag()\n}\n```\n\n在显示flag之前会调用checkToken(token)与bm(token)两个函数，我们先看一下显示flag的showFlag()函数，它定义在第39行：\n\n```JavaScript\nfunction showFlag() {\n\tvar t = document.getElementById(\"flagTitle\");\n\tvar f = document.getElementById(\"flag\");\n\tt.innerText = !!ic ? \"You got the flag below!!\" : \"Wrong!\";\n\tt.className = !!ic ? \"rightflag\" : \"wrongflag\";\n\tf.innerText = fg;\n}\n```\n\n可以看到是通过ic的布尔值判断我们是否输入正确的token，而ic由函数checkToken(token)返回，跳转到script-min.js中定义函数checkToken的地方看一下：\n\n```JavaScript\nfunction checkToken(s) {\n    return s === \"FAKE-TOKEN\";\n}\n```\n\n难不成FAKE-TOKEN就是正确的token？当然不是，还是抱着希望去试了一下，果然不是！那么问题只能出在函数bm中，它改变了ic的布尔值！\n\n于是去看一下函数bm，它定义如下：\n\n```JavaScript\nfunction bm(s){\n\treturn rb(rstr(str2rstr_utf8(s)));\n}\n```\n\n函数str2rstr_utf8与rb并没有改变ic的布尔值，是rstr调用的函数ck改变了ic的布尔值；函数ck的定义如下：\n\n```JavaScript\nfunction ck(s){\n    try {\n        ic\n    } catch (e) {\n        return;\n    }\n    var a = [118, 104, 102, 120, 117, 108, 119, 124, 48,123,101,120];\n    if (s.length == a.length) {\n        for (i = 0; i < s.length; i++) {\n            if (a[i] - s.charCodeAt(i) != 3)\n                return ic = false;\n        }\n        return ic = true;\n    }\n    return ic = false;\n}\n```\n\n看到这里明白了，checkToken就是个幌子，这里才决定ic布尔值！对函数ic的输入参数(字符串)s，只有s与列表a等长，且s每个字符在ascii表中的序号比列表a中每个对应元素小3时，ic才为True。\n\n于是可以写个python脚本求一下这里会让ic=True的s：\n\n```Python\na=[118,104,102,120,117,108,119,124,48,123,101,120];\nprint ''.join([chr(x-3) for x in a])\n```\n\n得到s为security-xbu字符串。\n\n综上，当函数ck的输入为字符串security-xbu时，会使ic的布尔值为True，从而得到正确的flag；通过分析调用过程，函数ck的输入为str2rstr_utf8(token)，那么token为何值时str2rstr_utf8(token)为字符串security-xbu呢？是不是要写个str2rstr_utf8的逆程序？其实不用，我们将script-min.js中的函数bm改一下，如下：\n\n```JavaScript\nfunction bm(s){\n\t//return rb(rstr(str2rstr_utf8(s)));\n\treturn rb(rstr(s))\n}\n```\n\n刷新index.html，填入security-xbu，就可以得到正确的flag！","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析2","url":"/crypto/xctf-Industrial-Protocol-Analysis-II.html","content":"## 题目信息\n\n在进行工业企业检查评估工作中，发现了疑似感染恶意软件的上位机。现已提取出上位机通信流量，尝试分析出异常点，获取FLAG。 flag形式为 flag{}。\n\n## 分析\n字符串'flag'的16进制编码为0x666c6167，在筛选器输入data contains \"666c61677b\"筛选包含666c61677b的流量包，筛选出两个包。\n\n## 解题\n任选一个提取出数据666c61677b37466f4d3253746b6865507a7d，再进行16进制解码得到flag{7FoM2StkhePz}","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-新手练习区","url":"/crypto/xctf-Beginner-Practice-Area.html","content":"## Caeser\n\n凯撒密码：替换加密——明文中的所有字母都在字母表上向后按照一个固定数目offset进行偏移后被替换成密文。由于不知道偏移量，因此将每个偏移量都试一下进行解密;事实上，解密过程既可以看作密文中的所有字母都在字母表上向前按照一个固定数目offset进行偏移，也可以看作密文中的所有字母都在字母表上向后按照一个固定数目(26-offset)进行偏移！\n\n如下是解题的Python代码：\n\n```Python\nfrom string import lowercase\n\nclass Caeser():\n    def __init__(self,dic=None):\n        if dic==None:\n            self.dic=lowercase\n        else:\n            self.dic=dic\n\n    def enc(self,msg,ofst):\n        dic=self.dic\n        ld=len(dic)\n        cip=''\n        for c in msg:\n            if c in dic:\n                index=dic.find(c)\n                cip+=dic[(index+ofst)%ld]\n            else:\n                cip+=c\n        return cip\n\ndef solve():\n    msg='oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}'\n    caeser=Caeser()\n    for ii in range(len(caeser.dic)):\n        print caeser.enc(msg,ii)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp1.py\noknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\nplorecrnpr{lbh_unir_yrnearq_pnrfne_rapelcgvba}\nqmpsfdsoqs{mci_vojs_zsofbsr_qosgof_sbqfmdhwcb}\nrnqtgetprt{ndj_wpkt_atpgcts_rpthpg_tcrgneixdc}\nsoruhfuqsu{oek_xqlu_buqhdut_squiqh_udshofjyed}\ntpsvigvrtv{pfl_yrmv_cvrievu_trvjri_vetipgkzfe}\nuqtwjhwsuw{qgm_zsnw_dwsjfwv_uswksj_wfujqhlagf}\nvruxkixtvx{rhn_atox_extkgxw_vtxltk_xgvkrimbhg}\nwsvyljyuwy{sio_bupy_fyulhyx_wuymul_yhwlsjncih}\nxtwzmkzvxz{tjp_cvqz_gzvmizy_xvznvm_zixmtkodji}\nyuxanlawya{ukq_dwra_hawnjaz_ywaown_ajynulpekj}\nzvybombxzb{vlr_exsb_ibxokba_zxbpxo_bkzovmqflk}\nawzcpncyac{wms_fytc_jcyplcb_aycqyp_clapwnrgml}\nbxadqodzbd{xnt_gzud_kdzqmdc_bzdrzq_dmbqxoshnm}\ncyberpeace{you_have_learned_caesar_encryption}\ndzcfsqfbdf{zpv_ibwf_mfbsofe_dbftbs_fodszqujpo}\neadgtrgceg{aqw_jcxg_ngctpgf_ecguct_gpetarvkqp}\nfbehushdfh{brx_kdyh_ohduqhg_fdhvdu_hqfubswlrq}\ngcfivtiegi{csy_lezi_pievrih_geiwev_irgvctxmsr}\nhdgjwujfhj{dtz_mfaj_qjfwsji_hfjxfw_jshwduynts}\niehkxvkgik{eua_ngbk_rkgxtkj_igkygx_ktixevzout}\njfilywlhjl{fvb_ohcl_slhyulk_jhlzhy_lujyfwapvu}\nkgjmzxmikm{gwc_pidm_tmizvml_kimaiz_mvkzgxbqwv}\nlhknaynjln{hxd_qjen_unjawnm_ljnbja_nwlahycrxw}\nmilobzokmo{iye_rkfo_vokbxon_mkockb_oxmbizdsyx}\nnjmpcaplnp{jzf_slgp_wplcypo_nlpdlc_pyncjaetzy}\n```\n\n看上去像句人话的就是cyberpeace{you_have_learned_caesar_encryption}，这就是flag。\n\n## Morse\n\n摩尔斯密码：使用0,1两种状态的二进制代码组合表示字母与数字；解密就是一个查找操作。如下是解题的Python代码：\n\n```Python\n#Morse Code\n\nclass Morse():\n    def __init__(self):\n        self.dic = {'a': '01',     'b': '1000',   'c': '1010',\n                'd': '100',    'e': '0',      'f': '0010',\n                'g': '110',    'h': '0000',   'i': '00',\n                'j': '0111',   'k': '101',    'l': '0100',\n                'm': '11',     'n': '10',     'o': '111',\n                'p': '0110',   'q': '1101',   'r': '010',\n                's': '000',    't': '1',      'u': '001',\n                'v': '0001',   'w': '011',    'x': '1001',\n                'y': '1011',   'z': '1100',   '_': '001101',\n                '0': '11111',  '1': '01111',  '2': '00111',\n                '3': '00011',  '4': '00001',  '5': '00000',\n                '6': '10000',  '7': '11000',  '8': '11100',\n                '9': '11110'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n            cip+=''\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in cip.split():\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'\n    morse=Morse()\n    print morse.dec(cip)\n\nif __name__=='__main__':\n#   python wp2.py\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp2.py\nmorsecodeissointeresting\n```\n\n## 不仅仅是Morse\n\n由于得到的数据格式与上一个相同，因此仍然进行Morse解密，解密出\n```Bash\nmay_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba\n```\n\n这还不是明文，提示你还需要一种解码；这种密码是培根密码：替换密码——根据所给表对应转换即可加密解密。\n\n如下是解题的Python代码：\n\n```Python\n#Morse code + Bacon cipher\n\nfrom wp2 import Morse\n\nclass Bacon():\n    def __init__(self):\n        self.dic={'a':'aaaaa','b':'aaaab','c':'aaaba','d':'aaabb',\n                'e':'aabaa','f':'aabab','g':'aabba','h':'aabbb',\n                'i':'abaaa','j':'abaab','k':'ababa','l':'ababb',\n                'm':'abbaa','n':'abbab','o':'abbba','p':'abbbb',\n                'q':'baaaa','r':'baaab','s':'baaba','t':'baabb',\n                'u':'babaa','v':'babab','w':'babba','x':'babbb',\n                'y':'bbaaa','z':'bbaab'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in [cip[5*ii:5*(ii+1)] for ii in range(len(cip)/5)]:\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 01 1011 001101 1000 0 001101 0000 01 0001 0 001101 01 10 111 1 0000 0 010 001101 100 0 1010 111 100 0 0000 0000 0000 0000 01 01 01 01 01 1000 01 01 1000 1000 1000 01 01 1000 1000 01 01 01 01 01 01 01 01 1000 01 01 1000 01 1000 01 01 01 01 01 01 01 1000 1000 01 1000 01 01 01 1000 1000 01 01 01 1000 1000 01 01 1000 01 01 01 01 1000 01 1000 01 01 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 01 1000 01 01 1000 01 1000 1000 01 01 1000 1000 1000 01 1000 01 01 01 1000 01 1000 01 1000 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 01 01 1000 1000 01 1000 1000 01 01 1000 1000 01 01 1000 01 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 1000 01 1000 01 01 1000 1000 01 1000 01 01 01 01 1000 1000 01 1000 01 01 1000 1000 01'\n    morse=Morse()\n    cip=morse.dec(cip)\n    print cip\n    cip=cip[cip.find('hhhh')+4:]\n    bacon=Bacon()\n    print bacon.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp3.py\nattackanddefenceworldisinteresting\n```\n\n## 幂数加密\n\n这题实际是云影密码：26个英文字母在字母表中的次序ord(x)<$2^{5}$，因此5位二进制数可以表示一个英文字母，即1,2,4,8,16的组合(求和)可表示一个英文字母，例如L在字母表中的次序为12=4+8，因此组合48就可以表示字母L；同时0作为分隔符。\n\n如下是解题的Python代码：\n\n```Python\ns='8842101220480224404014224202480122'\nls=s.split('0')\ndic='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nm=''\nfor c in ls:\n    t=0\n    for cc in c:\n        t+=int(cc)\n    m+=dic[t-1]\nprint m\n```\n\n运行上述程序：\n\n```Bash\n$ python wp4.py\nWELLDONE\n```\n\n## Railfence\n\n栅栏密码：将明文row个为一组，排列为col行(明文的长度可能小于为row$\\cdot$col，即最后一行可能不会填满)，再将第一列的字母从上至下连接起来，接下来是第二列，直到第row列，生成密文。\n\n但是此题是栅栏密码的一个变种——W型栅栏密码；例如，如下是一个密钥为5的W型栅栏密码，明文为1-19的自然数，将其按照W的形状排列，再由上至下，从左至右连接数字，生成密文[1,9,17,2,8,10,16,18,3,7,11,15,19,4,6,12,14,5,13]。\n\n```Bash\n1             9               17\n  2         8   10          16  18\n    3      7      11      15      19\n      4   6         12  14\n        5             13\n```\n\n如下是解题的Python代码(此题的密钥为5)：\n\n```Python\n#W kind Railfence cipher\n\nclass Railfence_W():\n    def __init__(self,key=2):\n        self.key=key\n\n    def enc(self,msg,mode):\n        #mode = 0 means decrypt,mode = 1 means encrypt\n        ls=len(msg)\n        key=self.key\n        rep=range(0,ls,2*(key-1))\n        for dd in range(1,key-1):\n            ind=dd\n            de1=2*(key-1-dd)\n            de2=2*dd\n            while ind<ls:\n                rep.append(ind)\n                ind+=de1\n                if ind>=ls:\n                    break\n                rep.append(ind)\n                ind+=de2\n        rep.extend(range(key-1,ls,2*(key-1)))\n        if mode:\n            cips=''.join([msg[ii] for ii in rep])\n        else:\n            cip=rep[:]\n            for ii in range(ls):\n                cip[rep[ii]]=msg[ii]\n            cips=''.join(cip)\n        return cips\n\ndef solve():\n    cip='ccehgyaefnpeoobe{lcirg}epriec_ora_g'\n    for step in range(2,8):\n        railfence_w=Railfence_W(step)\n        print railfence_w.enc(cip,0)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp5.py\ncccierhgg}yeaperfinepce_ooorbae_{gl\ncnipceeoeocbhe_{glocyirraga}ee_pfrg\ncal_cecfiornepgr}ehoeapogbr_iey{egc\ncyberpeace{railfence_cipher_gogogo}\ncgecraiioycaore_cgbeefe}_goe{nhplpr\nchfbriaegengcyp{}c__eleaeeocpogrrio\n```\n\n## easychallenge\n\n附件是一个pyc文件，使用uncompyle6进行反编译得到py脚本，脚本中定义了3个编码函数，这3个编码函数都是可逆的，从而可求解出与给定编码数据对应的明文。\n\n如下是解题的Python代码：\n\n```Python\nfrom base64 import b32decode\n\ndef decode1(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)-25\n        x^=36\n        s+=chr(x)\n    return s\n\ndef decode2(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)^36\n        x-=36\n        s+=chr(x)\n    return s\n\ndef decode3(ans):\n    return b32decode(ans)\n\ndef solve():\n    final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='\n    return decode1(decode2(decode3(final)))\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp6.py\ncyberpeace{interestinghhhhh}\n```\n\n## 转轮机加密\n\n题目提示托马斯·杰斐逊，搜索一下有一个关于此人的密码——杰斐逊密码：首先，转轮机每一圈有若干字母，共有若干圈；加密时，将转轮机调整至某一列为明文，然后任选其他的某一列，作为密文。因此解密时，转轮机调整至某一列为密文，然后分析其他列，找到语句通顺的就是明文。\n\n如下是解题的Python代码：\n\n```Python\n#Jefferson cipher\n\nclass Jefferson():\n    def __init__(self,key):\n        self.box=[\n                'ZWAXJGDLUBVIQHKYPNTCRMOSFE',\n                'KPBELNACZDTRXMJQOYHGVSFUWI',\n                'BDMAIZVRNSJUWFHTEQGYXPLOCK',\n                'RPLNDVHGFCUKTEBSXQYIZMJWAO',\n                'IHFRLABEUOTSGJVDKCPMNZQWXY',\n                'AMKGHIWPNYCJBFZDRUSLOQXVET',\n                'GWTHSPYBXIZULVKMRAFDCEONJQ',\n                'NOZUTWDCVRJLXKISEFAPMYGHBQ',\n                'XPLTDSRFHENYVUBMCQWAOIKZGJ',\n                'UDNAJFBOWTGVRSCZQKELMXYIHP',\n                'MNBVCXZQWERTPOIUYALSKDJFHG',\n                'LVNCMXZPQOWEIURYTASBKJDFHG',\n                'JZQAWSXCDERFVBGTYHNUMKILOP'\n                ]\n        self.key=key\n\n    def dec(self,cip):\n        box=self.box\n        key=self.key\n        lb=len(box)\n        tbox=[box[x-1] for x in key]\n        assert lb==len(cip)\n        for ii in range(lb):\n            ind=tbox[ii].find(cip[ii])\n            tbox[ii]=tbox[ii][ind:]+tbox[ii][:ind]\n        for ii in range(len(box[0])):\n            print (''.join([x[ii] for x in tbox])).lower()\n\ndef solve():\n    cip='NFQKSEVOQOFNP'\n    key=[2,3,7,5,13,12,9,1,8,10,4,11,6]\n    jefferson=Jefferson(key)\n    jefferson.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp7.py\n...\nsambkvlqsiaav\nfireinthehole\nuzaulcdkfprst\n...\n```\n\n唯一一句人话就是fireinthehole，这就是flag。","tags":["xctf"],"categories":["crypto"]},{"title":"about","url":"/about/index.html","content":"\n姓名：褚康明\n\n籍贯：湖北省孝感市\n\n本科：西安电子科技大学，数学与应用数学\n\n硕士：中国科学院大学信息工程研究所，电子信息\n\n方向：CTF密码学，NLP，代码嵌入"},{"title":"help","url":"/help/index.html","content":"\n**1**这博客很好看，是怎么做的？\n答：本博客使用Hexo制作，采用的jsimple主题，部署在Gitee Pages上，搭建步骤请参考：[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)，也可以多参考[主题作者的README](https://github.com/tangkunyin/hexo-theme-jsimple/blob/master/README.zhCN.md)\n\n**2**部署到Gitee Pages上面时布局一团糟怎么办？\n答：这可能是因为你没有做到`根目录部署`，导致数据索引不到，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客，在最后指出如何正确创建`根目录部署`\n\n**3**Gitee Pages与本地的博客效果不一致是为什么？\n答：因为您没有氪金，单用`hexo deploy`是不会更新Gitee Pages的，还需要手动更新，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客\n\n**4**怎么才能多给我打赏？\n答：好意心领了，我相信千里送鹅毛，礼轻情意重"},{"title":"tags","url":"/tags/index.html"},{"title":"links","url":"/links/index.html","content":"\n[hexo文档](https://hexo.io/zh-cn/docs/)\n\n[hexo 主题大全](https://hexo.io/themes/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[攻防世界](https://adworld.xctf.org.cn)\n\n[pexels](https://www.pexels.com/)\n\n[Gnome-look](https://www.gnome-look.org)\n\n[中文马克思主义文库：毛泽东](https://www.marxists.org/chinese/maozedong/index.htm)\n\n[抗美援朝](http://www.12371.cn/2020/10/12/VIDA1602474174035898.shtml)\n\n[国务院公报](http://www.gov.cn/zwgk/2011-11/09/content_1989024.htm)\n\n\n\n\n\n"}]
[{"title":"Ubuntu18.04安装ntl库","url":"/[object Object]/Ubuntu1804-installs-the-NTL-library.html","content":"\n首先去[官网](https://www.shoup.net/ntl)下载安装包，下列shell脚本与安装包放到同一目录，赋予此脚本执行权限。另外，我这里默认你的电脑上面已经安装gcc，g++，make。\n```Bash\n#apt install -y gcc\n#apt install -y g++\n#apt install -y make\napt install -y autoconf\n\napt install -y m4\napt install -y libgmp-dev\napt install -y libgf2x-dev\n\ntar zxvf ntl-11.4.3.tar.gz\n\nmv ntl-11.4.3 ntl\n \necho -e \"\\033[31m start install ntl \\033[0m\"\ncd ntl/src\n./configure NTL_GF2X_LIB=on\nmake && make check && make install\ncd - >> /dev/null\n \nrm -r ntl\n```\n测试一下：新建一个rand.cpp（顾名思义，是输出随机数）\n```C++\n#include <NTL/ZZ.h>\n#include <time.h>\nNTL_CLIENT\nint main()\n{\n\tZZ a,b,c;\n\tSetSeed(to_ZZ(time(NULL)));\n\tRandomLen(a, 32);\n\tRandomLen(b, 32);\n\tc = a + b;\n\tcout << \"a=\" << a << \", b=\" << b << \", c=\" << c << \"\\n\";\n\treturn 0;\n}\n```\n按照官网的介绍，使用如下命令编译：\n```Bash\ng++ -g -O2 -std=c++11 -pthread -march=native rand.cpp -o rand -lntl -lgmp -lm\n```\n其中rand.cpp是c++文件，rand是编译后的可执行文件。程序运行效果如下：\n```Bash\n$ ./rand\na=2298665095, b=3622090486, c=5920755581\n```\n\n参考链接：\n[NTL库快速上手中文指南](https://blog.csdn.net/tzwh_86/article/details/9372411#commentBox)\n[A Tour of NTL](https://libntl.org/doc/tour.html)","tags":["Ubuntu","ntl"],"categories":["conf"]},{"title":"Bitcoin—块散列算法","url":"/[object Object]/Bitcoin-Block-hashing-algorithm.html","content":"\n# 1. BTC Block\n\n[BTC Block](https://live.blockcypher.com/btc/)\n\n{% asset_img 1.png pic1 %}\n\n点击进入Height为658423的哈希值(000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c)\n\n{% asset_img 2.png pic2 %}\n\n# 2. Block hash算法\n\n[Block hash算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)\n\n它有多强大呢？举个例子：\n\n```Python\n>>> from hashlib import sha256\n>>> d=bytes.fromhex('01000000'+'81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000'+'e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b'+'c7f5d74d'+'f2b9441a'+'42a14695')\n>>> h=sha256(d).digest()\n>>> sha256(h).hexdigest()\n'1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000'\n```\n\n通过它构造的消息，其哈希值后面有很长的一段0！想知道上面的消息怎么构造，请往下看：\n\n## 2.1. 准备工作\n\n**1.**安装pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n\n**2.**安装curl工具\n\n如果你用的Linux系统，curl工具可通过命令行安装；\n\n对于我使用的Windows系统，去[官网](https://curl.se/windows/)下载工具包，解压到C:\\Windows\\System32目录下或者将bin目录下的curl.exe的路径加入环境变量；\n\n## 2.2. 获取构造特定哈希值的信息\n\n对我们想要的哈希值000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c，在命令行运行：\n```Bash\n# curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c > data\n```\n因为返回的消息太多了，因此输出重定向到文件中存下来；我们主要关注的有：ver、prev_block、mrkl_root、time、bits与nonce；这些值提取出来如下：\n```Python\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n```\n注意：ver、time、bits与nonce找最前面的，prev_block与mrkl_root找最后面的，不然算出来的哈希值会不是我们想要的。\n\n接下来，使用我写好的脚本如下，通过将这些信息组合起来就可以构造出消息，其哈希值就是000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c！\n\n```Python\nfrom hashlib import sha256\nfrom binascii import hexlify,unhexlify\nfrom Crypto.Util.number import long_to_bytes\n\n#curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n\ndef num_to_Bytes(n):\n    byte_n=long_to_bytes(n,4)\n    return byte_n[::-1]\n\ndef hex_to_Bytes(h):\n    s=unhexlify(h)\n    return s[::-1]\n    \ndef Bitcoin_demo():\n    d=num_to_Bytes(data['ver'])+hex_to_Bytes(data['prev_block'])+hex_to_Bytes(data['mrkl_root'])+num_to_Bytes(data['time'])+num_to_Bytes(data['bits'])+num_to_Bytes(data['nonce']%pow(2,32))\n    h=sha256(d).digest()\n    return sha256(h).digest()\n\nif __name__=='__main__':\n    ret=Bitcoin_demo()\n    print(hexlify(ret[::-1]))\n```\n\n程序运行结果如下：\n\n```Bash\n# python3 Bitcoin.py\nb'000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"Sagemath在ctf密码学中的使用","url":"/[object Object]/Use-of-Sagemath-in-CTF-Cryptography.html","content":"\n# 1. 基本的环和域\n\n```Python\n#整数域,有理数域和实数域\nZZ(3)\nQQ(0.25)\nRR(2^0.5)\n#复数域\nCC(1,2)\n#生成虚数单位i\ni=ComplexField().gen();(2+i)*(4+3*i)\n\n#构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环\n#定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域\nR.<w>=PolynomialRing(ZZ);R\n(1 + w)^3\n\n#有限环\nRN=IntegerModRing(63)\nFR=Integers(17);FR\n#自身的代数扩展;exR=FR[w]/(w^2+3)\nexR=FR.extension(w^2+3)；exR\n#以python整数的形式返回所有可逆元素的列表\nFR.list_of_elements_of_multiplicative_group()\n#假设环的乘法群是循环的，返回这个环的乘法群的生成元\nFR.multiplicative_generator()\n#返回这个环的一个随机元素\nFR.random_element()\n#上述几种方法对如下的域同样支持\n\n#有限域\n#素数域\nG1=GF(37);G1\n#伽罗瓦域\nG2=GF(3^5);G2\n```\n\n# 2. 数论基本函数\n\n```Python\n#同时求商与余数\nq,r=divmod(12,5)\n\n#求公约数\nd=gcd(12,5)\n\n#扩展的欧几里得算法\nd,u,v=xgcd(12,5)\n\n#12在模5下的逆\nu=inverse_mod(12,5)\n\n#生成[lb,ub)之间的随机素数,注意ub在前,lb在后,lb可缺省为0\n#可通过这种方式生成128位的随机素数\np=random_prime(2L**128,2L**127)\n\n#判断是否为素数\nis_prime(65537)\n\n#第20个素数\nnth_prime(20)\n\n#计算x^y mod n\nz=power_mod(12,5,17)\n\n#欧拉函数\neuler_phi(111)\n\n#中国剩余定理,A=[a1,...,an],M=[m1,...,mn]\n#ai=x mod mi,i=1,...,n\ncrt([1,2,3,4],[7,5,12,23])\n\n#求自身的n次根\nFR(12).nth_root(7,all='True')\n\n#求多项式的根，roots方法必须作用在域上\nR.<x>=PolynomialRing(G1)\nxt=G1(12)\nyt=xt^6\nf=x^6-yt\nf.roots()\n```\n\n# 3. 线性代数\n\n```Python\n#定义矩阵，默认定义在实数域\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#定义在其他域上的矩阵，如有限域\nA = matrix(GF(13),[[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#可以看到两个逆矩阵不一样\n\n#定义向量，定义在有限域，默认定义在实数域\nw = vector(GF(13),[1,1,4,3])\nY=A*w;Y\nZ=w*A;Z\n\n#解线性方程组AX=Y\nX = A.solve_right(Y);X\n#也可以使用符号\\\nA\\Y\n#解线性方程组XA=Y\nX = A.solve_left(Z);X\n\n#格基约减\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\n#LLL算法\nA.LLL()\n#BKZ算法\nA.BKZ()\n```\n\n# 4. 离散椭圆曲线\n以国密SM2算法使用的椭圆曲线为例；\n\n```Python\np=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF',16)\na=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC',16)\nb=ZZ('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93',16)\n#有限域GF(p)上的椭圆曲线y^2 = x^3 + a*x + b mod p\nE=EllipticCurve(GF(p),[0,0,0,a,b])\n#基点\ng=E([ZZ('32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7',16),ZZ('bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0',16)])\n#基点的阶\nn=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123',16)\n#生成密钥\nsk=random_prime(2*n//3,n//3)\n#生成公钥\nG=sk*g\n```\n\n# 5. 离散对数\n\n前言：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是'+'与'\\*'，默认为'\\*'；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。\n\n```Python\n#通用的求离散对数的方法\nx=discrete_log(a,base,ord,operation)\n\n#求离散对数的Pollard-Rho算法\nx=discrete_log_rho(a,base,ord,operation)\n\n#求离散对数的Pollard-kangaroo算法(也称为lambda算法)\nx=discrete_log_lambda(a,base,bounds,operation)\n\n#小步大步法\nx=bsgs(base,a,bounds,operation)\n```\n\n# 6. coppersmith算法\n\n[coppersmith算法介绍链接](https://www.cnblogs.com/coming1890/p/13506057.html)\n\n使用sage实现coppersmith相关攻击，[GitHub链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n最后，sage的[官方文档链接](https://doc.sagemath.org/html/en/reference/)","tags":["ctf"],"categories":["crypto"]},{"title":"Elgamal&RSA小结","url":"/[object Object]/Elgamal-RSA-summary.html","content":"\n# 1. 前言\n\n要解决的问题：$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但$(e,\\phi(N))>1$)\n\n# 2. 分类讨论\n\n首先给出求解方程($q,e$为素数)$y\\equiv x^{e}\\ \\textrm{mod}\\ q^{k}$的[Python脚本](https://github.com/KangMing-ux/AllRootModqk)\n\n注：当$k=1$时，可(使用Sagemath)直接在有限域$GF(q)$上对$y$开$e$次方；\n\n## 2.1. $N=p^{a}$\n\n记$g=(e,\\phi(N)),e_{1}=e/g$，则$(e_{1},\\phi(N))=1$，因此可以计算$d_{1}\\equiv e_{1}^{-1}\\ \\textrm{mod}\\ \\phi(N)$；$c^{d_{1}}\\equiv m^{e\\cdot d_{1}}\\equiv (m^{g})^{d_{1}\\cdot e_{1}}\\equiv m^{g}\\ \\textrm{mod}\\ N$，从而可得$m^{g}\\ \\textrm{mod}\\ p^{a}$，接下来使用上述工具求解(最多有$g$个解)。\n\n## 2.2. $N=p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}}$\n\n$c\\equiv m^{e}\\ \\textrm{mod}\\ N\\Rightarrow c\\equiv m^{e}\\ \\textrm{mod}\\ (p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}})$，则有\n$$\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n记$\\phi_{i}=\\phi(p_{i}^{a_{i}})$，$g_{i}=(e,\\phi_{i})$，$e_{i}=e/g_{i}$，$d_{i}\\equiv e_{i}^{-1}\\ \\textrm{mod}\\ \\phi_{i}$\n$$\nm^{g_{1}}\\equiv c^{d_{1}}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm^{g_{k}}\\equiv c^{d_{k}}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n这时处理的方式不唯一；我们只考虑那些$g_{i}$很小的线程同余方程，不妨设$g_{1},\\cdots,g_{t}$很小；\n\n(1)$g_{1}=\\cdots =g_{s}=r$，$s\\leqslant t$(不妨设前$s$个$g_{i}$相等)\n\n利用中国剩余定理求解前$s$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$下的解；当$m^{r}<p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$时，直接对解开$r$次方即得$m$；\n\n(2)一般情况，$g_{i}(i=1,\\cdots,t)$很小但是大多数各不相同\n\n那么首先对每个方程组利用上述工具求解(记$x_{i}$为第$i$个方程的解，此时大多数方程组有多个解，每个方程组的解最多有$g_{i}$个)\n\n$$\nm\\equiv x_{1}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm\\equiv x_{k}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n\n利用中国剩余定理求解前$t$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{k}^{a_{t}}$下的解；当$m<p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}$时，$m$必在这些解中。\n\n注：其实这里也解释了为什么考虑那些$g_{i}$很小的线程同余方程，我们最多要求解$g_{1}\\cdots g_{t}$个这样的方程组，每个方程组会求出一个解；如果$g_{i}$很大，那么候选的解太多；但是我们要保证$p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}>m$。","tags":["ctf"],"categories":["crypto"]},{"title":"b32&64encode详解","url":"/[object Object]/B32-64-encode-explanation.html","content":"\n以前只是用这些函数，从没想过这些编码的原理；还是因为一道ctf题让我好好的了解了一下这些编码方式！\n\n# 一、b32encode\n\n我们知道每个字节是8比特，b32encode将5个字节分成8块，每块前三位补0，从而将5个字节扩展为8个字节；那么扩展后的每个字节的值不超过32，与32个字符\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"对应，有时我们发现编码的字符串中还有\"=\"这个字符，但是它是填充字符，以上就是b32encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,digits\nfrom base64 import b32encode\n\ndef my_b32encode(s):\n    base=uppercase+digits[2:8]\n    assert(len(s))==5\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==40\n    sbs=[bs[5*ind:5*(ind+1)] for ind in range(8)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b32encode('BITSC')\n    print b32encode('BITSC')\n```\n\n# 二、b64encode\n\nb64encode将3个字节分成4块，每块前两位补0，从而将3个字节扩展为4个字节；那么扩展后的每个字节的值不超过64，与64个字符 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"对应，同样地，\"=\"作为填充字符，以上就是b64encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,lowercase,digits\nfrom base64 import b64encode\n\ndef my_b64encode(s):\n    base=uppercase+lowercase+digits+'+/'\n    assert len(s)==3\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==24\n    sbs=[bs[6*ind:6*(ind+1)] for ind in range(4)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b64encode('BIT')\n    print b64encode('BIT')\n```","tags":["ctf"],"categories":["crypto"]},{"title":"鲲鹏计算专场密码学部分详解","url":"/[object Object]/Kun-Peng-calculation-special-cryptography-part-of-the-detailed.html","content":"\n# 一、平平无奇的RSA\n\n## 1. 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/HUAWEI2020/task_task_gHXvFLV)\n\n## 2.分析\n\n题目由三个小问题组合而成，下面分别对他们进行分析。\n\n**Level 3**\n\n从脚本可得的信息如下：\n\n$N_{3}=p\\cdot q$，$\\phi$是$N_{3}$的欧拉函数；\n\n$s\\cdot sinv\\equiv 1\\ \\textrm{mod}\\ q$，再令$e=4s\\cdot sinv+3$(且要保证$(e,\\phi)=1$)；\n\n给你一组已知明-密文$km,kc$，即$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}$；\n\n那么分解$N_{3}$的步骤如下：\n\n$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}\\Rightarrow kc\\equiv km^{e}\\ \\textrm{mod}\\ p\\Rightarrow kc\\equiv km^{4s\\cdot sinv+3}\\ \\textrm{mod}\\ p$\n\n由欧拉定理可得：$km^{s\\cdot sinv}\\equiv km\\ \\textrm{mod}\\ p$，从而$kc\\equiv km^{4+3}\\ \\textrm{mod}\\ p$，即$kc\\equiv km^{7}\\ \\textrm{mod}\\ p$\n\n则$p|(km^{7}-kc)\\Rightarrow p=(km^{7}-kc,N_{3})$，因此$N_{3}$的一个因子是其与$km^{7}-kc$的公约数，进而分解出$N_{3}$；\n\n分解出$N_{3}$后，解密$c_{3}$得到Level 2的密文，下面分析Level 2。\n\n**Level 2**\n\n从脚本可得的信息如下：\n\n$o,s$是两个随机生成的素数，$t$是$o$的下一个素数，$u$是$s$的下一个素数；\n\n已知$os=o*s,tu=t*u$(因为$N_{2}=o*s*t*u\\Rightarrow tu=N_{2}//os$)，这道题在18年强网杯的nextrsa的第四关考察过，[此处](https://www.cnblogs.com/WangAoBo/p/8654120.html)是对其的writeup\n\n**Level 1**\n\n这一层很简单，从$(N_{1}//1323)^{1/4}$往下开始试除即可(第一次写的时候疏忽了，往上试除，程序跑了几分钟都没解出来)。\n\n# 3. 解题\n\n上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\n$ python3 solve.py\nflag{4c2fd4e6-44de-445f-8c34-1235464de2de}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"drangon2020密码学部分详解","url":"/[object Object]/Drangon-2020-Cryptography-Section.html","content":"\n# 一、Bit_Flip1\n\n## 1.1. 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon2020/bit_flip_1)\n\n## 1.2. 分析\n\n**1.过一遍程序**\n\n* 生成16个随机的字节作为alice_seed，与接收到的flip_str异或取后32个字节(不够在前面加\\x00)即为seed；\n\n* 由于alice = DiffieHellman(flip_str(alice_seed))没有设置prime，因此alice初始化时会调用get_prime()来生成素数；\n\n* 重点来看get_prime()这个函数；它不停的调用getbits(512)直到生成的数是一个素数；\n\n* 来看getbits()的原理：先调用more_bytes()积累足够的“随机”字节，每次调用more_bytes()都会在generated后面加上seed的sha256哈希值(长256比特)；\n\n* seed的更新方式为seed=long_to_bytes(bytes_to_long(seed)+1,32)，在这里简单看作seed的值增1即可；\n\n* generated收集到足够的字节之后，取后num比特作为生成的随机数，未用到的“随机”字节仍然保存在generated中；\n\n* 判断getbits(512)生成的是否为素数，若不是继续调用getbits(512)；\n\n* 得到素数之后，会告知你iter——相对于一次生成就能得到素数，对getbits(512)增加的调用次数(易知每调用一次getbits(512)，seed自增2)；\n\n* 返回prime后；调用getbits()生成64位的my_secret(DH算法的私钥)，然后计算$my\\_number\\equiv 5^{my\\_secret}\\ \\textrm{mod}\\ prime$(DH算法的公钥)，设置shared为1337后，alice的初始化工作完成。\n\nbob=DiffieHellman(urandom(16), alice.prime)按照同样的方式完成初始化工作，只不过此时bob的prime直接使用alice的prime；\n\nalice与bob经密钥协商得到双方都知道的协商密钥(与DH算法略有不同，多了一个与1337的异或操作)，该密钥作为AES的加密密钥对FLAG进行加密。\n\n**2.寻找突破**\n\n我相信程序输出的数据都是有它的作用的，print(\"bob number\", bob.my_number)给出bob的公钥是为了让我们得到prime与secret之后可以同样计算出协商密钥；输出iv与enc_flag作用也很明显；那么程序输出iter就值得注意了，一定是对我们解题有用！\n\n**3.利用iter**\n\n那么我们如何借助iter来获取足够多的信息以致于解出FLAG；iter间接体现了get_prime()调用getbits()的次数！\n\n由于程序会接收我发送的flip_str，因此我们可以改变seed的值，即使我们不知道seed的值，但是这仍然有用！\n\n既然我们不知道seed的值(是因为我们不知道alice_seed的值)，那我们记alice_seed的值为$s_{127}\\cdots s_{1}s_{0}$，我们的考虑这样的情况：\n\n我发送如下两个flip_str：\n\nflip_str_1：\n空字节\n\nflip_str_2：\n|$1$|$0$|\n|  :-:  |  :-:  |\n那么经bit_flip()就能生成如下2种seed：\n\nseed_1：\n|$s_{127}$|$\\cdots$|$s_{1}$|$s_{0}$|\n| :-: | :-: | :-: | :-: |\nseed_2：\n|$s_{127}$|$\\cdots$|$1\\oplus s_{1}$|$s_{0}$|\n| :-: | :-: | :-: | :-: |\n由这2个seed生成素数的iter分别记为iter_1与iter_2；\n\n分类讨论：\n\n* $s_{1}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{1}=1$，seed_2+2=seed_1，如果iter_2非0，必有iter_2-iter_1=1；\n\n那么当$iter\\_1\\cdot iter\\_2\\neq 0$时，由于$s_{j}$非0即1，因此此时iter_1-iter_2=1与iter_2-iter_1=1至少(没写错，确实是至少)有一个成立！此时$s_{j}=0\\Rightarrow$iter_1-iter_2=1，因此(原命题的真假性与逆否命题的真假性一致)$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$，即iter_1-iter_2=-1$\\Rightarrow s_{j}=1$。\n\n那如果$iter\\_1\\cdot iter\\_2=0$怎么办？这时根据iter_1-iter_2的值是无法判断$s_{1}$的值的！由于我们只需要保持|seed_1-seed_2|=2即可，因此我们可以改变flip_str前面的字节，这样得到的seed_x(x=1,2)的哈希值与原来显著不同，从而$iter\\_1\\cdot iter\\_2$的值有可能发生改变，不停的改变flip_str前面的字节直到$iter\\_1\\cdot iter\\_2\\neq 0$，就可以由上述分析过程解出$s_{1}$！\n\n一般地，类似于数学归纳法；假设我已经分析出$s_{j-1}\\cdots s_{1}$(这里没写错，$s_{0}$我是没有分析出来的)，借助已经得到的信息分析出$s_{j}$，思路如下：\n\n* 发送如下4种flip_str：\n\nflip_str_1：\n|$0$|$1\\oplus s_{j-1}$|$\\cdots$|$1\\oplus s_{1}$|$0$|\n|  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |\nflip_str_2：\n|$1$|$s_{j-1}$|$\\cdots$|$s_{1}$|$0$|\n|  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |\nflip_str_3：\n|$1$|$1\\oplus s_{j-1}$|$\\cdots$|$1\\oplus s_{1}$|$0$|\n|  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |\nflip_str_4：\n|$0$|$s_{j-1}$|$\\cdots$|$s_{1}$|$0$|\n|  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |\n那么经bit_flip()就能生成如下4种seed：\n\nseed_1：\n|$s_{127}$|$\\cdots$|$s_{j}$|$1$|$\\cdots$|$1$|$s_{0}$|\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: |\nseed_2：\n|$s_{127}$|$\\cdots$|$1\\oplus s_{j}$|$0$|$\\cdots$|$0$|$s_{0}$|\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: |\nseed_3：\n|$s_{127}$|$\\cdots$|$1\\oplus s_{j}$|$1$|$\\cdots$|$1$|$s_{0}$|\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: |\nseed_4：\n|$s_{127}$|$\\cdots$|$s_{j}$|$0$|$\\cdots$|$0$|$s_{0}$|\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n\n由这4个seed生成素数的iter分别记为iter_1、iter_2、iter_3与iter_4；\n\n分类讨论：\n\n* $s_{j}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{j}=1$，seed_3+2=seed_4，如果iter_3非0，必有iter_3-iter_4=1；\n\n那么当$iter\\_1\\cdot iter\\_3\\neq 0$，由于此时$s_{j}$非0即1，因此iter_1-iter_2=1与iter_3-iter_4=1必有一个成立！同样地，$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$；因此，当$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)\\neq 0$时，$iter\\_3-iter\\_4=1\\Rightarrow iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$。\n\n如果$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)=0$，同样地，改变flip_str前面的字节直到进入上述情形!\n\n综上，我给出了对$s_{1}$的分析思路，也给出了由$s_{j-1}\\cdots s_{1}$推出$s_{j}$的分析思路；最终我可以还原出alice_seed除$s_{0}$之外的所有比特位，而$s_{0}$非0即1，因此最后解出的结果与alice_seed的值相差不超过1！\n\n接下来按照同样的方式生成AES密钥，对密文进行解密即可！\n\n# 1.3. 解题\n\n这道题我并没有在比赛的时候做出来，因此我对task.py的交互方式作了一些改变；flag是自己设置的；上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\nλ python3 solve.py\nb'1\\xbc\\xfa\\x1b+5\\xed1\\x99\\xf7\\xa0\\x07\\x8e\\tQ\\xee'\nDrangon{just_for_test_flag}\n```\n\n# 二、Bit_Flip2\n\n## 2.1.题目信息\n\n附件仍然是一个Python脚本，相对于Bit_Flip1只有1行代码不同，它将print(\"bob number\", bob.my_number)这一行注释起来；[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon2020/bit_flip_2)\n\n## 2.2.分析\n\n同Bit_Flip1的方法可解出alice_seed，可此时我并不知道bob.my_number；虽然当时想过控制alice.my_secret为0，但是觉得太不切实际，而事实上writeup就是这么做的！这需要你对比特币有一定的了解，知道使用块散列算法(可[参见此处](https://www.cnblogs.com/coming1890/p/14030821.html))可以生成以一定长度的0字节结尾的哈希值。按同样的方法推测出alice_seed后发送特定的flip_str使得alice以特定的seed初始化，使得alice.my_secret为0，那么bob.my_number就对我们解密出flag无关紧要了。\n\n## 2.3.解题\n\n上述链接中的solve.py为解题脚本，同样因为题目没有在比赛的时候做出了，flag是我自己设置的；程序运行结果如下：\n\n```Bash\nλ python solve.py\nb'Drangon{just_for_test_flag}\\x00\\x00\\x00\\x00\\x00'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"i春秋\"巅峰极客\"2020密码学部分详解","url":"/[object Object]/I-Spring-and-Autumn-Peak-Geek-2020-Cryptography-in-detail.html","content":"\n# 一、tryecc\n\n## 1.1 题目信息\n\n附件是一个sage脚本与一个文本文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/iCHUNQIU2020/tryecc)在此\n\n## 1.2 分析\n\n$E_{1}: y^{2}\\equiv x^{3}+ax+c\\ \\textrm{mod}\\ N ; E_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ N$\n我们总结一下已知量和未知量：\n|      已知       |   未知    |\n| :-------------: | :-------: |\n| N,C,P1,P2,P3,P4 | A,B,m1,m2 |\n那么已知$P_{1}(x_{1},y_{1}),P_{2}(x_{2},y_{2})$就可以计算出$a,b$：\n$\ny_{1}^{2}\\equiv x_{1}^{3}+a\\cdot x_{1}+c\\ \\textrm{mod}\\ N \\\\\ny_{2}^{2}\\equiv x_{2}^{3}+a\\cdot x_{2}+b\\ \\textrm{mod}\\ N \\\\\na=[y_{1}^{2}-x_{1}^{3}-c]\\cdot x_{1}^{-1}\\ \\textrm{mod}\\ N \\\\\nb=y_{2}^{2}-x_{2}^{3}-a\\cdot x_{2}\\ \\textrm{mod}\\ N \\\\\n$\n\n好在$x_{1}$在模$N$下有逆，于是$a,b$就可以解出，到此得到了$E_{1},E_{2}$；\n\n$P_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2},P_{4}=m_{2}\\cdot P_{2}\\ in\\ E_{2}$\n\n丢到sgae里面去解离散对数，结果发现解不出来！\n\n但是发现N不是素数，用yafu分解一下N，发现N是两个素数的乘积，记为$N=p\\cdot q$，那么椭圆曲线$E_{2}$可重写为\n$E_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\\cdot q$，这样$E_{2}$上的点也满足下面两个等式：\n$\nE_{p}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p \\\\\nE_{q}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ q\n$\n\n即$E_{2}$上的点同时在$E_{p}$与$E_{q}$上(试了一下，我们可以求解$P_{3},P_{4}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数)\n$P_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}$ 则有\n$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{p} \\\\\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{q}\n$\n\n那是不是意味着我们解出$P_{3}$在椭圆曲线$E_{p}$上关于基点$P_{2}$的离散对数就是$m_{1}$呢？非也！我们解出的只是$m_{1}\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})$，即$m_{1}$模了$P_{2}$在椭圆曲线$E_{p}$上的阶之后的值！\n\n要想解出$M_{1}$，需要将$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数结合起来！\n$\nm_{1}\\equiv s_{p}(1)\\ \\textrm{mod}\\ order_{E_{p}}(P_{2}) \\\\\nm_{1}\\equiv s_{q}(1)\\ \\textrm{mod}\\ order_{E_{q}}(P_{2})\n$\n这里$s_{p}(1),s_{q}(1)$分别是$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数；\n\n使用中国剩余定理解上述方程组即可解出$m_{1}$，同理解出$m_{2}$\n\n## 1.3 解题\n\n上述链接中的solve.sage为解题的脚本；程序运行结果如下(运行时间有点长，稍微等一下)：\n\n```Bash\n$ sage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{de7a89ab1d074ef3930fb3054c0e3ac8}\n```\n\n# 后记\n\n一直在等师傅们关于密码学题目的writeup，结果一直没有找到；就只能把自己唯一做出来的一道题目的writeup写一下。","tags":["ctf"],"categories":["crypto"]},{"title":"GACTF2020密码学部分详解","url":"/[object Object]/GACTF2020-Cryptography-Section.html","content":"\n##前言\n\n比赛网址：[GACTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=147&hash=cf494a33-0f22-4e85-a48d-7a02efeedc90.event)\n[writeup参考链接](https://0xdktb.top/2020/08/30/WriteUp-GACTF2020-Crypto/)\n\n# 一、ezAES\n\n## 1.1. 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/ezAES)的challeng.py。\n\n## 1.2. 分析\n\n整体浏览Python脚本后，可得此题考察CBC分组加密工作模式；总结一下脚本给出的信息：\n* key给出前14位(key长16位，即最后2位未知)\n* message的长度为86字节，因此明文最后一组填充10个'\\n'\n* 密文最后一组给出后10个字节\n\n因此，可穷举key的最后2位，每一位考虑所有可打印字符，有100种可能，因此穷举key的最后2位有$10^{4}$种可能，处于合理范围；对每一个key，解密最后一组密文，将解密出的明文后10位与上一组密文后10位异或，若异或后均为'\\n'，则说明穷举出正确的key；\n解出正确的key之后，可按照同样的方式计算出SECRET，从而获取整个明文；\n已知所有明文之后，由CBC工作模式：$m_{i}=D(c_{i};key)\\oplus c_{i-1},i=n,\\cdots,1$，其中$c_{0}=IV$，那么已知最后一组密文，就可以递推出IV：$c_{i-1}=D(c_{i};key)\\oplus m_{i},i=n,\\cdots,1$\n\n## 1.3. 解题\n\n上述链接中的solve.py为解题的Python脚本；\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n[+] MBruteforcing: Found key: \"pd\"\n9j_for_aes_cbc!!\n```\n\n# 二、what_r_the_noise\n\n## 2.1. 题目信息\n\n噪音太大，听不见，China:124.71.145.165:9999(现在应该已经失效了)。\n\n## 2.2. 分析\n\n大致意思是服务器返回的数据是加入了噪声的，让你去掉噪声，解出正确的明文；有点概率论知识应该想到获取多次数据取平均值。\n\n## 2.3. 解题\n\n解题的Python脚本在[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/what_r_the_noise)中；\n\n解出的flag可能不完全正确，但是你基本可以猜出是什么单词了！\n\n最后得到flag为gactf{you_know_much_about_differential_privacy}\n\n# 三、da Vinci after rsa\n\n## 3.1. 题目信息\n\n附件中包含两个文本文件encryption与output；encryption中是一列数，output给出“RSA公钥”与密文；[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/da_Vinci_after_rsa)\n\n## 3.2. 分析\n\nda Vinci翻译了一下(英语不好)是达芬奇，这既然是密码学题目，自然去查了一下达芬奇密码，发现这是一本书，在网上不停地查这本书，找到一个片段，“打乱的数字”一下引起我的注意，后面马上提到“斐波那契数列”，回去一看，encryption中的那一列数确实是打乱的斐波那契数列，到此encryption的作用弄明白了；\n\n接下来将公钥的模数N放到yafu中分解，得到三个因子；但是我想，不怕，和RSA问题一样求解$d\\equiv e^{-1}\\ \\textrm{mod}\\ \\phi(N)$即可解出$m\\equiv c^{d}\\ \\textrm{mod}\\ N$，编好程序运行时发现$e$在$\\phi(N)$下没有逆，这一下子就不知道怎么办了，其实这样的方程也是有办法求解的，[求解思路链接在此](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n解出的$m$虽然有多个，但是flag每个字符都是可见字符，这样最后只剩下一个$m$，这还不是flag；花括号内正好25个字符，encryption中正好25个数，按照一样的规则打乱花括号内的25个字符即得到真正的flag；\n\n## 3.3. 解题\n\n上述GitHub备份链接中的solve.sage脚本为解题的sage脚本；\n\n程序运行结果如下：\n\n```Bash\n$ sage solve.sage\nflag{w5awd4fa994f87_dwad3123_2}\n```\n\n# 四、elgamal_rsa\n\n## 4.1. 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/elgamal_rsa)\n\n## 4.2. 分析\n\n$g^{q}\\equiv 1\\ \\textrm{mod}\\ p,h\\equiv g^{d}\\ \\textrm{mod}\\ p$\n\n$c_{1}\\equiv g^{r_{1}}\\ \\textrm{mod}\\ p,c_{2}\\equiv m\\cdot h^{r_{1}}\\ \\textrm{mod}\\ p$\n\n$c_{11}\\equiv g^{r_{2}}\\ \\textrm{mod}\\ p,c_{22}\\equiv m\\cdot h^{r_{2}}\\ \\textrm{mod}\\ p$\n\n其中，$r_{2}\\equiv (B\\cdot r_{1}+A)\\ \\textrm{mod}\\ q$\n\n这里的$m$就是$secret$，$secret$是下面“RSA”加密的模数，因此首先要解出$secret$，这也是很好解的；\n\n$c_{2}^{B}\\cdot h^{A}\\equiv (m\\cdot h^{r_{1}})^{B}\\cdot h^{A}\\equiv m^{B}\\cdot h^{B\\cdot r_{1}+A}\\equiv m^{B-1}\\cdot c_{22}\\ \\textrm{mod}\\ p$\n\n$m^{B-1}\\equiv c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1}\\ \\textrm{mod}\\ p$，计算$t\\equiv (B-1)^{-1}\\ \\textrm{mod}\\ (p-1)$\n\n那么$(c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1})^{t}\\equiv m\\ \\textrm{mod}\\ p$\n\n解出$secret$后，放到yafu里面分解(因子是真的多，一度怀疑自己解错了)，[求解flag的思路链接](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n## 4.3. 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出secret；第二步，求解方程$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但是$(e,\\phi(N))>1$)；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n329380824451982777596468080979390700896875051159309053251427777390225223390054462862874890632092714850180031743329031313028975903871751004003831036860000454098274963081490031808010876171935539110201531253322208564941373067673598629247111527738724700328114569409692796434368030258427126193825227856160081569366870307559297674909108870298864572520476006338972072593434914773857347865349086098662711283463352902488164071184362082990162654586995346553108747183805073294471613391819978413596510467204977114038549473397779377039088475929677184284430986636686769839308217865627271293739711926018699557041530631349486791876338842184994986024157099233298972714917732995013317087756483\n```\n\n```Bash\n$ sage step2.sage\nyou_4re_good_at_b0th_el94mal_and_rs4\n```\n\n# 五、babycrypto\n\n## 5.1. 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/babycrypto)\n\n## 5.2. 分析\n\n在GF(p)上定义的点集$\\{(x,y)|x,y\\in GF(p)\\}$上定义加法\"+\"：$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}x_{2}-y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})$，定义乘法\"$\\cdot$\"：$k\\cdot (x,y)=(x,y)+\\cdots +(x,y)$\n\n给出基点g，$A=a\\cdot g,B=b\\cdot g$，给出A,B；\n\n$shared=b\\cdot A$，再利用shared生成AES密钥进行加密；\n\np未知！！！先介绍Edwards曲线E：$x^{2}+y^{2}\\equiv 1+dx^{2}y^{2}\\ \\textrm{mod}\\ p$，曲线上的加法定义为$(x_{1},y_{1})+(x_{2},y_{2})=((x_{1}y_{2}+x_{2}y_{1})/(1+dx_{1}x_{2}y_{1}y_{2}),(x_{1}x_{2}-y_{1}y_{2})/(1-dx_{1}x_{2}y_{1}y_{2}))$\n\n令d=0，则E：$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，则加法重写为$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}y_{2}+x_{2}y_{1},x_{1}x_{2}-y_{1}y_{2})$\n\n若我们设定d=0，那么$A(x_{1},y_{1}),B(x_{2},y_{2})$满足方程$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，求$x_{1}^{2}+y_{1}^{2}-1$与$x_{2}^{2}+y_{2}^{2}-1$的公约数，则p是其最大素因子；\n\n下面考虑如何解出b，这是一个离散对数问题，难点是sage并未实现Edwards曲线及其运算；\n\n给出一个有用的结论：$\\{(x,y)|x,y\\in GF(p),x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p\\}$与$H=F_{p}(w)/(w^{2}+1)$(有限域$F_{p}$上的多项式在模$w^{2}+1$下的剩余环)同构，同构映射$\\sigma :E\\rightarrow H$，$\\sigma((x,y))=x+yw$\n\n在sage中通过extend函数就可以生成H，从而可以求解此离散对数问题；\n\n## 5.3. 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出p；第二步，解出b然后以同样的方式生成AES密钥再对消息进行解密；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n435393448000740628395634230535241428961470055780764193459123534837759996\n```\n\n使用yafu分解，可得到p(在solve.sage中有给出)\n\n```Bash\n$ sage solve.sage\ngactf{354b6ce4c03387a828a3c30061213204}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"WMCTF2020密码学部分详解","url":"/[object Object]/WMCTF2020-Cryptography-Part-Detail.html","content":"\n比赛网址：[WMCTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=146&hash=684a58cc-1140-4937-99f2-ef347d777d9f.event)\n\n# 一、piece_of_cake\n\n## 1. 题目信息\n附件是一个py脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF2020/piece_of_cake)中的task.py。\n\n## 2. 分析\n\neat_cake函数中的各个变量的定义如下：\n\n* $p,q$为512位随机素数，$ph=(p-1) \\cdot (q+1),N=p \\cdot q,d=e^{-1}\\ \\textrm{mod}\\ ph$\n\n* $cake$为768位随机素数，$q$重新赋值为1536位随机素数，将$d$的值赋给$f$，$g$为随机素数，$g$的位数等于$q$的位数减去$f$的位数再减去1\n\n* $h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$，$r$为512位随机素数，$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n由$h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$可得$f \\cdot h \\equiv g\\ \\textrm{mod}\\ q$，记为$f \\cdot h-t \\cdot q=g$，构造矩阵\n$$\nM=\\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix}\n$$\n则有\n$$\n\\begin{pmatrix}\nf & -t\n\\end{pmatrix} \\cdot \\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix} = \\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$$\n则$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$是格$L(M)$上的短格基，因此有可能可使用LLL算法或BKZ算法求出，这里说有可能求出，因为在解题时并不是每次都能找到短格基$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$\n假设我们求出的短格基为$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$，再由公式$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n则\n\n$f \\cdot c \\equiv f \\cdot (r \\cdot h+cake) \\equiv (r \\cdot g+f \\cdot cake)\\ \\textrm{mod}\\ q$\n\n从而\n\n$(r \\cdot g+f \\cdot cake)= f \\cdot c\\ \\textrm{mod}\\ q$\n\n两边模$g$可得\n\n$f \\cdot cake \\equiv (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g$\n\n于是\n\n$cake=f^{-1} \\cdot (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g$\n\n注意，上面等式中$f^{-1}$是$f$在$g$下的逆，不能与括号内的$f$抵消。\n\n## 3. 解题\n\n上述链接中的solve.sage为解题的sage脚本。\n\n## 4. 备注\n\n此exp并不能保证次次成功！不过它的有效性不可否认，上述链接中的test.sage即可验证。\n\n以下是我对test.sage四次的运行结果：\n\n```Bash\n$ sage test.sage\nsuccess! 48 -th\n$ sage test.sage\nsuccess! 2 -th\n$ sage test.sage\nsuccess! 50 -th\n$ sage test.sage\nsuccess! 24 -th\n```\n\n从而验证了解题脚本solve.sage的有效性。\n\n# 二、babySum\n\n## 1. 题目信息\n\n附件是两个py脚本与一个json文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF2020/babySum)中的task.py与check.py。\n\n## 2. 分析\n\ntask.py告诉我们生成data中数据的逻辑，其实很好理解：生成$n=120$个150位的随机数，组成数组$A$，从中选$k=20$个相加生成和$s$；\n\n记数组$A=[a_{1},\\cdots,a_{n}]$，check.py读入120个数$b_{1},\\cdots,b_{n}(b_{i}={0,1})$，其中20个为1，另外100个为1，检验$\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$，如果等式成立，就打印出flag。\n\n到这里我们共有3个约束条件：\n* $\\sum_{i=1}^{n}b_{i}=k$\n* $\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$\n* $b_{i}=0,1;i=1,\\cdots,n$\n\n遇到这种问题一般转化为格基约减问题，构造矩阵$\n\\begin{pmatrix}\n1 &   &   &   & a_{1} & 1 \\\\\n  & 1 &   &   & a_{2} & 1 \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & a_{n} & 1 \\\\\n  &   &   &   & -s & -k &\n\\end{pmatrix}=M\n$\n\n那么$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n即通过格基约减可以求出$b_{1},\\cdots,b_{n}$。\n\n理想很丰满，现实很骨感！\n\n约减后的格基无法达到我们需要的结果！直到看到writeup，这里需要记住一个很有用的技巧，可类比约束优化问题对约束条件的处理，当不满足约束条件$\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\n\\end{cases}\n$时加大“惩罚”，我们重新设计格基矩阵$M$为$\n\\begin{pmatrix}\n1 &   &   &   & N \\cdot a_{1} & N \\\\\n  & 1 &   &   & N \\cdot a_{2} & N \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & N \\cdot a_{n} & N \\\\\n  &   &   &   & -N \\cdot s & -N \\cdot k &\n\\end{pmatrix}\n$\n其中$N=[\\sqrt{n}]$，\n此时仍然有$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n然后就是比较玄学的问题，对同一格，改变格基矩阵行的顺序，约减的结果也会不同，官方的writeup就是不断打乱格基矩阵的行，然后进行格基约减；再就是为了更快得到结果，需要进行多线程编程；上述链接中的solve.sage为解题的sage脚本；官方设置的8个线程，我自己改成6个线程，跑了几次，基本上都是20分钟左右出结果。\n\n```Bash\n$ sage solve.sage   \n(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)\ncost time:  0:25:27\n```","tags":["ctf"],"categories":["crypto"]},{"title":"git基础使用&gitee","url":"/[object Object]/The-basic-Git-use-with-Gitee.html","content":"\n# 1. 在网站上初始化\n\n在[码云](https://gitee.com/)上创建项目基本是傻瓜式操作。创建一个名为git-test的私有项目以备后续使用。\n\n本文介绍在本地创建仓库、将仓库上传至服务器以及本地与服务器的交互。\n\n# 2. 在本地创建仓库及相关操作\n\n```Bash\n# 初始化一个Git仓库，则执行命令的目录会作为一个仓库\nmkdir /home/gitee/git-test && cd /home/gitee/git-test\ngit init\n# 那么git-test文件夹将会作为一个仓库\n# 新建一个文件然后将文件添加到Git的暂存区\necho 'Life is beautiful' > README.md && git add \"README.md\"\n# 查看仓库当前文件提交状态(A：提交成功；AM：文件在添加到缓存之后又有改动)\ngit status -s\n# 从Git的暂存区提交版本到仓库，参数-m后为当次提交的备注信息\ngit commit -m \"1.0.0\"\n```\n\n# 3. 本地与服务器的交互\n\n在本地与服务器交互之前，先配置ssh公钥；保证已经安装了ssh(apt install -y ssh)，使用ssh-keygen生成ssh公钥：\n```Bash\ngit config --global user.email 'gitee注册邮箱'\ngit config --global user.name 'gitee用户名'\nssh-keygen -t rsa\n```\n在~/.ssh目录下有一个id_rsa.pub文件，里面的文本以ssh-rsa开头，将这些文本全部复制，转到设置->安全设置->ssh公钥，随便写个标题，将id_rsa.pub中的文本全部复制到公钥下面的框内。\n\n关于项目的ssh地址如何获得，见下图：\n\n{% asset_img 1.png pic1 %}\n\n下面介绍一些本地与服务器的常用交互\n```Bash\n# 在不执行克隆操作时将一个远程仓库添加到本地的仓库\ngit remote add origin ssh地址\n# 如果不需要远程的更新，比如此时远程只是一般性的初始化内容，可使用-f选项进行强制推送(远程仓库默认名为origin)\ngit push origin master -f\n# 克隆服务器中的项目(即在1中新建的名为git-test的项目)到本地\ngit clone ssh地址\n## 文件修改(本地)\n# 修改文件README.md，在文件后面追加一行'local change'\n# 此时查看状态\ngit status -s\n#先将文件添加到Git的暂存区，然后提交\ngit add 'README.md' && git commit -m '1.0.1'\n# 用本地仓库内容更新远程仓库内容\ngit push ssh地址\n# 刷新网站，可以看到服务器上面的内容已经与本地一致\n\n## 文件添加(本地)\n# 创建一个输出hello,world的C文件并将其编译\necho -e '#include <stdio.h>\\n\\nint main()\\n{\\n\\tprintf(\"hello,world\\\\n\");\\n\\treturn 0;\\n}' > hello.c && gcc hello.c -o hello -g\n# 先将新增的文件添加到Git的暂存区\ngit add he*\n# 这里可以查看一下状态\ngit status -s\n# 从Git的暂存区提交版本到仓库\ngit commit -m '1.0.2'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上已经有新增的文件\n\n## 文件移动(本地)\n# 为增强项目文件的组织性，我将上述的两个新增文件移到一个文件夹中\nmkdir Hello && git mv he* Hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.3'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上原来新增的两个文件已经在新建的文件夹下\n\n## 文件删除(本地)\n# 如我要将hello这个可执行文件删除\ngit rm Hello/hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.4'\n# 将更改同步到远程服务器\ngit push ssh地址\n\n# 如果是在网站上对项目做出更改(文件修改、添加、移动与删除)，要将更改同步回本地(即拉取)，使用pull命令\ngit pull origin master\n```\n以上基本上包含了使用git常见问题的解决方案。","tags":["git"],"categories":["tech"]},{"title":"Ubuntu安装metasploit-framework(方便安全可秒全网现有各种方法)","url":"/[object Object]/Ubuntu-Installs-Metasploit-Framework-Easy-Secure-Instable.html","content":"\n# 前言\n\n做项目需要用到metasploit-framework这款强大的渗透工具，学长给的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)下载起来巨慢，重新在网上找方法：网上几乎都是添加Kali源来安装metasploit-framework，但是自己手残在apt update后加了一条apt upgrade -y，然后电脑开始下很多奇奇怪怪的东西直到电脑完全动不了，最后只能重装Ubuntu！所以总结一下网上在Ubuntu安装metasploit-framework的两种方法要么慢，要么危险。\n\n# deb包安装\n\n推荐一种安全又快捷的方法，使用deb包进行安装：[deb包链接在此](https://apt.metasploit.com/)；翻到最下面，可以看到有metasploit-framework的deb包\n\n\n\n选择最新版的下载下来，使用gdebi来安装deb包即可\n```Bash\nsudo gdebi metasploit-framework_6.0.13+20201023102229~1rapid7-1_amd64.deb\n```\n可以看看安装好的效果：\n\n\n# 后记\n\n我来说一下上面的deb包链接是怎么找到的；从上述的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)开始，下面的Installing\n\n\n点击the free installer,再到下面的Linux manual installation\n\n\nhttps://apt.metasploit.com 就是deb包的链接。","tags":["Ubuntu","msf"],"categories":["conf"]},{"title":"return2libc实验","url":"/[object Object]/Return2libc-experiment.html","content":"\n首先，[实验程序GitHub链接](https://github.com/coderall/return-to-libc-attack)\n注：实验环境为Ubuntu16.04的32位虚拟机(virtualbox)\n\n# 1. 预备工作\n关闭地址随机化，否则攻击失败\n```Bash\nsudo sysctl -w kernel.randomize_va_space=0\n```\n{% asset_img 1.png pic1 %}\n\n# 2. 任务1——查找libc函数的地址\n编译retlib.c，设置-fno-stack-protector关闭ubuntu上StackGuard保护机制，设置-z -execstack/noexecstack可打开或关闭可执行栈的机制，使用gdb来获取当前system()与exit()的地址\n```Bash\nsudo gcc retlib.c -fno-stack-protector -z noexecstack -o retlib -g\nsudo chmod 4755 retlib\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np system\np exit\nq\n```\n{% asset_img 2.png pic2 %}\n\n我们可以看到system()函数的地址是0xb7e43da0，exit()函数的地址是0xb7e379d0，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 3.png pic3 %}\n\n改完之后：\n\n{% asset_img 4.png pic4 %}\n\n# 3. 任务2——将shell字符串放入内存中\n创建环境变量MYSH来记录/bin/sh路径，编译getenv.c，运行getenv程序获取/bin/sh的地址\n```Bash\nexport MYSH=\"/bin/sh\"\ngcc getenv.c -z noexecstack -o getenv -g\n./getenv MYSH ./retlib\n```\n{% asset_img 5.png pic5 %}\n\n可以看到/bin/sh的地址为0xbffffe41，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 6.png pic6 %}\n\n改完之后：\n\n{% asset_img 7.png pic7 %}\n\n# 4. 任务3——找出栈溢出地址相对buffer的偏移\n\n下面我们介绍  *(long *) &buf[24] = 0xb7e5f430 ;   //  system()  中的24是怎么得到的；\n首先你应该对return to libc的原理有一定了解(不了解先参见[此处](https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/index.html))(原理看完就可以回来了，实验部分这里讲得更清楚^_^)\n这里的24就是栈溢出地址相对buffer的偏移；一种有用的办法是这样做的：生成较长的由a-zA-Z组成的随机字符串(比如我生成长100的这样的字符串)，将它写入badfile文件，然后用gdb调试retlib程序；\nrand.py程序如下：\n```Python\nfrom string import ascii_letters as al\nfrom random import randint\n\nX=[randint(0,51) for _ in range(100)]\nprint ''.join([al[x] for x in X])\n```\n\n```Bash\npython rand.py >> badfile\ngdb -q retlib\n#进入gdb命令行\nr\n```\n\n{% asset_img 8.png pic8 %}\n\n不用设置断点，直接运行然后会发生栈溢出错误，并且告诉你栈溢出的地址，在我调试的过程中，栈溢出的地址为0x4a4c4e49，把这个地址转换为字符串并反转是INLJ(之所以要反转是因为地址的表示为大端表示)，INLJ在上述生成的随机字符串中的索引就是24，说明栈溢出地址相对buffer的偏移为24；\n\n# 5. 任务4——利用缓冲区溢出漏洞\n编译exploit.c，攻击，进入/bin/sh程序\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n{% asset_img 9.png pic9 %}\n\n# 6. 任务5——增加调用setuid进行提权\n首先按照同样的方式获取setuid()函数的地址，然后更改程序exploit.c；\n```Bash\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np setuid\nq\n```\n{% asset_img 10.png pic10 %}\n\n可以看到setuid()函数的地址为0xb7eba2e0，使用上述得到的地址更改程序exploit.c，改完之后：\n\n{% asset_img 11.png pic11 %}\n\n重新编译exploit.c然后进行攻击(如果攻击失败，尝试：重启->关闭地址随机化->export MYSH=\"/bin/sh\"，然后重新执行下面三行命令)\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n攻击结果如下：\n{% asset_img 12.png pic12 %}","tags":["ret2libc"],"categories":["tech"]},{"title":"Makefile初探","url":"/[object Object]/The-Makefile-que.html","content":"\n# 1. 背景\n\n如果做过工程，或者读过一些优秀的开源代码的话；了解.c文件需要分开写，每个.c文件实现特定的一小部分功能，另外还有一些.h文件，这种文件主要引用一些头文件，声明一些函数(虽然函数可以直接定义无需声明，但是先声明再定义是一个好习惯，另外一些虚函数是仅仅声明而不定义的)与宏；这些.c文件再被不同的目录组织；以上就是工程一般的框架，这些.c文件既可能依赖.h文件，也可能依赖其他.c文件，单单一行gcc的编译命令已经解决不了，这时需要Makefile来指导编译过程！\n\n# 2. 语法规则\n\n目标文件：依赖文件\n|tab|编译规则\n\n注：|tab|代表一个tab键\n\n# 3. demo\n\n我的文件组织如下：\n```Bash\n.\n├── include\n│   └── head.h\n├── Makefile\n└── src\n    ├── add.c\n    ├── div.c\n    ├── master.c\n    ├── mul.c\n    └── sub.c\n```\n\nhead.h的代码如下：\n```C\n#include <stdio.h>\n\nint add(int a,int b);\n\nint sub(int a,int b);\n\nlong mul(long a,long b);\n\nfloat div(float a,float b);\n```\n\nadd.c的代码如下：\n```C\n#include \"head.h\"\n\nint add(int a,int b)\n{\n\treturn a+b;\n}\n```\n差不多这个意思，其他的代码就自己完善吧；\n\n最后master.c代码如下：\n```C\n#include \"head.h\"\n\nint main()\n{\n\tint a,b;\n\ta=12;\n\tb=3;\n\tprintf(\"%d add %d = %d\\n\",a,b,add(a,b));\n\tprintf(\"%d sub %d = %d\\n\",a,b,sub(a,b));\n\tlong ma,mb;\n\tma=12;\n\tmb=3;\n\tprintf(\"%ld mul %ld = %ld\\n\",ma,mb,mul(ma,mb));\n\tfloat fa,fb;\n\tfa=12;\n\tfb=3;\n\tprintf(\"%f div %f = %f\\n\",fa,fb,div(fa,fb));\n\treturn 0;\n}\n```\n\n下面是Makefile文件：\n```Makefile\nmaster:rely1.o rely2.o rely3.o rely4.o rely5.o\n\tgcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nrely1.o: src/master.c include/head.h\n\tgcc -c -I include src/master.c -o src/master.o\nrely2.o: src/add.c include/head.h\n\tgcc -c -I include src/add.c -o src/add.o\nrely3.o: src/sub.c include/head.h\n\tgcc -c -I include src/sub.c -o src/sub.o\nrely4.o: src/mul.c include/head.h\n\tgcc -c -I include src/mul.c -o src/mul.o\nrely5.o: src/div.c include/head.h\n\tgcc -c -I include src/div.c -o src/div.o\n.PHONY:clean\nclean:\n\tfind . -name '*.o'  | xargs rm -f\n```\n\n下面make生成可执行文件：\n```Bash\n$ make && make clean\ngcc -c -I include src/master.c -o src/master.o\ngcc -c -I include src/add.c -o src/add.o\ngcc -c -I include src/sub.c -o src/sub.o\ngcc -c -I include src/mul.c -o src/mul.o\ngcc -c -I include src/div.c -o src/div.o\ngcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nfind . -name '*.o'  | xargs rm -f\n```\n\nmake clean会执行Makefile文件中clean下的命令，它会清除所有的目标文件(.o文件)，因为已经不需要了！\n\n我们测试一下可执行文件是否正确执行：\n```Bash\n$ ./master\n12 add 3 = 15\n12 sub 3 = 9\n12 mul 3 = 36\n12.000000 div 3.000000 = 4.000000\n```\n\n注：可以看到Makefile中的rely1.o等等只是代号，真正目标文件的名称设定由编译规则指定。","tags":["makefile"],"categories":["tech"]},{"title":"ctf密码学常用python库","url":"/[object Object]/CTF-cryptography-uses-Python-libraries.html","content":"\n# 1. pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n这个库是实现各种算法和协议的密码模块的集合，包含Cipher，Hash，Protocol，PublicKey，Signature，Util这些子包；\n\n## 1.1. Cipher子包\n\n实现了分组加密(AES，DES，DES3，CAST，Blowfish，RC2)，流加密(RC4，XOR)与公钥加密(RSA PKCS#1与PKCS#1 OAEP，这两个区别在于加密前对数据的填充不同)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nkey = b'Sixteen byte key'\niv = Random.new().read(AES.block_size)\ncipher = AES.new(key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\nprint msg.encode('hex')\n```\n\n有时在解RSA的题时，已经知道了密钥，解出来的flag却是乱码，也许是加了一些填充如OAEP，PKCS#1导致的；这时就需要使用对应的秘钥解密；如下是一个PKCS#1填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度-11\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom gmpy2 import invert\nfrom base64 import b64decode\n\ncip='bT633yPu4dOHEL66eKCHjg6cZb09CElt2mSSQZkRDHk='\n\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461L\ne=65537L\n#http://factordb.com/\np=275127860351348928173285174381581152299L\nq=319576316814478949870590164193048041239L\nphi=(p-1)*(q-1)\nd=invert(e,phi)\n\nprivkey=RSA.construct((n,e,long(d),p,q))\n\n#原生RSA\nprint privkey.decrypt(b64decode(cip))\n\n#PKCS#1填充\nkey= PKCS1_v1_5.new(privkey)\nprint key.decrypt(b64decode(cip),'')\n```\n\n再举个OAEP填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度减去41；你可以试一下在下面代码中的明文中多加一个字符运行就会报错。\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom base64 import b64encode,b64decode\n\nrsa_key=RSA.generate(1024)\nkey=PKCS1_OAEP.new(rsa_key)\ncip=b64encode(key.encrypt('PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}abcdef'))\nprint cip\n\nmsg=key.decrypt(b64decode(cip))\nprint msg\n```\n\n## 1.2. Hash子包\n\n实现了哈希算法(MD2，MD4，MD5，RIPEMD，SHA，SHA224，SHA256，SHA384，SHA512，HMAC，hashalgo)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Hash import MD2\nh = MD2.new()\nh.update(b'Hello')\nprint h.hexdigest()\n```\n\n但是没有实现SHA1，要使用SHA1，需要导入hashlib库，正好验证一下Google之前给出的求得两个 sha1 值一样的pdf对：https://shattered.io/\n\n```Python\nfrom hashlib import sha1\n\nwith open('shattered-1.pdf','rb') as f1:\n    da1=f1.read()\nwith open('shattered-2.pdf','rb') as f2:\n    da2=f2.read()\n\nprint sha1(da1).hexdigest()\nprint sha1(da2).hexdigest()\n```\n\n## 1.3. PublicKey子包\n\n实现了公钥加密和签名算法(RSA，DSA，ElGamal)；文档给出的例子：\n\n```Python\nfrom Crypto.PublicKey import RSA\nkey0 = RSA.generate(2048)\nwith open('mykey.pem','w') as f:\n    f.write(key0.exportKey('PEM'))\n\nwith open('mykey.pem','r') as g:\n    key = RSA.importKey(g.read())\n```\n\n## 1.4. Util子包\n\n实现了各种有用的模块和功能(Util.number：数论函数，Util.randpool：随机数生成，Util.RFC1751：在128位键和可读的字串之间进行转换，Util.asn1：对ASN.1 DER编码的最小支持)；自己写个例子如下：\n\n```Python\nfrom Crypto.Util import number\ns='this is a demo'\n#字节转换为long型整数\nls=number.bytes_to_long(s)\n\nbits=8*len(s)\n#生成长度为bits的素数\ngp=number.getPrime(bits)\n\n#生成长度小于bits的随机数\ngri=number.getRandomInteger(bits)\n \n#生成长度为bits的随机数\ngrnbi=number.getRandomNBitInteger(bits)\n \n#生成长度不超过bits的随机数\ngrn=number.getRandomNumber(bits)\n \n#生成grn与2*grn之间的随机数\ngrr=number.getRandomRange(grn,2*grn)\n\n#生成强的素数（gsp-1，gsp+1均至少具有一个大的素因子）\ngsp=number.getStrongPrime(1024)\n\n#计算gri在模grn下的逆\niin=number.inverse(gri,grn)\n\n#判断iin是否为素数\nip=number.isPrime(iin)\n\n#long型整数转换为字节\ntb=number.long_to_bytes(ls)\n```\n\n由于这个库很多函数都很有用，因此我们直接使用\n```Python\nfrom Crypto.Util.number import *\n```\n来导入这个包的所有函数。\n\n# 2. pwntools库\n\n```Bash\npip3 install pwntools -i https://pypi.douban.com/simple\n```\n\n这个库内容很多，只介绍比赛中用到的。\n\n## 2.1. mbruteforce函数\n\n多线程穷举函数，详细定义如下：mbruteforce(func, alphabet, length, method='upto', start=None, threads=None)，其中，\n* func输入参数为字符串，输出布尔值，mbruteforce穷举直到func输出True；\n* alphabet为组成输入参数字符串的字符集合；\n* length指定输入参数字符串的长度上界；\n* method默认为'upto'，指定穷举的字符串长度从1增大到length；另外两个选项为'fixed'、'downfrom'，fixed'指定穷举的字符串长度仅为ength，'downfrom'指定穷举的字符串长度从length减小到1；\n* start=(N,i)，就是把搜索空间分成N块从第i块开始穷举；默认为(1,1)\n* threads指定穷举时的线程数，默认值是内核的数量；\n\n举个例子：\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\nmbruteforce(lambda x: x == 'hello','helo',5,method='fixed')\n```\n\n## 2.2. remote类\n\n用来与服务器交互；常用函数的用法注释到如下脚本中。\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\n\n#创建到远程主机的TCP或udp连接，主机为cn.bing.com，连接主机的端口为443\n#ssl=True代表用SSL包装套接字\nr=remote('cn.bing.com',443,ssl=True)\n\n#向主机发送数据，只不过数据只能是一行\nr.sendline('GET /')\n\n#向主机发送数据，数据可以是多行\nr.send(b'\\r\\n\\r\\n')\n\n##上面两行代码等价于r.send(b'GET /\\r\\n\\r\\n')\n\n#从主机接收4个字节的数据\nre=r.recvn(4)\nprint re\n\n#从主机一直接收数据直到'Please'出现\nre=r.recvuntil('Please')\nprint re\n\n#从主机一直接收数据，最多接收4096字节\nre=r.recv()\nprint re\n\n#关闭连接\nr.close()\n```","tags":["ctf","python"],"categories":["tech"]},{"title":"RSA攻击大全及其实现","url":"/[object Object]/RSA-attack-Daquo-and-its-implementation.html","content":"\n# 一、RSA攻击大全\n\n## 1. 模数分解\n\n* Small q：模数N有小素数因子；\n* fermat：模数N的因子p与q非常接近；\n* 模不互素：给出多组公钥，但是其中的模数共用了素因子；\n\n## 2. 针对指数进行攻击\n\n* 小公钥指数攻击：指数很小；\n* 低加密指数广播攻击：相同的消息发送给多个接收者，且加密指数较低；\n\n## 3. 针对私钥进行攻击\n\n* 维纳攻击：指数很大(理论上$d<N^{0.25}$此攻击起作用)；\n* Boneh-Durfee攻击：同样针对指数很大的情形，理论上$d<N^{0.29}$此攻击起作用；\n\n## 4. Coppersmith相关攻击\n\nCoppersmith算法用于求解模$N$多项式$F(X)$($X$为单变量、二元变量甚至多元变量)所有小整数根($\\big\\|X\\big\\|<cN^{\\beta^{2}/\\delta}$，其中$\\delta$为多项式$F$的次数，假设$N$具有不小于$N^{\\beta}$的因子)\n\n* 明文高位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其高位$m_{b} \\cdots m_{t+1}$泄露，记$m'=m_{b} \\cdots m_{t+1}0 \\cdots 0$，则$m'$已知，但$\\Delta m=m_{t} \\cdots m_{1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其高位$p_{b} \\cdots p_{t+1}$泄露，记$p'=p_{b} \\cdots p_{t+1}0 \\cdots 0$，则$p'$已知，但$\\Delta p=p_{t} \\cdots p_{1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 明文低位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其低位$m_{t} \\cdots m_{1}$泄露，记$m'=m_{t} \\cdots m_{1}$，则$m'$已知，但$\\Delta m=m_{b} \\cdots m_{t+1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+2^{t}X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其低位$p_{t} \\cdots p_{1}$泄露，记$p'=p_{t} \\cdots p_{1}$，则$p'$已知，但$\\Delta p=p_{b} \\cdots p_{t+1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+2^{t}X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n[GithHub实现链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n# 二、攻击工具\n\n## 1. RsaCtfTool\nGitHub链接：[RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)\n\n在Ubuntu18.04下的安装RsaCtfTool(进入RsaCtfTool目录下)：\n\n```Bash\napt install -y libgmp-dev\napt install -y libmpfr-dev\napt install -y libmpc-dev\npip3 install gmpy2 -i https://pypi.douban.com/simple\npip3 install -r requirements.txt -i https://pypi.douban.com/simple\n```\n\n## 2. yafu\n\n我认为最强大的分解因子的工具。\n\n## 3. 在线分解因子网站\n\n[factordb](http://factordb.com/)","tags":["rsa"],"categories":["crypto"]},{"title":"win10正版安装+配置记录","url":"/[object Object]/Win10-legal-installation-configuration-records.html","content":"\n# 1.前言\n自己以前作为一个电脑小白，重装系统时直接在百度上面搜索，搜到的全是各种下载站，从这些网站上面下载的系统其实已经改过了，安装完之后会给你预装很多软件，你又要花时间把他们删掉，可以说很不方便；去微软官网上面找，如果不知道怎么找，可能很不容易找到，于是写下这篇博客备忘，也方便他人。\n\n# 2. 下载镜像并制作启动盘\n\n安装前，准备好8GB以上的U盘(必须真的是8G以上，U盘质量一定要过关；另外，U盘里面的数据要备份好，制作启动盘会让原来的数据不复存在)\n\n**1.**先去[微软官方镜像下载地址](https://www.microsoft.com/zh-cn/software-download/windows10/)，下载MediaCreationTool；\n\n**2.**以管理员方式，运行MediaCreationTool；首先给出声明与许可条款，选择接受；此时会给你两种操作，升级本机或者创建安装介质，我习惯创建安装介质；\n\n**3.**选择语言、体系结构与版本，直接默认就好；\n\n**4.**选择要使用的介质，我这里选择U盘；插上事先准备好的U盘，如下图点击下一步：\n\n**5.**等待工具下载win10\n\n**6.**创建安装介质\n\n\n\n创建完成后，点击完成，工具做一些清理工作就会退出。\n\n打开文件资源管理器，可以看到启动盘已经制作完毕：\n\n\n\n# 3. 安装\n\n1.如果安装时鼠标用不了，可以使用tab键进行切换；\n\n2.安装过程中最好联网；\n\n3.删除不常用文件夹\ncmd-->regedit\n3D对象：HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->MyComputer\n->NameSpace->{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}\n音乐：{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}\n\n4.“开始”关掉设置、图片。\n\n\n# 4.安装常用软件\n\n[360zip国际版](https://www.360totalsecurity.com/zh-cn/360zip/)\n\n[百度网盘](http://pan.baidu.com/download)\n\n[Clover](http://en.ejie.me/)\n\n```Bash\n注：我们知道win10下面的文件资源管理器打开多个位置时是多个窗口，这个插件就可以以多标签页来管理，特别好用。\n```\n\n[Chrome浏览器](https://www.google.cn/intl/zh-CN/chrome/)\n\n```Bash\n注：虽然Edge用上了chrome的内核，但是你不跨平台还是不太方便。\n```\n\n[TIM](https://office.qq.com/download.html)\n\n```Bash\n注：窗口设置和微信差不多，感觉比QQ好用。\n```\n\n[迅雷&迅雷影音](https://www.xunlei.com/)\n\n[腾讯会议](https://meeting.tencent.com/download-center.html?from=1001)\n\n[cmder](https://cmder.net/)\n\n```Bash\n注：控制台模拟器，让你有一种用上Linux终端的感觉。\n\n1.更改快捷键Ctrl-T(新建标签页)为Crtl-Shift-T，避免与ctags的快捷键冲突。\n```\n\n[WPS](https://pc.wps.cn/)\n\n```Bash\n1.登录；\n\n2.在“我的电脑”隐藏网盘。\n```\n\n[Python3.6.4](https://www.python.org/downloads/windows/)\n\n```Bash\n注：安装的时候注意勾选添加到环境变量；将python改成python3以与python2程序区分；\n\n1.win10菜单搜索[管理应用执行别名]，关闭下面两个按钮[应用安装程序])；\n\n2.安装ctf密码学常用python库。\n```\n\n[VirtualBox](https://www.virtualbox.org/wiki/Downloads)\n\n[Vim](https://github.com/vim/vim-win32-installer/releases)\n\n```Bash\n1.添加环境变量：右键此电脑->属性->高级系统设置->环境变量，选中Path，并点击编辑，新建->填写vim程序的路径，点击3个确定才算成功添加；\n\n2.在安装vim的文件夹下有一个_vimrc文件，备份好之后写上自己的配置)；\n\n3.安装ctags插件：http://ctags.sourceforge.net；像ctags58.zip这种名称是支持win10的，下载下来之后只需要将ctags.exe复制到vim的安装目录下即可！\n```\n\n[yafu](https://sourceforge.net/projects/yafu/files/)\n\n```Bash\n强大的因子分解工具。\n```\n\n[Sagemath](https://github.com/sagemath/sage-windows/releases)\n\n[Curl](https://curl.se/windows/)，利用URL规则在命令行下工作的文件传输工具。\n\n[Telegram](https://desktop.telegram.org/)\n\n另外在win10应用商店里有几个不错的应用：微信、网易云音乐，淘宝。\n\nIDA Pro、SSR就看自己了。\n\n注：安装IDA Pro之后会顺带安装python2.7，同样将其安装的路径加入环境变量。","tags":["windows"],"categories":["conf"]},{"title":"攻防世界-密码学-sleeping-guard","url":"/[object Object]/Attack-and-Defense-World-Cryptography-Sleeping-Guard.html","content":"\n# 1.题目信息\n\n点击还原比赛场景后，会给出镜像服务器的ip以及连接端口。且提示：“只有真正的hacker才能看到这张图片”\n\n# 2. 分析\n\n连接上服务器之后，服务器返回的数据看上去像base64编码，对此，解码即可；根据题目的提示，flag藏在图片中，解码后文件头数据不是png,jpg,bmp文件头格式(说明不是直接解码这么简单)，也不是zip,rar,7z文件头格式(说明不是将图片加密压缩)；实际上，原比赛的此题还有一个Python脚本，大致意思是使用长度为12的密钥与图片数据进行(循环)异或加密，有了这个信息之后，尝试使用各种图片格式的文件头与加密数据进行异或得到密钥，使用png格式的文件头与加密数据进行异或时，得到的结果“很像”密钥；接下来使用密钥解密即可。\n\n# 3. 解题\n\n首先从服务器接收全部的数据，再进行base64解码(将解码后的数据存入文件data)；\n\n然后通过png文件头解出密钥，然后通过密钥解密，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom binascii import unhexlify\nfrom Crypto.Util.strxor import strxor\n\ndef enc(data,key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve(data):\n    head=unhexlify('89504e470d0a1a0a0000000d49484452')\n    key=strxor(head,data[:16])\n    with open('sleeping-guard.png','wb') as f:\n        f.write(enc(data,key[:12]))\n\nif __name__=='__main__':\n    with open('data','rb') as f:\n        solve(f.read())\n```\n\n最后解密出图片\n\n{% asset_img 1.png pic1 %}","tags":["xctf"],"categories":["crypto"]},{"title":"ByteCTF2020密码学部分详解","url":"/[object Object]/BytectF2020-cryptography-section-details.html","content":"\n# 一、noise\n\n## 1. 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF2020/noise)\n\n## 2.分析\n\n穷举通过proof_of_work之后，我们来看代码逻辑：\n\n*   secret=getrandbits(1024)，注意他自己实现的getrandbits(1024)实际上是生成长1017~1024位的随机数；\n*   对上述生成的secret，服务器最多只会与你交互64次；\n*   若op为'god'，服务器会返回num * getrandbits(992) % secret，这里num也由我指定；\n*   若op为'bless'，服务器会判断num与secret是否相等，若相等服务器返回FLAG。\n\n由于我至少要留一次交互机会发送我计算出的secret，因此我必须在63次交互内计算出secret！为下面叙述方便，声明如下记号：\n\n*   第 i 次发送的num记为$n_{i}$；\n*   第 i 次getrandbits(992)记为$g_{i}$；\n*   第 i 次接收的num * getrandbits(992) % secret记为$c_{i}$。\n\n记secret为$m$，则：\n\n$c_{i} \\equiv n_{i}\\cdot g_{i}\\ \\textrm{mod}\\ m,i=1,\\cdots ,63$\n\n即存在$k_{i}\\in Z$，$n_{i}\\cdot g_{i}=c_{i}+k_{i}\\cdot m$\n\n对等式两边模$n_{i}$则有：\n\n$c_{i}+k_{i}\\cdot m \\equiv 0\\ \\textrm{mod}\\ n_{i}$\n\n若我能够控制$k_{i}=1$，那么：\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n同时得到多个如上形式的等式可考虑使用中国剩余定理解出$m$！\n\n### 2.1 利用$n_{i}$控制$k_{i}$\n\n$m$有$1/2$的概率长1024比特，$g_{i}$有$1/2$的概率长992比特；此时，要控制$k_{i}=1$，即：\n$$\n\\left\\{\n\\begin{aligned}\nn_{i}\\cdot g_{i} &>m \\\\\nn_{i}\\cdot g_{i} &<2m\n\\end{aligned}\n\\right.\n$$\n对上式两边取对数：\n$$\n\\left\\{\n\\begin{aligned}\nlog(n_{i})+log(g_{i}) &>log(m) \\\\\nlog(n_{i})+log(g_{i}) &<log(m)+1\n\\end{aligned}\n\\right.\n$$\n记$log(g_{i})=991+\\alpha,log(n_{i})=32+\\beta,log(m)=1023+\\gamma;\\alpha,\\beta,\\gamma \\in (0,1)$(其中$X=2^{\\alpha},Y=2^{\\gamma}$服从$[1,2]$上的均匀分布)。上式改写为：\n$$\n\\left\\{\n\\begin{aligned}\n\\alpha+\\beta &>\\gamma \\\\\n\\alpha+\\beta &<1+\\gamma\n\\end{aligned}\n\\right.\n$$\n综上，$P(k_{i}=1)=P(\\alpha+\\beta>\\gamma,\\alpha+\\beta<1+\\gamma)=P(2^{\\beta}\\cdot X>Y,2^{\\beta-1}\\cdot X<Y)$\n\n直观地看，$\\beta$越大越有利于约束条件$\\alpha+\\beta>\\gamma$而不利于约束条件$\\alpha+\\beta<1+\\gamma$，反之，$\\beta$越小越有利于约束条件$\\alpha+\\beta<1+\\gamma$而不利于约束条件$\\alpha+\\beta>\\gamma$。\n\n注意到我可以判断是否满足约束条件$\\alpha+\\beta>\\gamma$—若$n_{i}\\cdot g_{i}<m$则$c_{i}=n_{i}\\cdot g_{i}$从而$c_{i}\\equiv 0 \\textrm{mod}\\ n_{i}$。\n\n由此，我选择$n_{i}$时应该尽量满足约束条件$\\alpha+\\beta<1+\\gamma$，即$\\beta$应尽量小，为何不设置$\\beta$为0，理由如下：\n\n当$\\beta=0$时，$P(k_{i}=1)=P(\\alpha>\\gamma,\\alpha<1+\\gamma)=P(\\alpha>\\gamma)=1/2$；\n\n由上述：$n_{i}$长$33$比特，而$m$长$1024$比特；由中国剩余定理可知：我们需要32个如下形式的同余式才能解出$m$！\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n要得到如上形式的同余式，即需要$k_{i}=1$，而$P(k_{i}=1)=1/2$，那么我得到$32$个如上形式的同余式“平均”需要$64$次交互，从而我没有发送secret的交互机会。\n\n综上，$\\beta$应在大于0的前提下尽量小！\n\n### 2.2值得注意的地方\n\n通过2.1，我知道了$n_{i}$值多大时可以解出$m$，结合中国剩余定理，同余式的模数之间是互素的，即我选择的$n_{i}$需两两互素，因此$n_{i}$不是取确定的值而是在一定的取值范围内取素数！\n\n## 3. 解题\n\n上述链接中的solve.py为解题的Python脚本，程序运行(成功时)结果如下：\n\n```bash\n$ python3 solve.py\n[+] Opening connection to 182.92.153.117 on port 30101: Done\n[+] MBruteforcing: Found key: \"l9a\"\nsuccess!\n95613903744255213782277288259288084531700829576284706991256294359734535087821985034716432798049279163174069238632678362676474782669781482301447573436852554131343117198284150657465643396718720128642929008328391123641254705186541184339088382138616985634723733544083949806487213357784626124965521562172300016682\nb'CONGRATULATIONS ByteCTF{Noise_i5_rea11y_ANN0YING}\\n'\n[*] Closed connection to 182.92.153.117 port 30101\n```\n\n注：此程序并非次次运行都能解出secret\n\n# 二、threshold\n\n## 1.题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF2020/threshold)\n\n## 2.分析\n\n程序又臭又长，但其实考点特别简单，稍微使用一下欧拉定理即可！我来分析一下程序的逻辑：\n\n在类TSM2初始化时：\n\n$pks \\equiv [(sk+1)\\cdot sks]^{n-2}\\ \\textrm{mod}\\ n$\n\n接着在output_p1函数中：\n\n$s \\equiv (d_{1}\\cdot k_{1}\\cdot s_{2}+d_{1}\\cdot s_{3}-r)\\ \\textrm{mod}\\ n$\n\n其中$d_{1}=sks$，而$r,s_{2},s_{3}$均由我指定，那么我令$r=s_{2}=0,s_{3}=1$，则得到的$s$即为$d_{1}$在模$n$下的值，即：\n\n$s \\equiv sks\\ \\textrm{mod}\\ n$\n\n注意到$n$是素数，欧拉函数$\\phi(n)=n-1$，显然$(n-2,n-1)=1$，即存在$x\\in Z,x\\cdot (n-2)\\equiv 1\\ \\textrm{mod}\\ \\phi(n)$\n\n由欧拉定理：$pks^{x}\\equiv [(sk+1)\\cdot sks]^{(n-2)x}\\equiv (sk+1)\\cdot sks\\ \\textrm{mod}\\ n$\n\n因此$(sk+1)\\equiv pks^{x}\\cdot sks^{-1}\\equiv pks^{x}\\cdot s^{-1}\\ \\textrm{mod}\\ n$，而密钥$sk$是小于阶$n$的，因此解出密钥$sk$，有了密钥干什么不行呢，按照程序的要求，对消息b'Hello, Welcome to ByteCTF2020!'签名即可！\n\n## 3.解题\n\n略","tags":["ctf"],"categories":["crypto"]},{"title":"help","url":"/help/index.html"},{"title":"tags","url":"/tags/index.html"},{"title":"links","url":"/links/index.html"},{"title":"about","url":"/about/index.html","content":"\n姓名：褚康明\n\n籍贯：湖北省孝感市\n\n本科：西安电子科技大学，数学与应用数学\n\n硕士：中国科学院大学信息工程研究所，电子信息\n\n方向：CTF密码学，NLP，代码嵌入"}]
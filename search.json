[{"title":"《An elementary introduction to hyperelliptic curves》翻译","url":"/tech/Hyper-introduces-translation.html","content":"## 摘要\n\n​\t本文对具有密码相关性的任意特征的有限域上的超椭圆曲线的一些理论作了初步的介绍。给出了在超椭圆曲线雅可比矩阵中求解的康托算法，并证明了该算法的正确性。\n\n\n\n## 一、简介\n\n​\t超椭圆曲线是一类特殊的代数曲线，可以看作是椭圆曲线的推广。对每类$g\\geq1$的超椭圆曲线，当$g=1$时超椭圆曲线退化为椭圆曲线。一百多年来，人们对椭圆曲线进行了广泛的研究，并有大量的相关文献;例如，参见西尔弗曼[34,35]的著作。最初研究椭圆曲线主要是出于纯粹的审美原因，最近已成为几个重要应用领域的必要工具，包括编码理论(如Driencourt和Michon[11]和van der Geer [15])；伪随机数生成(如Kaliski [18]);数论算法(如Goldwasser and Kilian[16]和Lenstra [21]);和公开密钥密码学(见Koblitz [19]， Miller[27]和Menezes [25])。\n\n​\t另一方面，超椭圆曲线理论还没有得到学术界足够的重视。在代数几何文献中出现的关于超椭圆曲线的大多数结果都是用非常一般的术语表达的。例如，在有关超椭圆曲线的论文中，一个常见的来源是芒福德的书[28]。然而，非专业人士很难将本书中的结果专门研究(更不用说发现)到超椭圆曲线的特殊情况。另一个困难是，这些书中的理论通常仅限于复数上的超椭圆曲线(如芒福德的书)，或特征不等于$2$的代数闭域。最近的Cassels和Flynn[6]的书是关于类为$2$曲线的广泛记述。(与他们的书相比，我们的方法绝对是“低级的”。)近年来，超椭圆曲线在代数几何以外的领域得到了应用。超椭圆曲线是Adleman和Huang关于证明[3]的质数的随机多项式时间算法的关键组成部分。在纠错码[4]、整数分解算法[22]和公钥密码[20]的设计中也考虑了超椭圆曲线。对于实现这些代码和密码系统，在特征为$2$的有限域上的超椭圆曲线是特别有趣的。\n\n​\tCharlap和Robbins[7,8]对椭圆曲线进行了初步的介绍。目的是为有限域上计算椭圆曲线上的点的Schoof算法[33]的一些基本理论提供基本的自成证明。讨论仅限于不等于2或3的特征域。然而，在实际应用中，椭圆曲线和超椭圆曲线在两个特征域上特别具有吸引力。本文与Charlap和Robbins的思想相似，对具有密码相关性的任意特征有限域上的超椭圆曲线的一些理论作了初步的介绍。关于代数曲线理论的一般介绍，请参阅富尔顿的著作[14]。\n\n\n\n## 二、基本定义和属性\n\n **定义1(超椭圆曲线)**设$K$是一个域，$\\bar K$是$K$的代数闭包。$K$上类为$g$的超椭圆曲线定义为如下等式：\n$$\nC: v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v] \\tag{1}\n$$\n其中$h(u)\\in K[u]$是次数不超过$g$的多项式，$f(u)\\in K[u]$是次数为$2g+1$的首项系数为$1$多项式，并且不存在解$(u,v)\\in \\bar K\\times\\bar K$同时满足方程$v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v]$与两个偏微分方程$2v+h(u)=0,h^{'}(u)v-f^{'}(u)=0$。\n\n​\t所谓$C$上的奇异点是一个解$(u,v)\\in \\bar K\\times\\bar K$同时满足上述三个方程。定义$1$表明超椭圆曲线没有任何奇异点。\n\n​\t对于本文的其余部分，假设域$K$和曲线$C$已经固定。\n\n\n\n**引理1** 令$C$是$K$上如式$(1)$定义的超椭圆曲线；\n\n$(\\textrm{i})$ 若$h(u)=0$，则$char(K)\\neq 2$；\n\n$(\\textrm{ii})$ 若$char(K)\\neq 2$，则变量替换$u\\rightarrow u,v\\rightarrow (v-h(u)/2)$将$C$转换为形式$v^{2}=f(u)$，其中$f$的次数为$2g+1$；\n\n$(\\textrm{iii})$ 令$C$是形如$(1)$的等式且$h(u)=0,char(K)\\neq 2$，则$C$是超椭圆曲线当且仅当$f(u)$在$\\bar K$上没有重根；\n\n证明：\n\n$(\\textrm{i})$假设$char(K)=2$，则任意的$x\\in K , 2x=0$，因此要成为曲线$C$上的奇异点只需要满足如下两个等式即可：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n\n先求满足$f^{'}(u)=0$的根$u_{0}$，再求满足$v^{2}=f(u_{0})$的根$v_{0}$，从而得到曲线$C$的奇异点$(u_{1},v_{0})$；这与$C$是超椭圆曲线矛盾。\n\n$(\\textrm{ii})$经变量替换，$C$的形式为：$(v-\\frac {h(u)} {2})^{2}=f(u)\\Rightarrow v^{2}=f(u)-\\frac {h^{2}(u)} {4}$，而$deg(h)\\leq g\\Rightarrow deg(f(u)-\\frac {h^{2}(u)} {4})=2g+1$。\n\n$(\\textrm{iii}) 当h(u)=0,char(K)\\neq 2$时，$C$有奇异点等价于存在$(u,v)\\in \\bar K\\times\\bar K$，满足：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\n2v=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n等价于：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\\\\\n\\\\\nv=0\n\\end{cases}\n$$\n因此，$C$有奇异点等价于存在$u\\in \\bar K$，满足：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n即$f$有重根；因此，$C$是超椭圆曲线等价于$f$无重根。\n\n**定义3**(有理点，无限点，有限点)设$L$是$K$的扩展域。$C$上$L$有理点的集合，记为$C(L)$，是满足曲线$C$的等式$(1)$的所有点$P(x,y)\\in L\\times L$连同一个在无穷远处的特殊点(记为$\\infty$)，点集$C(\\bar K)$简单地被$C$定义，$C$上异于$\\infty$的点称为有限点。\n\n\n\n**例4**(实数域上的超椭圆曲线)如下是实数域上的超椭圆曲线的三个例子，每条曲线类$g=2$且$h(u)=0$。\n\n$(\\textrm{i})\\ C_{1}:\\ v^{2}=u^{5}+u^{4}+4u^{3}+4u^{2}+3u+3=(u+1)(u^{2}+1)(u^{2}+3)$，$C_{1}$在实平面的图像如图$1$所示；\n\n{% asset_img 1.png pic1 %}\n\n$(\\textrm{ii})\\ C_{2}:\\ v^{2}=u^{5}+u^{4}-u^{2}-u=u(u-1)(u+1)(u^{2}+u+1)$，$C_{2}$在实平面的图像如图$2$所示；\n\n{% asset_img 2.png pic2 %}\n\n$(\\textrm{iii})\\ C_{3}:\\ v^{2}=u^{5}-5u^{3}-u^{2}+4u=u(u-1)(u+1)(u-2)(u+2)$，$C_{3}$在实平面的图像如图$3$所示；\n\n{% asset_img 3.png pic3 %}\n\n\n\n**定义5**(相反点、特殊点和平凡点)令$P(x,y)$是曲线$C$上的一个有限点。$P$的相反点是$\\bar P(x,-y-h(x))$。(注意到$\\bar P$确实在$C$上。)我们同样定义$\\infty$的相反点$\\bar \\infty=\\infty$为他的本身。若一个有限点$P$满足$P=\\bar P$，则该点被称为特殊的；否则，该点被称为平凡的。\n\n\n\n**例6**($Z_{7}$上的超椭圆曲线)考虑有限域$Z_{7}$上的曲线$C:v^{2}+uv=u^{5}+5u^{4}+6u^{2}+u+3$。这里，$h(u)=u,f(u)=u^{5}+5u^{4}+6u^{2}+u+3$且$g=2$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$确实是一个超椭圆曲线。$C$上的$Z_{7}$有理点为$C(Z_{7})={\\infty,(1,1),(1,5),(2,2),(2,3),(5,3),(5,6),(6,4)}$，点$(6,4)$是一个特殊点。\n\n\n\n**例7**($F_{2^{5}}$上的超椭圆曲线)考虑有限域$F_{2^{5}}=F_{2}[x]/(x^{5}+x^{2}+1)$，并且令$\\alpha$是本原多项式$x^{5}+x^{2}+1$在$F_{2^{5}}$的根。$\\alpha$的指数如表$1$所示。\n\n{% asset_img 4.png pic4 %}\n\n考虑有限域$F_{2^{5}}$上类$g=2$曲线$C: v^{2}+(u^{2}+u)v=u^{5}+u^{3}+1$，这里$h(u)=u^{2}+u,f(u)=u^{5}+u^{3}+1$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$实际上是一个超椭圆曲线。$C(F_{2^{5}})$中的有限点如下：\n\n{% asset_img 5.png pic5 %}\n\n其中，点$(0,1),(1,1)$是特殊的。\n\n## 三、多项式与有理函数\n\n​\t本节介绍多项式和有理函数的基本性质，这些性质是将它们视为超椭圆曲线上的函数而产生的。\n\n**定义8**(坐标环，多项式函数)$K$上$C$的坐标环，定义为$K[C]$，是商环\n$$\nK[C]=K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n其中$(v^{2}+h(u)v-f(u))$定义为由多项式$v^{2}+h(u)v-f(u)$生成的$K[u,v]$的理想。类似地，$\\bar K$上$C$的坐标环定义为\n$$\n\\bar K[C]=\\bar K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n$\\bar K[C]$的一个元素称为$C$上的多项式函数。\n\n**引理9** $\\bar K$上的多项式$r(u,v)=v^{2}+h(u)v-f(u)$不可约，从而$\\bar K[C]$是一个整环。\n\n证明：\n\n若$r(u,v)$在$\\bar K$可约，那么它将被分解为$(v-a(u))(v-b(u)),a,b\\in \\bar K[u]$。然而，此时$deg(a\\cdot b)=deg(f)=2g+1,deg(a+b)=deg(h)=g$，这是不可能的！\n\n​\t注意到对每个$G(u,v)\\in \\bar K[C]$，我们可以重复地用$f(u)-h(u)v$替换$v^{2}$直到最终得到如下表示：\n$$\nG(u,v)=a(u)-b(u)v,a(u),b(u)\\in \\bar K[u]\n$$\n显然这种表示是唯一的。\n\n**定义10**(共轭)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G(u,v)$的共轭被定义为$\\bar G(u,v)=a(u)+b(u)[v+h(u)]$。\n\n**定义11**(范数)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G$的范数为多项式函数$N(G)=G\\cdot \\bar G$。\n\n​\t范数函数在把关于双变量多项式函数的问题转化为关于单变量多项式的简单问题时非常有用。\n\n**引理12**(范数的性质)令$G,H\\in \\bar K[C]$为多项式函数。\n\n$\\textrm{(i)}\\ N(G)$是$\\bar K[u]$的一个多项式；\n\n$\\textrm{(ii)}\\ N(\\bar G)=N(G)$；\n\n$\\textrm{(iii)}\\ N(GH)=N(G)N(H)$；\n\n证明：$N(G)=a^{2}(u)-b^{2}(u)f(u)+a(u)b(u)h(u)$...基本就是套定义，没有什么思路的难度。\n\n**定义13**(函数域，有理函数)$K$上$C$的函数域$K(C)$是$K[C]$的分数域。同理，$\\bar K$上$C$的函数域$\\bar K(C)$是$\\bar K[C]$的分数域。$\\bar K(C)$的元素被称为$C$上的有理函数。\n\n注意到$\\bar K[C]$是$\\bar K(C)$的子环，即每个多项式函数也是有理函数。\n\n**定义14**(有理函数在有限点处的值)令$R\\in \\bar K(C),P\\in C,P\\neq \\infty$。如果存在多项式函数$G,H\\in \\bar K[C]$，使得$R=G/H$且$H(P)\\neq 0$，则称$R$在$P$处有定义。如果没有这样的$G,H\\in \\bar K[C]$存在，则$R$在$P$处没有定义。如果$R$在$P$处有定义，则$R$在$P$处的值定义为$R(P)=G(P)/H(P)$。\n\n显然值$R(P)$是定义明确的，即它不取决于$G,H$的选择，下面的定义介绍了多项式函数的次数的概念。\n\n**定义15**(多项式函数的次数)令$G(u,v)=a(u)-b(u)v$为$\\bar K[C]$中非零多项式函数，$G$的次数定义为：\n$$\ndeg(G)=max[2deg(a),2g+1+2deg(b)]\n$$\n**引理16**(次数的性质)令$G,H\\in \\bar K[C]$。\n\n$\\textrm{(i)}\\ deg(G)=deg(N(G))$；\n\n$\\textrm{(ii)}\\ deg(GH)=deg(G)+deg(H)$；\n\n$\\textrm{(iii)}\\ deg(G)=deg(\\bar G)$；\n\n证明：\n\n$\\textrm{(i)}N(G)=a^{2}-b^{2}f+abh,deg(N(G))=max[deg(G),deg(a)+deg(b)+g]$，因此只需证$deg(a)+deg(b)+g$必小于$2deg(a)$与$2g+1+2deg(b)$其中一个。\n\n$\\textrm{(ii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(iii)}$的结论，$deg(GH)=deg(N(GH))=deg(N(G)N(H))=deg(N(G))+deg(N(H))=deg(G)+deg(H)$\n\n$\\textrm{(iii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(ii)}$的结论...\n\n**定义17**(有理函数在$\\infty$处的值)令$R=G/H\\in \\bar K(C)$是一个有理函数。\n\n$\\textrm{(i)}$若$deg(G)<deg(H)$则$R$在$\\infty$处的值被定义为$R(\\infty)=0$；\n\n$\\textrm{(ii)}$若$deg(G)>deg(H)$则$R$在$\\infty$处的无定义；\n\n$\\textrm{(iii)}$若$deg(G)=deg(H)$则$R(\\infty)$被定义为$G$与$H$的首项系数的比值。\n\n## 四、零点与极点\n\n​\t本节介绍单值化参数的概念，以及有理函数的零点和极点的阶数。\n\n**定义18**(零点，极点)令$R\\in \\bar K(C)^{*},P\\in C$。若$R(P)=0$则记为$R$在$P$有一个零点。若$R$在$P$处没有定义则记为$R$在$P$处有一个极点，此时我们记为$R(P)=\\infty$。\n\n**引理19**令$G\\in \\bar K(C)^{*},P\\in C$，若$G(P)=0$，则$\\bar G(\\bar P)=0$。\n\n证明：套定义算就行，过程略。\n\n​\t定理23中使用引理20、21和22，证明了单值化参数的存在性。\n\n**引理20** 令$P(x,y)$是$C$上一个点。假定$G(u,v)=a(u)-b(u)v\\in \\bar K[C]^{*}$在$P$处有一个零点，且$x$不是$a(u),b(u)$的根。则$\\bar G(P)=0$当且仅当$P$是一个特殊点。\n\n证明：式子一列就看出来了。\n\n**引理21** 令$P(x,y)$是$C$上一个平凡点，$G=a(u)-b(u)v\\in \\bar K(C)^{*}$。若$G(P)=0$，且$x$不是$a(u),b(u)$的根。则$G$能被写为$(u-x)^{s}S$的形式，其中$s$是$(u-x)$能够整除$N(G)$的最高次数。$S\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：$G=N(G)/\\bar G$，由引理20，$\\bar G(P)\\neq 0\\Rightarrow N(G)(x)=0$，因此$N(G)$可被表示为$(u-x)^{s}d(u)$的形式。再令$S=d(u)/\\bar G$，则$G$能被写为$(u-x)^{s}S$的形式。由$s$的定义可知$S(P)\\neq 0$且$S(P)\\neq \\infty$。\n\n**引理22** 令$P(x,y)$是一个在$C$上的特殊点。则$(u-x)$可被写为$(v-y)^{2}\\cdot S(u,v)$，其中$S(u,v)\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：记$H(u,v)=(v-y)^{2} , s(u)=H(u,y)$，显然$s(x)=0 , s^{'}(u)=f^{'}(u)-h^{'}(u)y$，由于$C$是超椭圆曲线，无奇异点，而$P(x,y)$是特殊点，因此$2y+h(u)=0$，因此必有$f^{'}(x)-h^{'}(x)y\\neq 0$，即$s^{'}(x)\\neq 0$；综上，$(u-x)|H(u,v)$且$(u-x)^{2}\\nmid H(u,v)$，可得$S(x,y)\\neq 0,\\infty$。\n\n**引理23**(单值化参数的存在性)令$P\\in C$，则存在一个函数$U\\in\\bar K(C) , U(P)=0$使下列性质成立：对于每个多项式函数$G\\in \\bar K[C]^{*}$，存在整数$d$与函数$S\\in\\bar K(C)$，使得$S(P)\\neq 0,\\infty$且$G=U^{d}S$；此外，$d$与$U$的选择无关。$U$称为关于$P$的单值化参数。\n\n证明：太麻烦了，自己看吧！\n\n{% asset_img 6.png pic6 %}\n\n{% asset_img 7.png pic7 %}\n\n{% asset_img 8.png pic8 %}\n\n{% asset_img 9.png pic9 %}\n\n下面利用单值化参数的概念来定义多项式函数在某一点上的阶数。定义26给出了[20]的另一种定义，它更便于用于计算目的。引理27证明这两个定义实际上是等价的。\n\n**定义24**(多项式函数在一点的阶数的通常定义)令$G\\in \\bar K[C]^{*} , P\\in C , U\\in \\bar K(C)$是关于$P$的单值化参数，记$G=U^{d}S$，其中$S\\in \\bar K(C) , S(P)\\neq 0,\\infty$。$G$的阶在$P$处定义为$ord_{P}(G)=d$。\n\n**引理25** 令$G_{1} , G_{2}\\in \\bar K[C]^{*} , P\\in C$，记$ord_{P}(G_{1})=r_{1} , ord_{P}(G_{2})=r_{2}$。\n\n$\\textrm{(i)}\\ ord_{P}(G_{1}G_{2})=ord_{P}(G_{1})+ord_{P}(G_{2})$\n\n$\\textrm{(ii)}$若$G_{1}\\neq -G_{2}$。若$r_{1}\\neq r_{2}$，则$ord_{P}(G_{1}+G_{2})=\\textrm{min}(r_{1},r_{2})$，若$r_{1}=r_{2}$则$ord_{P}(G_{1}+G_{2})\\geq\\textrm{min}(r_{1},r_{2})$\n\n证明：由定义24易证！\n\n**定义26**(多项式函数在一点的阶数的另一种定义) $G=a-bv\\in \\bar K[C]^{*} , P\\in C$，$G$在$P$处的定义记为$ord_{P}(G)$，定义如下：\n\n$\\textrm{(i)}$若$P(x,y)$是有限点，则令$r$为$u-x$能够同时整除$a(u),b(u)$的最高次数，记$G(u,v)=(u-x)^{r}[a_{0}(u)-b_{0}(u)v]$，若$a_{0}(x)-b_{0}(x)y\\neq 0$，则令$s=0$；否则，令$s$为$u-x$能整除$N(a_{0}(u)-b_{0}(u)v)=a_{0}^{2}+a_{0}b_{0}h-b_{0}f$。若$P$是一个平凡点，则定义$ord_{P}(G)=r+s$，若$P$是一个特殊点，则定义$ord_{P}(G)=2r+s$。\n\n$\\textrm{(ii)}$若$P=\\infty$，则$ord_{P}(G)=-max[2deg(a),2g+1+2deg(b)]$。\n\n**引理27** 定义24与定义26等价。\n\n证明：\n\n{% asset_img 10.png pic10 %}\n\n**引理28** 令$G\\in \\bar K[C]^{*} , P\\in C$。则$ord_{P}(G)=ord_{\\bar P}(\\bar G)$。\n\n证明：\n\n{% asset_img 11.png pic11 %}\n\n**定理29**$G\\in \\bar K[C]^{*}$。则$G$存在有限个零点与极点；此外，$\\sum _{P\\in C}ord_{P}(G)=0$。\n\n证明：\n\n{% asset_img 12.png pic12 %}\n\n**定义30**(有理函数在一点上的阶数)令$R=G/H\\in \\bar K(C)^{*} , P\\in C$，$R$在$P$处的阶数定义为$ord_{P}(R)=ord_{P}(G)-ord_{P}(H)$。\n\n不难证明ordP (R)不依赖于G和H的选择，引理25和定理29对于非零有理函数也成立。\n\n## 五、因数\n\n本节介绍因数的基本性质及超椭圆曲线的雅可比矩阵。\n\n**定义31**(因数 , 次数 , 阶数)因数D是C中的点的形式和：$D=\\sum_{P\\in C}m_{P}P ,m_{P}\\in Z$，其中只有有限的$m_{P}$是非零的。D的次数，记为$degD$，是$\\sum_{P\\in C}m_{P}$。$D$在$P$处的阶数$m_{P}$，记$ord_{P}(D)=m_{P}$。\n所有因数的集合记为D，在加法规则下形成一个可加群：$\\sum_{P\\in C}m_{P}P+\\sum_{P\\in C}n_{P}P=\\sum_{P\\in C}(m_{P}+n_{P})P$。\n所有次数为$0$的因数组成的集合，记为$\\bf{D^{0}}$，是$D$的子群。\n\n**定义32**(因数的公约数)令$D_{1}=\\sum_{P\\in C}m_{P}P , D_{2}=\\sum_{P\\in C}n_{P}P$为两个因子，$D_{1}$与$D_{2}$的最大公约数定义为：$gcd(D_{1},D_{2})=\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P})P-(\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P}))\\infty$(注意到$gcd(D_{1},D_{2})\\in \\bf{D^{0}}$)。\n\n**定义33**(有理函数的因数)令$R\\in \\bar K(C)^{*}$。$R$的因数是$div(R)=\\sum_{P\\in C}(ord_{P}R)P$，注意到若$R=G/H$则$div(R)=div(G)-div(H)$。定理29表明有理函数的因数确实是一个有限形式和并且次数为0。\n\n**例34**若$P(x,y)$是$C$上的一个平凡点，则$div(u-x)=P+\\bar P-2\\infty$，若$P(x,y)$是$C$上的一个特殊点，则$div(u-x)=2P-2\\infty$。\n\n**引理35**令$G\\in \\bar K[C]^{*} , div(G)=\\sum_{P\\in C}m_{P}P$，则$div(\\bar G)=\\sum_{P\\in C}m_{P}\\bar P$。\n\n证明：由引理28易得。\n\n若$R_{1} , R_{2}\\in \\bar K(C)^{*}$则由引理25可得$div(R_{1}R_{2})=div(R_{1})+div(R_{2})$。\n\n**定义36**若对某些有理函数$R\\in \\bar K(C)^{*}$，$D=div(R)$，则因数$D\\in \\bf{D^{0}}$称为主因数。所有主因数组成的集合，记为$\\bf{P}$，是$\\bf{D^{0}}$的子群；商群$J=\\bf{D^{0}/P}$称为曲线$C$的雅可比矩阵。若$D_{1} , D_{2}\\in \\bf{D^{0}}$，当$D_{1}-D_{2}\\in \\bf{P}$时我们记为$D_{1}\\sim D_{2}$，$D_{1}$与$D_{2}$被称为等价因数。\n\n**定义37**(因数的支持)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的支持是集合$\\textrm{supp}(D)=\\{P\\in C|m_{P}\\neq 0\\}$。\n\n**定义38**(半约化因数)半约化因数是形如$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$，其中每个$m_{i}\\geq 0$且$P_{i}$均为有限点使得当$P_{i}\\in \\textrm{supp}(D)$则$\\bar P_{i}\\notin \\textrm{supp}(D)$，除非$P_{i}=\\bar P_{i}$，此时$m_{i}=1$。\n\n**引理39**对每个因数$D\\in\\bf{D^{0}}$存在一个半约化因数$D_{1}(D_{1}\\in\\bf{D^{0}})$使得$D\\sim D_{1}$。\n\n证明：\n\n{% asset_img 13.png pic13 %}\n\n## 六、半约化因数的表示\n\n本节描述雅可比矩阵半约化因子的多项式表示。它引出了一个有效的算法来添加雅可比矩阵的元素。\n\n**引理40** 令$P(x,y)$是$C$上一个平凡点，再令$R\\in \\bar K(C)$是一个在$P$处没有极点的有理函数，则对任意的$k\\geq 0$，存在唯一的元素$c_{0},\\cdots,c_{k}\\in\\bar K$与$R_{k}\\in \\bar K(C)$使得$R=\\sum_{i=0}^{k} c_{i}(u-x)^{i}+(u-x)^{k+1}R_{k}$，其中$R_{k}$在$P$处没有极点。\n\n证明：\n\n{% asset_img 14.png pic14 %}\n\n**引理41** 令$P(x,y)$是$C$上一个平凡点，则对任一$k\\geq 1$，存在唯一的多项式$b_{k}(u)\\in \\bar K[u]$使得：\n\n$\\textrm{(i)}\\ deg_{u} b_{k}<k$；\n\n$\\textrm{(ii)}\\ b_{k}(x)=y$且$b_{k}^{2}(u)+b_{k}(u)h(u)\\equiv f(u)\\ \\textrm{mod}\\ (u-x)^{k}$；\n\n证明：\n\n{% asset_img 15.png pic15 %}\n\n下面的定理说明了半约化因数如何可以表示为两个多项式函数的因数的最大公约数。\n\n**定理42** 令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，其中$P_{i}(x_{i},y_{i})$，令$a(u)=\\prod (u-x_{i})^{m_{i}}$。令$b(u)$是唯一满足如下条件的多项式：\n$\\textrm{(i)}\\ deg(b)<deg(a)$；\n\n$\\textrm{(ii)}$对所有$m_{i}\\neq 0$的$i$都有$b(x_{i})=y_{i}$；\n\n$\\textrm{(iii)}\\ a(u)|[b^{2}(u)+b(u)h(u)-f(u)]$，则$D=\\textrm{gcd}(div(a(u)),div(b(u)-v))$。\n\n注：$\\textrm{gcd}(div(a(u)),div(b(u)-v))$通常缩写为$div(a(u),b(u)-v)$或者，更简单：$div(a,b)$。\n\n{% asset_img 16.png pic16 %}\n\n{% asset_img 17.png pic17 %}\n\n注意到零因数表示为$div(1,0)$，下一个结果来自定理42的证明。\n\n**引理43** 令$a(u),b(u)\\in \\bar K[u]$使得$deg(b)<deg(a)$，若$a|(b^{2}+bh-f)$则$div(a,b)$是半约化的。\n\n## 七、约化因数\n\n本节定义了约化因数的概念，并证明了商群的每个陪集$\\bf{J=D^{0}/P}$只有一个约化因数，因此，我们可以用它的约化因数来识别每个陪集。\n\n**定义44**(约化因数)令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，若$\\sum m_{i}\\leq g$($g$是$C$的属性)，则$D$称为一个约化因数。\n\n**定义45**(因数的范数)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的范数定义为：$|D|=\\sum_{P\\in C\\setminus {\\infty}}m_{P}$。\n\n注意到给定一个因数$D\\in \\bf{D^{0}}$，在引理39的证明中所描述的操作会产生一个半约化因数$D_{1}$使得$D_{1}\\sim D$且$D_{1}\\leq D$。\n\n**引理46** 令$R\\in \\bar K(C)^{*}$，若$R$没有有限的极点，则$R$是一个多形式函数。\n\n{% asset_img 18.png pic18 %}\n\n**定理47 **对任一因数$D\\in \\bf{D^{0}}$存在一个唯一的约化因数$D_{1}$使得$D_{1}\\sim D$。\n\n证明：\n\n{% asset_img 19.png pic19 %}\n\n{% asset_img 20.png pic20 %}\n\n## 八、约化因数相加\n\n令$C$是定义在有限域$K$上属性为$g$的一个超椭圆曲线，令$J$是$C$的雅克比行列式，令$P(x,y)\\in C$，令$\\sigma$是$\\bar K$到$K$的一个自同构，则$P^{\\sigma}=(x^{\\sigma},y^{\\sigma})$同样是$C$上的一个点。\n\n**定义48**(因数的定义域)若一个因数$D=\\sum m_{P}P$有$D^{\\sigma}=\\sum m_{P}P^{\\sigma}$能对任意$\\bar K$到$K$的自同构$\\sigma$均与$D$相等。\n\n注意到如果$D$定义在$K$上，这并不代表$D$的支撑集中的每个点均为$K$有理点，一个主因数定义在$K$上当且仅当它是一个有$K$中系数的有理函数的因数，$J$中所有除数类的集合$J(K)$有一个定义在$K$上的代表，是$J$的一个子群。$J(K)$的每个元素都有一个唯一的表示形式，即约化因数$div(a, b)$，其中$a,b\\in K[u],deg(a)\\leq g,deg(b)<deg(a)$，因此$J(K)$事实上是一个有限Abel群。本节介绍一种在该组中元素相加的有效算法。\n\n令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个在$K$上定义的约化因数(则$a_{1},b_{1},a_{2},b_{2}\\in K[u]$)。算法1寻找一个半约化因数$D=\\textrm{div}(a,b),a,b\\in K[u]$使得$D\\sim D_{1}+D_{2}$。算法2将$D$约化为等价的约化因数$D^{'}$。\n\n算法1,2由Koblitz [20]实现，其推广了Cantor[5]的早期算法—假定$h(u)=0$且$char(K)\\neq 2$。\n\n{% asset_img 21.png pic21 %}\n\n**定理49**(算法1的有效性)令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个半约化因数，令$a,b$如式$(4),(5)$定义，则$D=\\textrm{div}(a,b)$是一个半约化因数且$D\\sim D_{1}+D_{2}$。\n\n证明：\n\n{% asset_img 22.png pic22 %}\n\n{% asset_img 23.png pic23 %}\n\n{% asset_img 24.png pic24 %}\n\n{% asset_img 25.png pic25 %}\n\n算法2：\n\n{% asset_img 26.png pic26 %}\n\n{% asset_img 27.png pic27 %}\n\n**定理51**(算法2的有效性)令$D=\\textrm{div}(a,b)$是一个半约化因数，则由算法2返回的因数$D^{'}=\\textrm{div}(a^{'},b^{'})$是约化的且$D^{'}\\sim D$。\n\n证明：\n\n{% asset_img 28.png pic28 %}\n\n{% asset_img 29.png pic29 %}\n\n{% asset_img 30.png pic30 %}\n\n注意，算法1和算法2中的所有计算都发生在域$K$本身(而不是$K$的任何适当扩展)。在算法1中，若$deg(a_{1})\\leq g,deg(a_{2})\\leq g$则$deg(a)\\leq 2g$。此时，算法2对步骤1的迭代次数最多为$[g/2]$。\n\n## 九、超椭圆曲线密码系统的实现\n\nDiffie-Hellman密钥交换[10]是一个协议，两个实体$A$和$B$可以通过公共通道上的一系列传输，就一个秘密的加密密钥达成一致。方法如下。$A$和$B$首先选择一个(乘式写)有限Abel群$G$和某个元素$\\alpha\\in G$。然后$A$选择一个随机整数$a$且将$\\alpha^{a}$传输给$B$，$B$反过来选择一个随机整数$b$且将$\\alpha^{b}$传输给$A$。这样$A,B$均能确定$\\alpha^{ab}$，作为他们的共享密钥。\n\n窃听者$C$监控$A$与$B$之间的传输将会得到$G,\\alpha,\\alpha^{a},\\alpha^{b}$，选择参数$G$和$\\alpha$，使$C$确定$\\alpha^{ab}$在计算上是不可行的。事实上，若$C$可以计算$a$或者$b$，则$C$可以确定$\\alpha^{ab}$。给定$\\alpha,\\beta=\\alpha^{a}$确定$a$的问题称为离散对数问题。当限制在$[0,order(\\alpha)-1]$范围内$a$是唯一的，称为以$\\alpha$为底，$\\beta$的对数。确定$\\alpha^{ab}$与计算$G$上的离散对数问题是否等价还没有定论，在其他安全依赖于离散对数问题的加密协议中，有ElGamal公钥加密和数字签名方案[12]，以及最近采用的美国数字签名标准[29]。\n\n最好的算法以解决离散对数问题在任意$G$组指数平方根攻击(见McCurley[24]),有一个运行时间的平方根成比例最大的质数因子$l$, $l$是$\\alpha$的阶。因此，如果选择$G$和$\\alpha$，使$l$有一个大的素数因子，那么这些攻击就可以避免。\n\n令$F_{q}$代表阶为$q$的有限域，再令$q=p^{m}$其中$p$是$F_{q}$的特征，Diffie与Hellman最初提议$G=F_{q}^{*}$，$F_{q}$的乘法群，作为实现Diffie-Hellman密钥交换协议的候选。有一些已知的随机次指数时间算法可用于计算$F_{q}$中的对数。关于$q$为质数的情形，请参见Coppersmith，Odlyzko和Schroeppel [9]和Gordon [17]，对于$p=2$的情况，请参见Odlyzko [30]，有关一般情况，请参见Adleman和DeMarrais [1]。这些算法是对上一段中提到的通用算法的渐进改进。 出于加密目的，我们对相应离散对数问题的次指数算法未知的群感兴趣。另外，为了有效和实际地实施，群操作应该相对容易地应用。 对于这样的群，在有限域上定义的超椭圆曲线的雅可比行列式就是一种可能性。\n\n为了使用超椭圆曲线实现离散对数密码系统，必须选择合适的曲线$C$和有限域$K$。 所选曲线和域的理想属性包括：\n\n* 底层有限域K中的算术应该有效地实现； 特征2的有限域似乎是最有吸引力的选择；\n* $C$的行列式$J(K)$的阶，表示为$\\sharp J(K)$，应该能被大素数整除。给定当前的计算技术，一个安全的要求为$\\sharp J(K)$可被至少45位的十进制素数$r$整除。另外，为了避免约化攻击Frey and Ruck [13]，它将$J(K)$中的离散对数问题简化为扩展域$K=F_{q}$中的离散对数问题。对所有的$F_{q^{k}}$中的离散对数可解的小整数$k$，$r$应无法整除$q^{k}-1$($1\\leq k\\leq 2000/(\\log_{2}q)$满足)。\n\n接下来描述一种用于选择超椭圆曲线并计算$\\sharp J(K)$的技术。令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，由方程$v^{2}+h(u)v=f(u)$给定，令$F_{q^{n}}$代表$F_{q}$的$n$次扩展，且令$N_{n}$代表有限Abel群$J(F_{q^{n}})$的阶，$C$上的$F_{q^{n}}$-有理点的个数定义为$M_{n}$。与$C$关联的是zeta函数，定义如下：\n\n**定义53**(zeta函数)令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，再令$M_{r}=\\sharp C(F_{q^{r}}),r\\geq 1$，$C$的zeta函数是幂级数：\n$$\nZ_{C}(t)=exp\\left(\\sum_{r\\geq 1}M_{r}\\frac {r} {t^{r}}\\right)\n$$\n以下是有关zeta函数的一些众所周知的事实(例如，参见[23])。\n\n**定理54**(zeta函数的性质)令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$Z_{C}(t)$为$C$的zeta函数。\n\n$\\textrm{(i)}\\ Z_{C}(t)\\in Z(t)$。更确切地说，我们有：\n$$\nZ_{C}(t)=\\frac {P(t)} {(1-t)(1-qt)}\\tag{9}\n$$\n其中$P(t)$为次数为$2g$的整系数多项式；此外，$P(t)$有如下形式：\n$$\nP(t)=1+a_{1}t+\\cdots+a_{g}t^{g}+qa_{g-1}t^{g+1}+q^{2}a_{g-2}t^{g+2}+\\cdots+q^{g-1}a_{1}t^{2g-1}+q^{g}t^{2g}\\tag{10}\n$$\n$\\textrm{(ii)}\\ P(t)$分解为：\n$$\nP(t)=\\prod_{i=1}^{g}(1-\\alpha_{i}t)(1-\\bar\\alpha_{i}t)\\tag{11}\n$$\n\n其中每个$\\alpha_{i}=\\sqrt{q}$，$\\bar\\alpha_{i}$为$\\alpha_{i}$的共轭。\n\n$\\textrm{(iii)}\\ N_{n}=\\sharp J(F_{q^{n}})$满足：\n$$\nN_{n}=\\prod_{i=1}^{g}|1-\\alpha_{i}^{n}|^{2}\\tag{12}\n$$\n为了计算$N_{n}$，由它满足$\\textrm{(i)}$确定$P(t)$的系数$a_{1},\\cdots,a_{g}$，从而确定$P(t)$；$\\textrm{(ii)}$分解$P(t)$因此可以确定$\\alpha_{i}$；$\\textrm{(iii)}$通过等式$(12)$计算$N_{n}$。\n\n**推论55** 令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$N_{n}=\\sharp J(F_{q^{n}})$，则$(q^{n/2}-1)^{2g}\\leq N_{n}\\leq (q^{n/2}+1)^{2g}$；从而$N_{n}\\approx q^{ng}$。\n\n[原文链接](http://www.math.uwaterloo.ca/~ajmeneze/publications/hyperelliptic.pdf)\n\n翻译不当之处还请批评指正，另外文中有些证明等我看明白了再翻译...","tags":["hyper"],"categories":["tech"]},{"title":"使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)","url":"/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html","content":"**前言** 系统环境为Ubuntu18.04\n\n## 一、准备工作\n\n### 1.1 安装nodejs\n\n从[node官网](https://nodejs.org/en/download/)下载二进制包(最后下载低一点的版本，这样之后配置主题时成功率更高)并命名为nodejs，再进行如下操作：\n```Bash\n$ sudo mv nodejs /opt/\n$ sudo cp /opt/nodejs/bin/node /usr/local/bin/ && chmod +x /usr/local/bin/node\n```\n在/opt/nodejs/bin目录下还有npm、npx两个sh脚本，试过符号链接到/usr/local/bin/目录下但是运行不了，那就只能在运行它们时使用绝对路径精确指定了:(，将npm换淘宝源以便更快下载：\n```Bash\n$ /opt/nodejs/bin/npm config set registry https://registry.npm.taobao.org\n```\n\n### 1.2 安装hexo\n使用npm安装hexo：\n```Bash\n# 这种下载方式不会出错，遇到错误的都懂\n$ sudo /opt/nodejs/bin/npm install --unsafe-perm --verbose -g hexo\n```\n\n## 二、本地博客部署\n新建一个文件夹用来存放博客数据：\n```Bash\n$ mkdir hexo\n```\n在新建的博客文件夹hexo的父目录初始化hexo：\n```Bash\n$ hexo init hexo\n```\n输出警告“Failed to install dependencies”，继续执行下面命令即可；\n```Bash\n$ cd hexo\n$ /opt/nodejs/bin/npm install\n```\n使用hexo编译静态页面：\n```Bash\n$ hexo generate\n$ hexo server\n```\n然后在浏览器中进入`http://localhost:4000`，就可以看到编译好的静态页面。\n\n## 三、本地配置博客\n\n下载一个自己觉得好看的主题，比如jsimple；\n```Bash\n$ git clone https://github.com/tangkunyin/hexo-theme-jsimple themes/jsimple\n```\n然后将hexo/_config.yml文件中的`theme: landscape`更改为`theme: jsimple`\n手动安装主题所需依赖`hexo-generator-search`：\n```Bash\n/opt/nodejs/bin/npm install hexo-generator-search --save\n```\n还没到打开网页的时候，还要进行一些文件的配置：\n* scaffolds/post.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\ncategory:\ntags:\ncomments: true\n```\n**注**author、authorLink、authorAbout、authorDesc可以换成自己想写的内容，avatar的/images/favicon.png可以换成自己想换的图片；\n\n* scaffolds/page.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\nlayout: {{ title }}\n```\n\n* _config.yml对应内容(原来有的如果不一样改成与下面一样，没有的添加进去)配置得与如下内容一样：\n```Bash\n# 语言配置\nlanguage:\n    - zh-cn\n\n# URL （注意 permalink 格式。其中timestamp是改了源码加上的，具体参见patch目录文件）\nurl: https://shuoit.net\nroot: /\npermalink: :category/:entitle-:timestamp.html\npermalink_defaults:\n  lang: en\n\n# 搜索配置\nsearch:\n  path: search.json\n  field: all\n  content: true\n  \n# 分类和标签别名\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n**注** 其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n然后重新编译静态页面(由于本文接下来会多次进行下述操作，因此提到\"重新编译静态页面\"就是进行下面操作)：\n```Bash\n$ hexo clean && hexo generate\n$ hexo server\n```\n然后在浏览器进入`http://localhost:4000`，可以看到主题已经应用；在终端按Crtl-C退出继续配置；\n\n## 四、完善页面\n\n### 4.1 tag|category\n当我们打开这些页面时都显示`Cannot GET /categories/XXX`，因为这些页面还没创建！因此需要创建这些页面：\n```Bash\n# 经过测试，page category及其子页面可以不用生成，如果一个分类下存在文章，那么该分类页面可以正常显示，否则会出现GET: categorise/XXX错误\n$ hexo new page categories\n$ hexo new page tech -p categories/tech\n$ hexo new page humanity -p category/humanity\n#下面这些页面一定要生成\n$ hexo new page tags\n$ hexo new page help\n$ hexo new page about\n$ hexo new page links\n```\n\n重新编辑静态页面，标签(tag)、分类(category)已经没有问题了！\n\n### 4.2 数学公式\n\n卸载原Markdown渲染器，安装`hexo-renderer-kramed --save`这款Markdown渲染器：\n```Bash\n$ /opt/nodejs/bin/npm uninstall hexo-renderer-marked --save\n$ /opt/nodejs/bin/npm install hexo-renderer-kramed --save\n```\n安装了新的Markdown渲染器并没有完全解决公式渲染的问题！接下来修改node_modules/kramed/lib/rules/inline.js的内容—第11行与第20行，分别改为：\n```Bash\n# 第11行，原为escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,改为如下：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n# 第20行，原为em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,改为如下：\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n将主题配置文件_config.yml中的mathjax的enable设置为true，对于需要公式渲染的博客，在开头添加`mathjax: true`，重新编辑静态页面，可以看到该博客内的公式可以被无误渲染！\n\n### 4.3 小插曲\n\n正当我兴致冲冲重新编辑静态页面，去看看配置好的另一篇带有数学公式的博客时，神奇的事情发生了，博客页面出现的竟然是hello world！！！整个人发出无数wc，平静下来后在这篇博客的地址栏发现了端倪，地址是这样的：\n```Bash\nhttp://localhost:4000/tech/undefined-undefined.html\n```\n刚看到这个我也不明白是哪里出了问题，不断的研读两篇配置文件，终于找到了一点突破，我们还记得在前面，根据主题作者修改配置文件时有一个`permalink: :category/:entitle-:timestamp.html`，首先是我感觉这有点像地址的构造方式(原谅我还没学过前端，一点小聪明还望大佬勿喷)，category我知道是什么，它就在文章开头设置的，那么基本上就清楚了，地址是根据category、entitle与timestamp三者组合而成的，而我在博客开头压根没有设置什么timestamp，所以地址生成失败，统一生成了undefined-undefined，其实地址这么复杂我也用不到，就自己改成如下：\n```Bash\npermalink: :category/:title.html\npermalink_defaults:\n```\n重新编辑静态页面，终于没问题了！\n\n### 4.4 地图(sitemap)\n\n为保证博客可被baidu、Google检索，需安装`hexo-generator-sitemap`插件：\n```Bash\n$ /opt/nodejs/bin/npm install hexo-generator-sitemap --save\n```\n\n### 4.5 嵌入图片\n\npost_asset_folder设置为true，对于需要引用图片的博客，首先在与博客的同目录下新建一个与博客名相同的文件夹，想要引用的图片放入该文件夹中，以`{% asset_img 1.png pic1 %}`命令就可以嵌入图片！虽然在Typora中不能显示，但是编辑到博客中可以正常显示。\n\n### 4.6 其他\n\n还有一些site_name，头像，cover_title，cover_description等等自己改一下就行了。\n\n## 五、部署到Gitee\n\n在本地将博客配置得足够满意之后，还要将博客部署到Gitee上面，这样其他人也可以在互联网访问；\n\n### 5.1 申请Gitee pages\n\n这个主题必须要求博客是`根目录部署`，就是创建的项目名称与个人空间地址一致，重要的事情说三遍！！！网上大部分教程说的项目名称与用户名一致是因为他们申请Gitee账号后没有更改用户名，从而个人空间地址与用户名一致，因此他们的做法可以正确部署到根目录，但是如果你更改过用户名导致个人空间地址与用户名一致的话，那么这时你创建的项目名称应该与个人空间地址一致，否则就是错误的`根目录部署`！\n\n个人空间地址在：设置-->个人资料-->个人空间地址进行查看。\n\n项目创建好之后，新建一个blog分支；然后开启Gitee Page服务，服务部署到blog分支上，勾选强制使用HTTPS；然后就可以生成Page了，这时我们可以看到什么叫根目录部署了，以我的Gitee Pages服务的地址为例：`https://chu-kangming.gitee.io`；\n\n### 5.2 部署到Gitee Pages\n\n安装hexo-deployer-git组件：\n\n```Bash\n/opt/nodejs/bin/npm install hexo-deployer-git --save\n```\n\n我这里假定你电脑上面已经安装git，并且公钥已经添加到了Gitee；修改站点配置文件_config.yml的deploy：\n```Bash\ndeploy:\n  type: git\n  repo: ssh地址\n  branch: blog\n```\n\n使用命令`hexo d`就可以将本地的博客数据部署到Gitee上面，可以看到blog分支下已经有了博客数据，但是，但是你如果这个时候打开Gitee Pages服务的地址它还是404，或者和你本地的博客显示不一致，这时因为Gitee Pages还没有更新(Gitee Pages Pro可以自动更新，但是需要氪金)，你只能手动更新：\n\n{% asset_img 1.png pic1 %}\n\n点击上图的更新，等重新部署完成，再次打开Gitee Pages服务地址，可以看到博客的效果终于和本地的博客效果一致了！\n\n注意：\n* 比如我的search功能好像还有些问题，可以再`hexo d`一次然后再更新一次Gitee Pages，如果还不行可以稍等一会儿再看，毕竟没有氪金，更新起来不会很快，我等第二天早上再去博客时search功能就正常了；\n\n* 每次刷新浏览器时不要用Ctrl-R，一定要用Shift-F5强制刷新；\n\n**参考链接**\n\n[使用Gitee+Hexo搭建个人博客](https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[hexo本地与部署不一致](https://blog.csdn.net/GAI159/article/details/105128186)\n\n[Hexo + Gitee采坑指北](https://www.luogu.com.cn/blog/jelly123/hexo-gitee-cai-keng-zhi-bei)\n\n[渲染公式](https://www.jianshu.com/p/7ab21c7f0674)\n\n[引用图片]([https://segmentfault.com/q/1010000019625231)\n\n[sitemap](https://blog.csdn.net/formemorywithyou/article/details/96478453)\n\n","tags":["hexo","gitee","jsimple"],"categories":["conf"]},{"title":"Ubuntu18.04安装ntl库","url":"/conf/Ubuntu1804-installs-the-NTL-library.html","content":"## 一、安装\n\n首先去[官网](https://www.shoup.net/ntl)下载安装包，下列shell脚本与安装包放到同一目录，赋予此脚本执行权限。另外，我这里默认你的电脑上面已经安装gcc，g++，make。\n\n```Bash\n#apt install -y gcc\n#apt install -y g++\n#apt install -y make\napt install -y autoconf\n\napt install -y m4\napt install -y libgmp-dev\napt install -y libgf2x-dev\n\ntar zxvf ntl-11.4.3.tar.gz\n\nmv ntl-11.4.3 ntl\n \necho -e \"\\033[31m start install ntl \\033[0m\"\ncd ntl/src\n./configure NTL_GF2X_LIB=on\nmake && make check && make install\ncd - >> /dev/null\n \nrm -r ntl\n```\n## 二、测试\n\n新建一个rand.cpp（顾名思义，是输出随机数）\n\n```C++\n#include <NTL/ZZ.h>\n#include <time.h>\nNTL_CLIENT\nint main()\n{\n\tZZ a,b,c;\n\tSetSeed(to_ZZ(time(NULL)));\n\tRandomLen(a, 32);\n\tRandomLen(b, 32);\n\tc = a + b;\n\tcout << \"a=\" << a << \", b=\" << b << \", c=\" << c << \"\\n\";\n\treturn 0;\n}\n```\n按照官网的介绍，使用如下命令编译：\n```Bash\ng++ -g -O2 -std=c++11 -pthread -march=native rand.cpp -o rand -lntl -lgmp -lm\n```\n其中rand.cpp是c++文件，rand是编译后的可执行文件。程序运行效果如下：\n```Bash\n$ ./rand\na=2298665095, b=3622090486, c=5920755581\n```\n\n**参考链接**：\n[NTL库快速上手中文指南](https://blog.csdn.net/tzwh_86/article/details/9372411#commentBox)\n[A Tour of NTL](https://libntl.org/doc/tour.html)","tags":["Ubuntu","ntl"],"categories":["conf"]},{"title":"git基础使用&gitee","url":"/tech/The-basic-Git-use-with-Gitee.html","content":"## 一、在网站上初始化\n\n在[码云](https://gitee.com/)上创建项目基本是傻瓜式操作。创建一个名为git-test的私有项目以备后续使用。\n\n本文介绍在本地创建仓库、将仓库上传至服务器以及本地与服务器的交互。\n\n## 二、在本地创建仓库及相关操作\n\n```Bash\n# 初始化一个Git仓库，则执行命令的目录会作为一个仓库\nmkdir /home/gitee/git-test && cd /home/gitee/git-test\ngit init\n# 那么git-test文件夹将会作为一个仓库\n# 新建一个文件然后将文件添加到Git的暂存区\necho 'Life is beautiful' > README.md && git add \"README.md\"\n# 查看仓库当前文件提交状态(A：提交成功；AM：文件在添加到缓存之后又有改动)\ngit status -s\n# 从Git的暂存区提交版本到仓库，参数-m后为当次提交的备注信息\ngit commit -m \"1.0.0\"\n```\n\n## 三、本地与服务器的交互\n\n在本地与服务器交互之前，先配置ssh公钥；保证已经安装了ssh(apt install -y ssh)，使用ssh-keygen生成ssh公钥：\n```Bash\ngit config --global user.email 'gitee注册邮箱'\ngit config --global user.name 'gitee用户名'\nssh-keygen -t rsa\n```\n在~/.ssh目录下有一个id_rsa.pub文件，里面的文本以ssh-rsa开头，将这些文本全部复制，转到设置->安全设置->ssh公钥，随便写个标题，将id_rsa.pub中的文本全部复制到公钥下面的框内。\n\n关于项目的ssh地址如何获得，见下图：\n\n{% asset_img 1.png pic1 %}\n\n下面介绍一些本地与服务器的常用交互\n```Bash\n# 在不执行克隆操作时将一个远程仓库添加到本地的仓库\ngit remote add origin ssh地址\n# 如果不需要远程的更新，比如此时远程只是一般性的初始化内容，可使用-f选项进行强制推送(远程仓库默认名为origin)\ngit push origin master -f\n# 克隆服务器中的项目(即在1中新建的名为git-test的项目)到本地\ngit clone ssh地址\n## 文件修改(本地)\n# 修改文件README.md，在文件后面追加一行'local change'\n# 此时查看状态\ngit status -s\n#先将文件添加到Git的暂存区，然后提交\ngit add 'README.md' && git commit -m '1.0.1'\n# 用本地仓库内容更新远程仓库内容\ngit push ssh地址\n# 刷新网站，可以看到服务器上面的内容已经与本地一致\n\n## 文件添加(本地)\n# 创建一个输出hello,world的C文件并将其编译\necho -e '#include <stdio.h>\\n\\nint main()\\n{\\n\\tprintf(\"hello,world\\\\n\");\\n\\treturn 0;\\n}' > hello.c && gcc hello.c -o hello -g\n# 先将新增的文件添加到Git的暂存区\ngit add he*\n# 这里可以查看一下状态\ngit status -s\n# 从Git的暂存区提交版本到仓库\ngit commit -m '1.0.2'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上已经有新增的文件\n\n## 文件移动(本地)\n# 为增强项目文件的组织性，我将上述的两个新增文件移到一个文件夹中\nmkdir Hello && git mv he* Hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.3'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上原来新增的两个文件已经在新建的文件夹下\n\n## 文件删除(本地)\n# 如我要将hello这个可执行文件删除\ngit rm Hello/hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.4'\n# 将更改同步到远程服务器\ngit push ssh地址\n\n# 如果是在网站上对项目做出更改(文件修改、添加、移动与删除)，要将更改同步回本地(即拉取)，使用pull命令\ngit pull origin master\n```\n以上基本上包含了使用git常见问题的解决方案。","tags":["git"],"categories":["tech"]},{"title":"鲲鹏计算专场密码学部分详解","url":"/crypto/Kun-Peng-calculation-special-cryptography-part-of-the-detailed.html","content":"## 一、平平无奇的RSA\n\n### 1.1 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/HUAWEI/task_task_gHXvFLV)\n\n### 1.2 分析\n\n题目由三个小问题组合而成，下面分别对他们进行分析。\n\n**Level 3**\n\n从脚本可得的信息如下：\n\n$N_{3}=p\\cdot q$，$\\phi$是$N_{3}$的欧拉函数；\n\n$s\\cdot sinv\\equiv 1\\ \\textrm{mod}\\ q$，再令$e=4s\\cdot sinv+3$(且要保证$(e,\\phi)=1$)；\n\n给你一组已知明-密文$km,kc$，即$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}$；\n\n那么分解$N_{3}$的步骤如下：\n\n$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}\\Rightarrow kc\\equiv km^{e}\\ \\textrm{mod}\\ p\\Rightarrow kc\\equiv km^{4s\\cdot sinv+3}\\ \\textrm{mod}\\ p$\n\n由欧拉定理可得：$km^{s\\cdot sinv}\\equiv km\\ \\textrm{mod}\\ p$，从而$kc\\equiv km^{4+3}\\ \\textrm{mod}\\ p$，即$kc\\equiv km^{7}\\ \\textrm{mod}\\ p$\n\n则$p|(km^{7}-kc)\\Rightarrow p=(km^{7}-kc,N_{3})$，因此$N_{3}$的一个因子是其与$km^{7}-kc$的公约数，进而分解出$N_{3}$；\n\n分解出$N_{3}$后，解密$c_{3}$得到Level 2的密文，下面分析Level 2。\n\n**Level 2**\n\n从脚本可得的信息如下：\n\n$o,s$是两个随机生成的素数，$t$是$o$的下一个素数，$u$是$s$的下一个素数；\n\n已知$os=o*s,tu=t*u$，$N_{2}=o*s*t*u\\Rightarrow tu=N_{2}//os$，这道题在18年强网杯的nextrsa的第四关考察过，[此处](https://www.cnblogs.com/WangAoBo/p/8654120.html)是对其的writeup\n\n**Level 1**\n\n这一层很简单，从$(N_{1}//1323)^{1/4}$往下开始试除即可(第一次写的时候疏忽了，往上试除，程序跑了几分钟都没解出来)。\n\n### 1.3解题\n\n上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\n$ python3 solve.py\nflag{4c2fd4e6-44de-445f-8c34-1235464de2de}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"drangon2020密码学部分详解","url":"/crypto/Drangon-2020-Cryptography-Section.html","content":"## 一、Bit_Flip1\n\n### 1.1 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_1)\n\n### 1.2 分析\n\n**1.过一遍程序**\n\n* 生成16个随机的字节作为alice_seed，与接收到的flip_str异或取后32个字节(不够在前面加\\x00)即为seed；\n\n* 由于alice = DiffieHellman(flip_str(alice_seed))没有设置prime，因此alice初始化时会调用get_prime()来生成素数；\n\n* 重点来看get_prime()这个函数；它不停的调用getbits(512)直到生成的数是一个素数；\n\n* 来看getbits()的原理：先调用more_bytes()积累足够的“随机”字节，每次调用more_bytes()都会在generated后面加上seed的sha256哈希值(长256比特)；\n\n* seed的更新方式为seed=long_to_bytes(bytes_to_long(seed)+1,32)，在这里简单看作seed的值增1即可；\n\n* generated收集到足够的字节之后，取后num比特作为生成的随机数，未用到的“随机”字节仍然保存在generated中；\n\n* 判断getbits(512)生成的是否为素数，若不是继续调用getbits(512)；\n\n* 得到素数之后，会告知你iter——相对于一次生成就能得到素数，对getbits(512)增加的调用次数(易知每调用一次getbits(512)，seed自增2)；\n\n* 返回prime后；调用getbits()生成64位的mysecret(DH算法的私钥)，然后计算$mynumber\\equiv 5^{mysecret}\\ \\textrm{mod}\\ prime$(DH算法的公钥)，设置shared为1337后，alice的初始化工作完成。\n\nbob=DiffieHellman(urandom(16), alice.prime)按照同样的方式完成初始化工作，只不过此时bob的prime直接使用alice的prime；\n\nalice与bob经密钥协商得到双方都知道的协商密钥(与DH算法略有不同，多了一个与1337的异或操作)，该密钥作为AES的加密密钥对FLAG进行加密。\n\n**2.寻找突破**\n\n我相信程序输出的数据都是有它的作用的，print(\"bob number\", bob.my_number)给出bob的公钥是为了让我们得到prime与secret之后可以同样计算出协商密钥；输出iv与enc_flag作用也很明显；那么程序输出iter就值得注意了，一定是对我们解题有用！\n\n**3.利用iter**\n\n那么我们如何借助iter来获取足够多的信息以致于解出FLAG；iter间接体现了get_prime()调用getbits()的次数！\n\n由于程序会接收我发送的flip_str，因此我们可以改变seed的值，即使我们不知道seed的值，但是这仍然有用！\n\n既然我们不知道seed的值(是因为我们不知道alice_seed的值)，那我们记alice_seed的值为$s_{127}\\cdots s_{1}s_{0}$，我们的考虑这样的情况：\n\n我发送如下两个flip_str：\n\nflip_str_1：空字节\n\nflip_str_2：|$1$|$0$|\n\n那么经bit_flip()就能生成如下2种seed：\n\nseed_1：|$s_{127}$|$\\cdots$|$s_{1}$|$s_{0}$|\n\nseed_2：|$s_{127}$|$\\cdots$|$1\\oplus s_{1}$|$s_{0}$|\n\n由这2个seed生成素数的iter分别记为iter_1与iter_2；\n\n分类讨论：\n\n* $s_{1}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{1}=1$，seed_2+2=seed_1，如果iter_2非0，必有iter_2-iter_1=1；\n\n那么当$iter\\_1\\cdot iter\\_2\\neq 0$时，由于$s_{j}$非0即1，因此此时iter_1-iter_2=1与iter_2-iter_1=1至少(没写错，确实是至少)有一个成立！此时$s_{j}=0\\Rightarrow$iter_1-iter_2=1，因此(原命题的真假性与逆否命题的真假性一致)$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$，即iter_1-iter_2=-1$\\Rightarrow s_{j}=1$。\n\n那如果$iter\\_1\\cdot iter\\_2=0$怎么办？这时根据iter_1-iter_2的值是无法判断$s_{1}$的值的！由于我们只需要保持|seed_1-seed_2|=2即可，因此我们可以改变flip_str前面的字节，这样得到的seed_x(x=1,2)的哈希值与原来显著不同，从而$iter\\_1\\cdot iter\\_2$的值有可能发生改变，不停的改变flip_str前面的字节直到$iter\\_1\\cdot iter\\_2\\neq 0$，就可以由上述分析过程解出$s_{1}$！\n\n一般地，类似于数学归纳法；假设我已经分析出$s_{j-1}\\cdots s_{1}$(这里没写错，$s_{0}$我是没有分析出来的)，借助已经得到的信息分析出$s_{j}$，思路如下：\n\n* 发送如下4种flip_str：\n\nflip_str_1：| $0$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_2：| $1$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\nflip_str_3：| $1$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_4：| $0$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\n那么经bit_flip()就能生成如下4种seed：\n\nseed_1：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_2：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\nseed_3：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_4：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\n由这4个seed生成素数的iter分别记为iter_1、iter_2、iter_3与iter_4；\n\n分类讨论：\n\n* $s_{j}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{j}=1$，seed_3+2=seed_4，如果iter_3非0，必有iter_3-iter_4=1；\n\n那么当$iter\\_1\\cdot iter\\_3\\neq 0$，由于此时$s_{j}$非0即1，因此iter_1-iter_2=1与iter_3-iter_4=1必有一个成立！同样地，$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$；因此，当$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)\\neq 0$时，$iter\\_3-iter\\_4=1\\Rightarrow iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$。\n\n如果$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)=0$，同样地，改变flip_str前面的字节直到进入上述情形!\n\n综上，我给出了对$s_{1}$的分析思路，也给出了由$s_{j-1}\\cdots s_{1}$推出$s_{j}$的分析思路；最终我可以还原出alice_seed除$s_{0}$之外的所有比特位，而$s_{0}$非0即1，因此最后解出的结果与alice_seed的值相差不超过1！\n\n接下来按照同样的方式生成AES密钥，对密文进行解密即可！\n\n### 1.3 解题\n\n这道题我并没有在比赛的时候做出来，因此我对task.py的交互方式作了一些改变；flag是自己设置的；上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\nλ python3 solve.py\nb'1\\xbc\\xfa\\x1b+5\\xed1\\x99\\xf7\\xa0\\x07\\x8e\\tQ\\xee'\nDrangon{just_for_test_flag}\n```\n\n## 二、Bit_Flip2\n\n### 2.1 题目信息\n\n附件仍然是一个Python脚本，相对于Bit_Flip1只有1行代码不同，它将print(\"bob number\", bob.my_number)这一行注释起来；[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_2)\n\n### 2.2 分析\n\n同Bit_Flip1的方法可解出alice_seed，可此时我并不知道bob.my_number；虽然当时想过控制alice.my_secret为0，但是觉得太不切实际，而事实上writeup就是这么做的！这需要你对比特币有一定的了解，知道使用块散列算法(可[参见此处](https://chu-kangming.gitee.io/crypto/Bitcoin-Block-hashing-algorithm.html))可以生成以一定长度的0字节结尾的哈希值。按同样的方法推测出alice_seed后发送特定的flip_str使得alice以特定的seed初始化，使得alice.my_secret为0，那么bob.my_number就对我们解密出flag无关紧要了。\n\n### 2.3 解题\n\n上述链接中的solve.py为解题脚本，同样因为题目没有在比赛的时候做出了，flag是我自己设置的；程序运行结果如下：\n\n```Bash\n$ python solve.py\nb'Drangon{just_for_test_flag}\\x00\\x00\\x00\\x00\\x00'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"Bitcoin—块散列算法","url":"/crypto/Bitcoin-Block-hashing-algorithm.html","content":"## 一、BTC Block\n\n[BTC Block](https://live.blockcypher.com/btc/)\n\n{% asset_img 1.png pic1 %}\n\n点击进入Height为658423的哈希值(000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c)\n\n{% asset_img 2.png pic2 %}\n\n## 二、Block hash算法\n\n[Block hash算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)\n\n它有多强大呢？举个例子：\n\n```Python\n>>> from hashlib import sha256\n>>> d=bytes.fromhex('01000000'+'81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000'+'e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b'+'c7f5d74d'+'f2b9441a'+'42a14695')\n>>> h=sha256(d).digest()\n>>> sha256(h).hexdigest()\n'1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000'\n```\n\n通过它构造的消息，其哈希值后面有很长的一段0！想知道上面的消息怎么构造，请往下看：\n\n### 2.1 准备工作\n\n* 安装pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n\n* 安装curl工具\n\n如果你用的Linux系统，curl工具可通过命令行安装；\n\n对于我使用的Windows系统，去[官网](https://curl.se/windows/)下载工具包，解压到C:\\Windows\\System32目录下或者将bin目录下的curl.exe的路径加入环境变量；\n\n### 2.2 获取构造特定哈希值的信息\n\n对我们想要的哈希值000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c，在命令行运行：\n```Bash\n# curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c > data\n```\n因为返回的消息太多了，因此输出重定向到文件中存下来；我们主要关注的有：ver、prev_block、mrkl_root、time、bits与nonce；这些值提取出来如下：\n```Python\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n```\n注意：ver、time、bits与nonce找最前面的，prev_block与mrkl_root找最后面的，不然算出来的哈希值会不是我们想要的。\n\n接下来，使用我写好的脚本如下，通过将这些信息组合起来就可以构造出消息，其哈希值就是000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c！\n\n```Python\nfrom hashlib import sha256\nfrom binascii import hexlify,unhexlify\nfrom Crypto.Util.number import long_to_bytes\n\n#curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n\ndef num_to_Bytes(n):\n    byte_n=long_to_bytes(n,4)\n    return byte_n[::-1]\n\ndef hex_to_Bytes(h):\n    s=unhexlify(h)\n    return s[::-1]\n    \ndef Bitcoin_demo():\n    d=num_to_Bytes(data['ver'])+hex_to_Bytes(data['prev_block'])+hex_to_Bytes(data['mrkl_root'])+num_to_Bytes(data['time'])+num_to_Bytes(data['bits'])+num_to_Bytes(data['nonce']%pow(2,32))\n    h=sha256(d).digest()\n    return sha256(h).digest()\n\nif __name__=='__main__':\n    ret=Bitcoin_demo()\n    print(hexlify(ret[::-1]))\n```\n\n程序运行结果如下：\n\n```Bash\n# python3 Bitcoin.py\nb'000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c'\n```","tags":["ctf"],"categories":["crypto"]},{"title":"win10正版安装+配置记录","url":"/conf/Win10-legal-installation-configuration-records.html","content":"## 一、前言\n\n自己以前作为一个电脑小白，重装系统时直接在百度上面搜索，搜到的全是各种下载站，从这些网站上面下载的系统其实已经改过了，安装完之后会给你预装很多软件，你又要花时间把他们删掉，可以说很不方便；去微软官网上面找，如果不知道怎么找，可能很不容易找到，于是写下这篇博客备忘，也方便他人。\n\n## 二、下载镜像并制作启动盘\n\n安装前，准备好8GB以上的U盘(必须真的是8G以上，U盘质量一定要过关；另外，U盘里面的数据要备份好，制作启动盘会让原来的数据不复存在)\n\n**1.**先去[微软官方镜像下载地址](https://www.microsoft.com/zh-cn/software-download/windows10/)，下载MediaCreationTool；\n\n**2.**以管理员方式，运行MediaCreationTool；首先给出声明与许可条款，选择接受；此时会给你两种操作，升级本机或者创建安装介质，我习惯创建安装介质；\n\n**3.**选择语言、体系结构与版本，直接默认就好；\n\n**4.**选择要使用的介质，我这里选择U盘；插上事先准备好的U盘，如下图点击下一步：\n\n**5.**等待工具下载win10\n\n**6.**创建安装介质\n\n创建完成后，点击完成，工具做一些清理工作就会退出。\n\n打开文件资源管理器，可以看到启动盘已经制作完毕：\n\n## 三、安装\n\n1.如果安装时鼠标用不了，可以使用tab键进行切换；\n\n2.安装过程中最好联网；\n\n3.删除不常用文件夹\ncmd-->regedit\n3D对象：HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->MyComputer\n->NameSpace->{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}\n音乐：{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}\n\n4.“开始”关掉设置、图片。\n\n\n## 四、安装常用软件\n\n[360zip国际版](https://www.360totalsecurity.com/zh-cn/360zip/)\n\n[百度网盘](http://pan.baidu.com/download)\n\n[Clover](http://en.ejie.me/)\n\n```Bash\n注：我们知道win10下面的文件资源管理器打开多个位置时是多个窗口，这个插件就可以以多标签页来管理，特别好用。\n但是你要忍受经常的广告的骚扰\n```\n\n[Chrome浏览器](https://www.google.cn/intl/zh-CN/chrome/)\n\n[TIM](https://office.qq.com/download.html)\n\n```Bash\n注：窗口设置和微信差不多，感觉比QQ好用。\n```\n\n[迅雷&迅雷影音](https://www.xunlei.com/)\n\n[腾讯会议](https://meeting.tencent.com/download-center.html?from=1001)\n\n[cmder](https://cmder.net/)\n\n```Bash\n控制台模拟器，让你有一种用上Linux终端的感觉。\n更改快捷键Ctrl-T(新建标签页)为Crtl-Shift-T，避免与ctags的快捷键冲突。\n```\n\n[WPS](https://pc.wps.cn/)\n\n```Bash\n记得在“我的电脑”隐藏网盘。\n```\n\n[Python3.6.4](https://www.python.org/downloads/windows/)\n\n```Bash\n注：安装的时候注意勾选添加到环境变量；将python改成python3以与python2程序区分；\nwin10菜单搜索[管理应用执行别名]，关闭下面两个按钮[应用安装程序])；\n安装ctf密码学常用python库。\n```\n\n[VirtualBox](https://www.virtualbox.org/wiki/Downloads)\n\n[Vim](https://github.com/vim/vim-win32-installer/releases)\n\n```Bash\n添加环境变量：右键此电脑->属性->高级系统设置->环境变量，选中Path，并点击编辑，新建->填写vim程序的路径，点击3个确定才算成功添加；\n在安装vim的文件夹下有一个_vimrc文件，备份好之后写上自己的配置)；\n安装ctags插件：http://ctags.sourceforge.net；像ctags58.zip这种名称是支持win10的，下载下来之后只需要将ctags.exe复制到vim的安装目录下即可！\n```\n\n[yafu](https://sourceforge.net/projects/yafu/files/)\n\n```Bash\n强大的因子分解工具。\n```\n\n[Sagemath](https://github.com/sagemath/sage-windows/releases)\n\n[Curl](https://curl.se/windows/)，利用URL规则在命令行下工作的文件传输工具。\n\n[Telegram](https://desktop.telegram.org/)\n\n另外在win10应用商店里有几个不错的应用：微信、网易云音乐，淘宝。\n\nIDA Pro、SSR就看自己了。\n\n注：安装IDA Pro之后会顺带安装python2.7，同样将其安装的路径加入环境变量。","tags":["windows"],"categories":["conf"]},{"title":"ByteCTF2020密码学部分详解","url":"/crypto/BytectF2020-cryptography-section-details.html","content":"## 一、noise\n\n### 1.1 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/noise)\n\n### 1.2 分析\n\n穷举通过proof_of_work之后，我们来看代码逻辑：\n\n*   secret=getrandbits(1024)，注意他自己实现的getrandbits(1024)实际上是生成长1017~1024位的随机数；\n*   对上述生成的secret，服务器最多只会与你交互64次；\n*   若op为'god'，服务器会返回num * getrandbits(992) % secret，这里num也由我指定；\n*   若op为'bless'，服务器会判断num与secret是否相等，若相等服务器返回FLAG。\n\n由于我至少要留一次交互机会发送我计算出的secret，因此我必须在63次交互内计算出secret！为下面叙述方便，声明如下记号：\n\n*   第 i 次发送的num记为$n_{i}$；\n*   第 i 次getrandbits(992)记为$g_{i}$；\n*   第 i 次接收的num * getrandbits(992) % secret记为$c_{i}$。\n\n记secret为$m$，则：\n\n$c_{i} \\equiv n_{i}\\cdot g_{i}\\ \\textrm{mod}\\ m,i=1,\\cdots ,63$\n\n即存在$k_{i}\\in Z$，$n_{i}\\cdot g_{i}=c_{i}+k_{i}\\cdot m$\n\n对等式两边模$n_{i}$则有：\n\n$c_{i}+k_{i}\\cdot m \\equiv 0\\ \\textrm{mod}\\ n_{i}$\n\n若我能够控制$k_{i}=1$，那么：\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n同时得到多个如上形式的等式可考虑使用中国剩余定理解出$m$！\n\n### 1.3 利用$n_{i}$控制$k_{i}$\n\n$m$有$1/2$的概率长1024比特，$g_{i}$有$1/2$的概率长992比特；此时，要控制$k_{i}=1$，即：\n$$\n\\left\\{\n\\begin{aligned}\nn_{i}\\cdot g_{i} &>m \\\\\nn_{i}\\cdot g_{i} &<2m\n\\end{aligned}\n\\right.\n$$\n对上式两边取对数：\n$$\n\\left\\{\n\\begin{aligned}\nlog(n_{i})+log(g_{i}) &>log(m) \\\\\nlog(n_{i})+log(g_{i}) &<log(m)+1\n\\end{aligned}\n\\right.\n$$\n记$log(g_{i})=991+\\alpha,log(n_{i})=32+\\beta,log(m)=1023+\\gamma;\\alpha,\\beta,\\gamma \\in (0,1)$(其中$X=2^{\\alpha},Y=2^{\\gamma}$服从$[1,2]$上的均匀分布)。上式改写为：\n$$\n\\left\\{\n\\begin{aligned}\n\\alpha+\\beta &>\\gamma \\\\\n\\alpha+\\beta &<1+\\gamma\n\\end{aligned}\n\\right.\n$$\n综上，$P(k_{i}=1)=P(\\alpha+\\beta>\\gamma,\\alpha+\\beta<1+\\gamma)=P(2^{\\beta}\\cdot X>Y,2^{\\beta-1}\\cdot X<Y)$\n\n直观地看，$\\beta$越大越有利于约束条件$\\alpha+\\beta>\\gamma$而不利于约束条件$\\alpha+\\beta<1+\\gamma$，反之，$\\beta$越小越有利于约束条件$\\alpha+\\beta<1+\\gamma$而不利于约束条件$\\alpha+\\beta>\\gamma$。\n\n注意到我可以判断是否满足约束条件$\\alpha+\\beta>\\gamma$—若$n_{i}\\cdot g_{i}<m$则$c_{i}=n_{i}\\cdot g_{i}$从而$c_{i}\\equiv 0\\  \\textrm{mod}\\ n_{i}$。\n\n由此，我选择$n_{i}$时应该尽量满足约束条件$\\alpha+\\beta<1+\\gamma$，即$\\beta$应尽量小，为何不设置$\\beta$为0，理由如下：\n\n当$\\beta=0$时，$P(k_{i}=1)=P(\\alpha>\\gamma,\\alpha<1+\\gamma)=P(\\alpha>\\gamma)=1/2$；\n\n由上述：$n_{i}$长$33$比特，而$m$长$1024$比特；由中国剩余定理可知：我们需要32个如下形式的同余式才能解出$m$！\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n要得到如上形式的同余式，即需要$k_{i}=1$，而$P(k_{i}=1)=1/2$，那么我得到$32$个如上形式的同余式“平均”需要$64$次交互，从而我没有发送secret的交互机会。\n\n综上，$\\beta$应在大于0的前提下尽量小！\n\n### 1.4 值得注意的地方\n\n通过2.1，我知道了$n_{i}$值多大时可以解出$m$，结合中国剩余定理，同余式的模数之间是互素的，即我选择的$n_{i}$需两两互素，因此$n_{i}$不是取确定的值而是在一定的取值范围内取素数！\n\n### 1.5 解题\n\n上述链接中的solve.py为解题的Python脚本，程序运行(成功时)结果如下：\n\n```bash\n$ python3 solve.py\n[+] Opening connection to 182.92.153.117 on port 30101: Done\n[+] MBruteforcing: Found key: \"l9a\"\nsuccess!\n95613903744255213782277288259288084531700829576284706991256294359734535087821985034716432798049279163174069238632678362676474782669781482301447573436852554131343117198284150657465643396718720128642929008328391123641254705186541184339088382138616985634723733544083949806487213357784626124965521562172300016682\nb'CONGRATULATIONS ByteCTF{Noise_i5_rea11y_ANN0YING}\\n'\n[*] Closed connection to 182.92.153.117 port 30101\n```\n\n注：此程序并非次次运行都能解出secret\n\n## 二、threshold\n\n### 2.1 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/threshold)\n\n### 2.2 分析\n\n程序又臭又长，但其实考点特别简单，稍微使用一下欧拉定理即可！我来分析一下程序的逻辑：\n\n在类TSM2初始化时：\n\n$pks \\equiv [(sk+1)\\cdot sks]^{n-2}\\ \\textrm{mod}\\ n$\n\n接着在output_p1函数中：\n\n$s \\equiv (d_{1}\\cdot k_{1}\\cdot s_{2}+d_{1}\\cdot s_{3}-r)\\ \\textrm{mod}\\ n$\n\n其中$d_{1}=sks$，而$r,s_{2},s_{3}$均由我指定，那么我令$r=s_{2}=0,s_{3}=1$，则得到的$s$即为$d_{1}$在模$n$下的值，即：\n\n$s \\equiv sks\\ \\textrm{mod}\\ n$\n\n注意到$n$是素数，欧拉函数$\\phi(n)=n-1$，显然$(n-2,n-1)=1$，即存在$x\\in Z,x\\cdot (n-2)\\equiv 1\\ \\textrm{mod}\\ \\phi(n)$\n\n由欧拉定理：$pks^{x}\\equiv [(sk+1)\\cdot sks]^{(n-2)x}\\equiv (sk+1)\\cdot sks\\ \\textrm{mod}\\ n$\n\n因此$(sk+1)\\equiv pks^{x}\\cdot sks^{-1}\\equiv pks^{x}\\cdot s^{-1}\\ \\textrm{mod}\\ n$，而密钥$sk$是小于阶$n$的，因此解出密钥$sk$，有了密钥干什么不行呢，按照程序的要求，对消息b'Hello, Welcome to ByteCTF2020!'签名即可！\n\n### 2.3 解题\n\n略","tags":["ctf"],"categories":["crypto"]},{"title":"Ubuntu安装metasploit-framework(方便安全可秒全网现有各种方法)","url":"/conf/Ubuntu-Installs-Metasploit-Framework-Easy-Secure-Instable.html","content":"## 前言\n\n做项目需要用到metasploit-framework这款强大的渗透工具，学长给的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)下载起来巨慢，重新在网上找方法：网上几乎都是添加Kali源来安装metasploit-framework，但是自己手残在apt update后加了一条apt upgrade -y，然后电脑开始下很多奇奇怪怪的东西直到电脑完全动不了，最后只能重装Ubuntu！所以总结一下网上在Ubuntu安装metasploit-framework的两种方法要么慢，要么危险。\n\n## deb包安装\n\n推荐一种安全又快捷的方法，使用deb包进行安装：[deb包链接在此](https://apt.metasploit.com/)；翻到最下面，可以看到有metasploit-framework的deb包\n\n\n\n选择最新版的下载下来，使用gdebi来安装deb包即可\n```Bash\nsudo gdebi metasploit-framework_6.0.13+20201023102229~1rapid7-1_amd64.deb\n```\n可以看看安装好的效果：\n\n\n## 后记\n\n我来说一下上面的deb包链接是怎么找到的；从上述的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)开始，下面的Installing\n\n\n点击the free installer,再到下面的Linux manual installation\n\n\nhttps://apt.metasploit.com 就是deb包的链接。","tags":["Ubuntu","msf"],"categories":["conf"]},{"title":"return2libc实验","url":"/tech/Return2libc-experiment.html","content":"**前言**\n[实验程序GitHub链接](https://github.com/coderall/return-to-libc-attack)\n注：实验环境为Ubuntu16.04的32位虚拟机(virtualbox)\n\n## 一、预备工作\n关闭地址随机化，否则攻击失败\n```Bash\nsudo sysctl -w kernel.randomize_va_space=0\n```\n{% asset_img 1.png pic1 %}\n\n## 二、任务1—查找libc函数的地址\n编译retlib.c，设置-fno-stack-protector关闭ubuntu上StackGuard保护机制，设置-z -execstack/noexecstack可打开或关闭可执行栈的机制，使用gdb来获取当前system()与exit()的地址\n```Bash\nsudo gcc retlib.c -fno-stack-protector -z noexecstack -o retlib -g\nsudo chmod 4755 retlib\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np system\np exit\nq\n```\n{% asset_img 2.png pic2 %}\n\n我们可以看到system()函数的地址是0xb7e43da0，exit()函数的地址是0xb7e379d0，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 3.png pic3 %}\n\n改完之后：\n\n{% asset_img 4.png pic4 %}\n\n## 三、任务2—将shell字符串放入内存中\n创建环境变量MYSH来记录/bin/sh路径，编译getenv.c，运行getenv程序获取/bin/sh的地址\n```Bash\nexport MYSH=\"/bin/sh\"\ngcc getenv.c -z noexecstack -o getenv -g\n./getenv MYSH ./retlib\n```\n{% asset_img 5.png pic5 %}\n\n可以看到/bin/sh的地址为0xbffffe41，使用上述得到的地址更改程序exploit.c：\n\n{% asset_img 6.png pic6 %}\n\n改完之后：\n\n{% asset_img 7.png pic7 %}\n\n## 四、任务3—找出栈溢出地址相对buffer的偏移\n\n下面我们介绍  *(long *) &buf[24] = 0xb7e5f430 ;   //  system()  中的24是怎么得到的；\n首先你应该对return to libc的原理有一定了解(不了解先参见[此处](https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/index.html))(原理看完就可以回来了，实验部分这里讲得更清楚^_^)\n这里的24就是栈溢出地址相对buffer的偏移；一种有用的办法是这样做的：生成较长的由a-zA-Z组成的随机字符串(比如我生成长100的这样的字符串)，将它写入badfile文件，然后用gdb调试retlib程序；\nrand.py程序如下：\n```Python\nfrom string import ascii_letters as al\nfrom random import randint\n\nX=[randint(0,51) for _ in range(100)]\nprint ''.join([al[x] for x in X])\n```\n\n```Bash\npython rand.py >> badfile\ngdb -q retlib\n#进入gdb命令行\nr\n```\n\n{% asset_img 8.png pic8 %}\n\n不用设置断点，直接运行然后会发生栈溢出错误，并且告诉你栈溢出的地址，在我调试的过程中，栈溢出的地址为0x4a4c4e49，把这个地址转换为字符串并反转是INLJ(之所以要反转是因为地址的表示为大端表示)，INLJ在上述生成的随机字符串中的索引就是24，说明栈溢出地址相对buffer的偏移为24；\n\n## 五、任务4—利用缓冲区溢出漏洞\n编译exploit.c，攻击，进入/bin/sh程序\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n{% asset_img 9.png pic9 %}\n\n## 六、任务5—增加调用setuid进行提权\n首先按照同样的方式获取setuid()函数的地址，然后更改程序exploit.c；\n```Bash\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np setuid\nq\n```\n{% asset_img 10.png pic10 %}\n\n可以看到setuid()函数的地址为0xb7eba2e0，使用上述得到的地址更改程序exploit.c，改完之后：\n\n{% asset_img 11.png pic11 %}\n\n重新编译exploit.c然后进行攻击(如果攻击失败，尝试：重启->关闭地址随机化->export MYSH=\"/bin/sh\"，然后重新执行下面三行命令)\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n攻击结果如下：\n{% asset_img 12.png pic12 %}","tags":["ret2libc"],"categories":["tech"]},{"title":"Makefile初探","url":"/tech/The-Makefile-que.html","content":"## 一、 背景\n\n如果做过工程，或者读过一些优秀的开源代码的话；了解.c文件需要分开写，每个.c文件实现特定的一小部分功能，另外还有一些.h文件，这种文件主要引用一些头文件，声明一些函数(虽然函数可以直接定义无需声明，但是先声明再定义是一个好习惯，另外一些虚函数是仅仅声明而不定义的)与宏；这些.c文件再被不同的目录组织；以上就是工程一般的框架，这些.c文件既可能依赖.h文件，也可能依赖其他.c文件，单单一行gcc的编译命令已经解决不了，这时需要Makefile来指导编译过程！\n\n## 二、语法规则\n\n目标文件：依赖文件\n|tab|编译规则\n\n注：|tab|代表一个tab键\n\n# 三、Demo\n\n我的文件组织如下：\n```Bash\n.\n├── include\n│   └── head.h\n├── Makefile\n└── src\n    ├── add.c\n    ├── div.c\n    ├── master.c\n    ├── mul.c\n    └── sub.c\n```\n\nhead.h的代码如下：\n```C\n#include <stdio.h>\n\nint add(int a,int b);\n\nint sub(int a,int b);\n\nlong mul(long a,long b);\n\nfloat div(float a,float b);\n```\n\nadd.c的代码如下：\n```C\n#include \"head.h\"\n\nint add(int a,int b)\n{\n\treturn a+b;\n}\n```\n差不多这个意思，其他的代码就自己完善吧；\n\n最后master.c代码如下：\n```C\n#include \"head.h\"\n\nint main()\n{\n\tint a,b;\n\ta=12;\n\tb=3;\n\tprintf(\"%d add %d = %d\\n\",a,b,add(a,b));\n\tprintf(\"%d sub %d = %d\\n\",a,b,sub(a,b));\n\tlong ma,mb;\n\tma=12;\n\tmb=3;\n\tprintf(\"%ld mul %ld = %ld\\n\",ma,mb,mul(ma,mb));\n\tfloat fa,fb;\n\tfa=12;\n\tfb=3;\n\tprintf(\"%f div %f = %f\\n\",fa,fb,div(fa,fb));\n\treturn 0;\n}\n```\n\n下面是Makefile文件：\n```Makefile\nmaster:rely1.o rely2.o rely3.o rely4.o rely5.o\n\tgcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nrely1.o: src/master.c include/head.h\n\tgcc -c -I include src/master.c -o src/master.o\nrely2.o: src/add.c include/head.h\n\tgcc -c -I include src/add.c -o src/add.o\nrely3.o: src/sub.c include/head.h\n\tgcc -c -I include src/sub.c -o src/sub.o\nrely4.o: src/mul.c include/head.h\n\tgcc -c -I include src/mul.c -o src/mul.o\nrely5.o: src/div.c include/head.h\n\tgcc -c -I include src/div.c -o src/div.o\n.PHONY:clean\nclean:\n\tfind . -name '*.o'  | xargs rm -f\n```\n\n下面make生成可执行文件：\n```Bash\n$ make && make clean\ngcc -c -I include src/master.c -o src/master.o\ngcc -c -I include src/add.c -o src/add.o\ngcc -c -I include src/sub.c -o src/sub.o\ngcc -c -I include src/mul.c -o src/mul.o\ngcc -c -I include src/div.c -o src/div.o\ngcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nfind . -name '*.o'  | xargs rm -f\n```\n\nmake clean会执行Makefile文件中clean下的命令，它会清除所有的目标文件(.o文件)，因为已经不需要了！\n\n我们测试一下可执行文件是否正确执行：\n```Bash\n$ ./master\n12 add 3 = 15\n12 sub 3 = 9\n12 mul 3 = 36\n12.000000 div 3.000000 = 4.000000\n```\n\n注：可以看到Makefile中的rely1.o等等只是代号，真正目标文件的名称设定由编译规则指定。","tags":["makefile"],"categories":["tech"]},{"title":"i春秋\"巅峰极客\"2020密码学部分详解","url":"/crypto/I-Spring-and-Autumn-Peak-Geek-2020-Cryptography-in-detail.html","content":"## 一、tryecc\n\n### 1.1 题目信息\n\n附件是一个sage脚本与一个文本文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/iCHUNQIU/tryecc)在此\n\n### 1.2 分析\n\n$$\nE_{1}: y^{2}\\equiv x^{3}+ax+c\\ \\textrm{mod}\\ N\\\\\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ N\n$$\n\n我们总结一下已知量和未知量：\n\n| 已知            | 未知      |\n| :-: | :-: |\n| $N,C,P_{1},P_{2},P_{3},P_{4}$ | $A,B,m_{1},m_{2}$ |\n\n那么已知$P_{1}(x_{1},y_{1}),P_{2}(x_{2},y_{2})$就可以计算出$a,b$：\n$$\ny_{1}^{2}\\equiv x_{1}^{3}+a\\cdot x_{1}+c\\ \\textrm{mod}\\ N \\\\\ny_{2}^{2}\\equiv x_{2}^{3}+a\\cdot x_{2}+b\\ \\textrm{mod}\\ N \\\\\na=(y_{1}^{2}-x_{1}^{3}-c)\\cdot x_{1}^{-1}\\ \\textrm{mod}\\ N \\\\\nb=y_{2}^{2}-x_{2}^{3}-a\\cdot x_{2}\\ \\textrm{mod}\\ N \\\\\n$$\n好在$x_{1}$在模$N$下有逆，于是$a,b$就可以解出，到此得到了$E_{1},E_{2}$；\n\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\\\\\nP_{4}=m_{2}\\cdot P_{2}\\ in\\ E_{2}\n$$\n丢到sgaemath里面去解离散对数，结果发现解不出来！\n\n但是发现$N$不是素数，用yafu分解一下$N$，发现$N$是两个素数的乘积，记为$N=p\\cdot q$，那么椭圆曲线$E_{2}$可重写为\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\\cdot q\n$$\n这样$E_{2}$上的点也满足下面两个等式：\n$$\nE_{p}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p \\\\\nE_{q}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ q\n$$\n\n\n即$E_{2}$上的点同时在$E_{p}$与$E_{q}$上(试了一下，我们可以求解$P_{3},P_{4}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数)\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n 则有：\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{p} \\\\\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{q}\n$$\n那是不是意味着我们解出$P_{3}$在椭圆曲线$E_{p}$上关于基点$P_{2}$的离散对数就是$m_{1}$呢？非也！我们解出的只是$m_{1}\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})$，即$m_{1}$模了$P_{2}$在椭圆曲线$E_{p}$上的阶之后的值！\n\n要想解出$m_{1}$，需要将$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数结合起来！\n$$\nm_{1}\\equiv s_{p}(1)\\ \\textrm{mod}\\ order_{E_{p}}(P_{2}) \\\\\nm_{1}\\equiv s_{q}(1)\\ \\textrm{mod}\\ order_{E_{q}}(P_{2})\n$$\n这里$s_{p}(1),s_{q}(1)$分别是$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数；\n\n使用中国剩余定理解上述方程组即可解出$m_{1}$，同理解出$m_{2}$\n\n### 1.3 解题\n\n上述链接中的solve.sage为解题的脚本；程序运行结果如下(运行时间有点长，稍微等一下)：\n\n```Bash\n$ sage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{de7a89ab1d074ef3930fb3054c0e3ac8}\n```\n\n## 后记\n\n一直在等师傅们关于密码学题目的writeup，结果一直没有找到；就只能把自己唯一做出来的一道题目的writeup写一下。","tags":["ctf"],"categories":["crypto"]},{"title":"Sagemath在ctf密码学中的使用","url":"/crypto/Use-of-Sagemath-in-CTF-Cryptography.html","content":"## 一、 基本的环和域\n\n```Python\n#整数域,有理数域和实数域\nZZ(3)\nQQ(0.25)\nRR(2^0.5)\n#复数域\nCC(1,2)\n#生成虚数单位i\ni=ComplexField().gen();(2+i)*(4+3*i)\n\n#构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环\n#定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域\nR.<w>=PolynomialRing(ZZ);R\n(1 + w)^3\n\n#有限环\nRN=IntegerModRing(63)\nFR=Integers(17);FR\n#自身的代数扩展;exR=FR[w]/(w^2+3)\nexR=FR.extension(w^2+3)；exR\n#以python整数的形式返回所有可逆元素的列表\nFR.list_of_elements_of_multiplicative_group()\n#假设环的乘法群是循环的，返回这个环的乘法群的生成元\nFR.multiplicative_generator()\n#返回这个环的一个随机元素\nFR.random_element()\n#上述几种方法对如下的域同样支持\n\n#有限域\n#素数域\nG1=GF(37);G1\n#伽罗瓦域\nG2=GF(3^5);G2\n```\n\n## 二、 数论基本函数\n\n```Python\n#同时求商与余数\nq,r=divmod(12,5)\n\n#求公约数\nd=gcd(12,5)\n\n#扩展的欧几里得算法\nd,u,v=xgcd(12,5)\n\n#12在模5下的逆\nu=inverse_mod(12,5)\n\n#生成[lb,ub)之间的随机素数,注意ub在前,lb在后,lb可缺省为0\n#可通过这种方式生成128位的随机素数\np=random_prime(2L**128,2L**127)\n\n#判断是否为素数\nis_prime(65537)\n\n#第20个素数\nnth_prime(20)\n\n#计算x^y mod n\nz=power_mod(12,5,17)\n\n#欧拉函数\neuler_phi(111)\n\n#中国剩余定理,A=[a1,...,an],M=[m1,...,mn]\n#ai=x mod mi,i=1,...,n\ncrt([1,2,3,4],[7,5,12,23])\n\n#求自身的n次根\nFR(12).nth_root(7,all='True')\n\n#求多项式的根，roots方法必须作用在域上\nR.<x>=PolynomialRing(G1)\nxt=G1(12)\nyt=xt^6\nf=x^6-yt\nf.roots()\n```\n\n## 三、线性代数\n\n```Python\n#定义矩阵，默认定义在实数域\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#定义在其他域上的矩阵，如有限域\nA = matrix(GF(13),[[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#可以看到两个逆矩阵不一样\n\n#定义向量，定义在有限域，默认定义在实数域\nw = vector(GF(13),[1,1,4,3])\nY=A*w;Y\nZ=w*A;Z\n\n#解线性方程组AX=Y\nX = A.solve_right(Y);X\n#也可以使用符号\\\nA\\Y\n#解线性方程组XA=Y\nX = A.solve_left(Z);X\n\n#格基约减\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\n#LLL算法\nA.LLL()\n#BKZ算法\nA.BKZ()\n```\n\n## 四、离散椭圆曲线\n以国密SM2算法使用的椭圆曲线为例；\n\n```Python\np=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF',16)\na=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC',16)\nb=ZZ('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93',16)\n#有限域GF(p)上的椭圆曲线y^2 = x^3 + a*x + b mod p\nE=EllipticCurve(GF(p),[0,0,0,a,b])\n#基点\ng=E([ZZ('32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7',16),ZZ('bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0',16)])\n#基点的阶\nn=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123',16)\n#生成密钥\nsk=random_prime(2*n//3,n//3)\n#生成公钥\nG=sk*g\n```\n\n## 五、离散对数\n\n前言：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是'+'与'\\*'，默认为'\\*'；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。\n\n```Python\n#通用的求离散对数的方法\nx=discrete_log(a,base,ord,operation)\n\n#求离散对数的Pollard-Rho算法\nx=discrete_log_rho(a,base,ord,operation)\n\n#求离散对数的Pollard-kangaroo算法(也称为lambda算法)\nx=discrete_log_lambda(a,base,bounds,operation)\n\n#小步大步法\nx=bsgs(base,a,bounds,operation)\n```\n\n## 六、coppersmith算法\n\n[coppersmith算法介绍链接](https://www.cnblogs.com/coming1890/p/13506057.html)\n\n使用sage实现coppersmith相关攻击，[GitHub链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n最后，sage的[官方文档链接](https://doc.sagemath.org/html/en/reference/)","tags":["ctf","sagemath"],"categories":["crypto"]},{"title":"Elgamal&RSA小结","url":"/crypto/Elgamal-RSA-summary.html","content":"## 1. 前言\n\n要解决的问题：$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但$(e,\\phi(N))>1$)。\n\n## 2. 分类讨论\n\n首先给出求解方程($q,e$为素数)$y\\equiv x^{e}\\ \\textrm{mod}\\ q^{k}$的[Python脚本](https://github.com/KangMing-ux/AllRootModqk)\n\n注：当$k=1$时，可(使用Sagemath)直接在有限域$GF(q)$上对$y$开$e$次方；\n\n### 2.1. $N=p^{a}$\n\n记$g=(e,\\phi(N)),e_{1}=e/g$，则$(e_{1},\\phi(N))=1$，因此可以计算$d_{1}\\equiv e_{1}^{-1}\\ \\textrm{mod}\\ \\phi(N)$；$c^{d_{1}}\\equiv m^{e\\cdot d_{1}}\\equiv (m^{g})^{d_{1}\\cdot e_{1}}\\equiv m^{g}\\ \\textrm{mod}\\ N$，从而可得$m^{g}\\ \\textrm{mod}\\ p^{a}$，接下来使用上述工具求解(最多有$g$个解)。\n\n### 2.2. $N=p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}}$\n\n$c\\equiv m^{e}\\ \\textrm{mod}\\ N\\Rightarrow c\\equiv m^{e}\\ \\textrm{mod}\\ (p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}})$，则有\n$$\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n记$\\phi_{i}=\\phi(p_{i}^{a_{i}})$，$g_{i}=(e,\\phi_{i})$，$e_{i}=e/g_{i}$，$d_{i}\\equiv e_{i}^{-1}\\ \\textrm{mod}\\ \\phi_{i}$\n$$\nm^{g_{1}}\\equiv c^{d_{1}}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm^{g_{k}}\\equiv c^{d_{k}}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n这时处理的方式不唯一；我们只考虑那些$g_{i}$很小的线程同余方程，不妨设$g_{1},\\cdots,g_{t}$很小；\n\n(1)$g_{1}=\\cdots =g_{s}=r$，$s\\leqslant t$(不妨设前$s$个$g_{i}$相等)\n\n利用中国剩余定理求解前$s$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$下的解；当$m^{r}<p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$时，直接对解开$r$次方即得$m$；\n\n(2)一般情况，$g_{i}(i=1,\\cdots,t)$很小但是大多数各不相同\n\n那么首先对每个方程组利用上述工具求解(记$x_{i}$为第$i$个方程的解，此时大多数方程组有多个解，每个方程组的解最多有$g_{i}$个)\n\n$$\nm\\equiv x_{1}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm\\equiv x_{k}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n\n利用中国剩余定理求解前$t$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{k}^{a_{t}}$下的解；当$m<p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}$时，$m$必在这些解中。\n\n注：其实这里也解释了为什么考虑那些$g_{i}$很小的线程同余方程，我们最多要求解$g_{1}\\cdots g_{t}$个这样的方程组，每个方程组会求出一个解；如果$g_{i}$很大，那么候选的解太多；但是我们要保证$p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}>m$。","tags":["rsa","elgamal"],"categories":["crypto"]},{"title":"攻防世界-密码学-onetimepad","url":"/crypto/Attack-and-Defend-World-Cryptography-Onetimepad.html","content":"## 一、题目信息\n\n附件中包含实现加密的Python脚本，与密文文件。\n\n## 二、分析\n\n### 2.1 有限域$GF(2^{n})$\n\n构造有限域$GF(2^{n})$时，首先需要$GF(2)$上次数为n的本原多项式$g(x)$；对于$GF(2^{n})$上的每个元素$a$，都可以用一个次数不超过$n$的多项式$f_{a}$表示：$f_{a}(x)=\\sum_{i=0}^{n-1}a_{i}\\cdot x^{i}$，其中$a_{n-1}\\cdots a_{0}$是$a$的二进制表示；从而$GF(2^{n})$上的四则运算定义如下：\n\n* 加法：对于$a,b\\in GF(2^{n})$，它们的多项式表示分别为$f_{a},f_{b}$，记$f_{c}=f_{a}+f_{b}$(其中系数的加法为$GF(2)$上的加法，即异或运算)，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a+b$的值；\n\n* 减法：由于$GF(2)$上的加法与减法等价，因此对于$a,b\\in GF(2^{n})$，$a+b=a-b$；\n\n* 乘法：同样地，$a,b$的多项式表示$f_{a},f_{b}$，记$f_c=f_{a}\\cdot f_{b}\\ \\textrm{mod}\\ g$，由于多项式$g$的次数为$n$，故多项式$f_{c}$的次数不超过$n$，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a\\cdot b$的值；\n\n* 除法：先介绍(乘法)逆元，本原多项式是一种具有特殊性质的不可约多项式，对GF(2)上任意次数不超过$n$的多项式f，都存在$GF(2)$上次数不超过n的多项式$h$，使得$f\\cdot h \\equiv 1\\ \\textrm{mod}\\ g$；与$f$作除法等价于与$f$的逆元$h$作乘法；\n\n### 2.2 process(m,k)\n\n考虑$t^{2},t\\in GF(2^{256})$，构造$GF(2^{256})$的本原多项式为$g=x^{256}+x^{10}+x^{5}+x^{2}+1$，记$t$的二进制表示为$t_{n-1}\\cdots t_{0}$，则$t$的多项式表示$f_{t}(x)=\\sum_{i=0}^{n-1}t_{i}\\cdot x^{i}=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})$，考虑$t^{2}$：\n\n$f_{t}^{2}\\ \\textrm{mod}\\ g$\n\n$=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})\\cdot f_{t}\\ \\textrm{mod}\\ g$\n\n$=((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n$=((((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n我们再来对比函数process(m,k)：\n\n```Python\ndef process(m, k):\n    tmp = m ^ k\n    res = 0\n    for i in bin(tmp)[2:]:\n        res = res << 1;\n        if (int(i)):\n            res = res ^ tmp\n        if (res >> 256):\n            res = res ^ P\n    return res\n```\nres=res<<1代表乘以x，多项式的系数全体左移一位；\n\nif (int(i)):res^=tmp等价于res^=int(i)*tmp，代表$+t_{i}\\cdot f_{t}$；\n\nif (res>>256):res^=P代表模本原多项式g；\n\n综上，process(m,k)实际上实现了$GF(2^256)$上的元素$m$与$k$之和的平方$(m+k)^{2}$；\n\n### 2.3 解密过程\n\n$k_{2}=(k_{1}+secret)^{2},k_{3}=(k_{2}+secret)^{2}$(在GF(2^256)上的运算)\n\n$c_{1}=m_{1}\\oplus k_{1},c_{2}=m_{2}\\oplus k_{2},c_{3}=m_{3}\\oplus k_{3}$，其中$c_{i}(i=1,2,3),m_{i}(i=1,2)$已知\n\n则$k_{2}=m_{2}\\oplus c_{2},k_{3}=m_{3}\\oplus c_{3}$，可解出secret：$secret=k_{3}^{1/2}+k_{2}$(在GF(2^256)上的运算)\n\n接下来解出$k_{1}$：$k_{1}=k_{2}^{1/2}+secret$(在GF(2^256)上的运算)\n\n然后解出flag(即$m_{1}$)：$m_{1}=c_{1}\\oplus k_{1}$\n\n## 三、解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,long_to_bytes\n\nK.<x>=GF(2L**256,modulus=x^256+x^10+x^5+x^2+1)\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\ndef solve():\n    cip1=polify(0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07f)\n    cip2=polify(0x630eb4dce274d29a16f86940f2f35253477665949170ed9e8c9e828794b5543c)\n    cip3=polify(0xe913db07cbe4f433c7cdeaac549757d23651ebdccf69d7fbdfd5dc2829334d1b)\n    msg2=polify(bytes_to_long('I_am_not_a_secret_so_you_know_me'))\n    msg3=polify(bytes_to_long('feeddeadbeefcafefeeddeadbeefcafe'))\n    secret=cip2+msg2+(cip3+msg3).sqrt()\n    key1=(cip2+msg2).sqrt()+secret\n    msg1=cip1+key1\n    return long_to_bytes(unpolify(msg1))\n\nif __name__=='__main__':\n    print 'flag{'+solve()+'}'\n```\n\n程序运行结果如下：\n```Bash\n$ sage solve.sage\nflag{t0_B3_r4ndoM_en0Ugh_1s_nec3s5arY}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-sleeping-guard","url":"/crypto/Attack-and-Defense-World-Cryptography-Sleeping-Guard.html","content":"## 一、题目信息\n\n点击还原比赛场景后，会给出镜像服务器的ip以及连接端口。且提示：“只有真正的hacker才能看到这张图片”\n\n## 二、分析\n\n连接上服务器之后，服务器返回的数据看上去像base64编码，对此，解码即可；根据题目的提示，flag藏在图片中，解码后文件头数据不是png,jpg,bmp文件头格式(说明不是直接解码这么简单)，也不是zip,rar,7z文件头格式(说明不是将图片加密压缩)；实际上，原比赛的此题还有一个Python脚本，大致意思是使用长度为12的密钥与图片数据进行(循环)异或加密，有了这个信息之后，尝试使用各种图片格式的文件头与加密数据进行异或得到密钥，使用png格式的文件头与加密数据进行异或时，得到的结果“很像”密钥；接下来使用密钥解密即可。\n\n## 三、解题\n\n首先从服务器接收全部的数据，再进行base64解码(将解码后的数据存入文件data)；\n\n然后通过png文件头解出密钥，然后通过密钥解密，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom binascii import unhexlify\nfrom Crypto.Util.strxor import strxor\n\ndef enc(data,key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve(data):\n    head=unhexlify('89504e470d0a1a0a0000000d49484452')\n    key=strxor(head,data[:16])\n    with open('sleeping-guard.png','wb') as f:\n        f.write(enc(data,key[:12]))\n\nif __name__=='__main__':\n    with open('data','rb') as f:\n        solve(f.read())\n```\n\n最后解密出图片\n\n{% asset_img 1.png pic1 %}","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-streamgame1","url":"/crypto/Attack-and-Defend-World-Cryptography-StreamGame1.html","content":"## 一、题目信息\n\n附件给出实现流加密的Python脚本与一段输出的密钥流。\n\n## 二、分析\n\n通过对加密脚本的理解，可得本题的LFSR模型：\n{% asset_img 1.png pic1 %}\n\n其中 $a_{n-1},a_{n-2},\\cdots,a_0$ 为程序中 mask 的二进制位，当 $a_i=1$ 时，将 $b_i$ 输入异或运算，否则 $b_i$ 不输入异或运算；根据模型我们可以得到如下等式：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{1}   & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nb_{0}   & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n其中的加法为异或，因为$a_{n-1} =1$，将上式重写如下：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n由异或性质：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n再将等式“还原”：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nk_{2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nk_{n-1} & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{n} & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n计算的顺序由下至上，即可解出初始状态的所有比特位。\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom gmpy2 import c_div\n\ndef lfsr(R,mask):\n    output = (R << 1) & 0xffffff    \n    i=(R&mask)&0xffffff             \n    lastbit=0\n    while i!=0:\n        lastbit^=(i&1)    \n        i=i>>1\n    output^=lastbit\n    return (output,lastbit)\n\ndef cal(s,mask):\n    lm=len(bin(mask))-2\n    R=int(s[-1:]+s[:-1],2)\n    ss=''\n    for j in range(lm,0,-1):\n        (_,tk)=lfsr(R,mask)\n        ss=str(tk)+ss\n        R=int(s[j-2]+str(tk)+bin(R)[2:].rjust(lm,'0')[1:-1],2)\n    return ss\n\ndef solve():\n    mask=0b1010011000100011100\n    lm=len(bin(mask))-2\n    with open('key','rb') as f:\n        stream=f.read(c_div(lm,8))\n    s=''.join([bin(256+ord(it))[3:] for it in stream])\n    flag='flag{'+cal(s[:lm],mask)+'}'\n    return flag\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{1110101100001101011}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"GACTF2020密码学部分详解","url":"/crypto/GACTF2020-Cryptography-Section.html","content":"### 前言\n\n比赛网址：[GACTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=147&hash=cf494a33-0f22-4e85-a48d-7a02efeedc90.event)\n[writeup参考链接](https://0xdktb.top/2020/08/30/WriteUp-GACTF2020-Crypto/)\n\n## 一、ezAES\n\n### 1.1 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF/ezAES)的challeng.py。\n\n### 1.2 分析\n\n整体浏览Python脚本后，可得此题考察CBC分组加密工作模式；总结一下脚本给出的信息：\n* key给出前14位(key长16位，即最后2位未知)\n* message的长度为86字节，因此明文最后一组填充10个'\\n'\n* 密文最后一组给出后10个字节\n\n因此，可穷举key的最后2位，每一位考虑所有可打印字符，有100种可能，因此穷举key的最后2位有$10^{4}$种可能，处于合理范围；对每一个key，解密最后一组密文，将解密出的明文后10位与上一组密文后10位异或，若异或后均为'\\n'，则说明穷举出正确的key；\n解出正确的key之后，可按照同样的方式计算出SECRET，从而获取整个明文；\n已知所有明文之后，由CBC工作模式：$m_{i}=D(c_{i};key)\\oplus c_{i-1},i=n,\\cdots,1$，其中$c_{0}=IV$，那么已知最后一组密文，就可以递推出IV：$c_{i-1}=D(c_{i};key)\\oplus m_{i},i=n,\\cdots,1$\n\n### 1.3 解题\n\n上述链接中的solve.py为解题的Python脚本；\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n[+] MBruteforcing: Found key: \"pd\"\n9j_for_aes_cbc!!\n```\n\n## 二、what_r_the_noise\n\n### 2.1 题目信息\n\n噪音太大，听不见，China:124.71.145.165:9999(现在应该已经失效了)。\n\n### 2.2 分析\n\n大致意思是服务器返回的数据是加入了噪声的，让你去掉噪声，解出正确的明文；有点概率论知识应该想到获取多次数据取平均值。\n\n### 2.3 解题\n\n解题的Python脚本在[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/what_r_the_noise)中；\n\n解出的flag可能不完全正确，但是你基本可以猜出是什么单词了！\n\n最后得到flag为gactf{you_know_much_about_differential_privacy}\n\n## 三、da Vinci after rsa\n\n### 3.1 题目信息\n\n附件中包含两个文本文件encryption与output；encryption中是一列数，output给出“RSA公钥”与密文；[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/da_Vinci_after_rsa)\n\n### 3.2 分析\n\nda Vinci翻译了一下(英语不好)是达芬奇，这既然是密码学题目，自然去查了一下达芬奇密码，发现这是一本书，在网上不停地查这本书，找到一个片段，“打乱的数字”一下引起我的注意，后面马上提到“斐波那契数列”，回去一看，encryption中的那一列数确实是打乱的斐波那契数列，到此encryption的作用弄明白了；\n\n接下来将公钥的模数N放到yafu中分解，得到三个因子；但是我想，不怕，和RSA问题一样求解$d\\equiv e^{-1}\\ \\textrm{mod}\\ \\phi(N)$即可解出$m\\equiv c^{d}\\ \\textrm{mod}\\ N$，编好程序运行时发现$e$在$\\phi(N)$下没有逆，这一下子就不知道怎么办了，其实这样的方程也是有办法求解的，[求解思路链接在此](https://chu-kangming.gitee.io/crypto/Elgamal-RSA-summary.html)\n\n解出的$m$虽然有多个，但是flag每个字符都是可见字符，这样最后只剩下一个$m$，这还不是flag；花括号内正好25个字符，encryption中正好25个数，按照一样的规则打乱花括号内的25个字符即得到真正的flag；\n\n### 3.3 解题\n\n上述GitHub备份链接中的solve.sage脚本为解题的sage脚本；\n\n程序运行结果如下：\n\n```Bash\n$ sage solve.sage\nflag{w5awd4fa994f87_dwad3123_2}\n```\n\n## 四、elgamal_rsa\n\n### 4.1 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/elgamal_rsa)\n\n### 4.2 分析\n\n$g^{q}\\equiv 1\\ \\textrm{mod}\\ p,h\\equiv g^{d}\\ \\textrm{mod}\\ p$\n\n$c_{1}\\equiv g^{r_{1}}\\ \\textrm{mod}\\ p,c_{2}\\equiv m\\cdot h^{r_{1}}\\ \\textrm{mod}\\ p$\n\n$c_{11}\\equiv g^{r_{2}}\\ \\textrm{mod}\\ p,c_{22}\\equiv m\\cdot h^{r_{2}}\\ \\textrm{mod}\\ p$\n\n其中，$r_{2}\\equiv (B\\cdot r_{1}+A)\\ \\textrm{mod}\\ q$\n\n这里的$m$就是$secret$，$secret$是下面“RSA”加密的模数，因此首先要解出$secret$，这也是很好解的；\n\n$c_{2}^{B}\\cdot h^{A}\\equiv (m\\cdot h^{r_{1}})^{B}\\cdot h^{A}\\equiv m^{B}\\cdot h^{B\\cdot r_{1}+A}\\equiv m^{B-1}\\cdot c_{22}\\ \\textrm{mod}\\ p$\n\n$m^{B-1}\\equiv c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1}\\ \\textrm{mod}\\ p$，计算$t\\equiv (B-1)^{-1}\\ \\textrm{mod}\\ (p-1)$\n\n那么$(c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1})^{t}\\equiv m\\ \\textrm{mod}\\ p$\n\n解出$secret$后，放到yafu里面分解(因子是真的多，一度怀疑自己解错了)，[求解flag的思路链接](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n### 4.3 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出secret；第二步，求解方程$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但是$(e,\\phi(N))>1$)；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n329380824451982777596468080979390700896875051159309053251427777390225223390054462862874890632092714850180031743329031313028975903871751004003831036860000454098274963081490031808010876171935539110201531253322208564941373067673598629247111527738724700328114569409692796434368030258427126193825227856160081569366870307559297674909108870298864572520476006338972072593434914773857347865349086098662711283463352902488164071184362082990162654586995346553108747183805073294471613391819978413596510467204977114038549473397779377039088475929677184284430986636686769839308217865627271293739711926018699557041530631349486791876338842184994986024157099233298972714917732995013317087756483\n```\n\n```Bash\n$ sage step2.sage\nyou_4re_good_at_b0th_el94mal_and_rs4\n```\n\n## 五、babycrypto\n\n### 5.1 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/babycrypto)\n\n### 5.2 分析\n\n在GF(p)上定义的点集$\\{(x,y)|x,y\\in GF(p)\\}$上定义加法\"+\"：$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}x_{2}-y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})$，定义乘法\"$\\cdot$\"：$k\\cdot (x,y)=(x,y)+\\cdots +(x,y)$\n\n给出基点g，$A=a\\cdot g,B=b\\cdot g$，给出A,B；\n\n$shared=b\\cdot A$，再利用shared生成AES密钥进行加密；\n\np未知！！！先介绍Edwards曲线E：$x^{2}+y^{2}\\equiv 1+dx^{2}y^{2}\\ \\textrm{mod}\\ p$，曲线上的加法定义为$(x_{1},y_{1})+(x_{2},y_{2})=((x_{1}y_{2}+x_{2}y_{1})/(1+dx_{1}x_{2}y_{1}y_{2}),(x_{1}x_{2}-y_{1}y_{2})/(1-dx_{1}x_{2}y_{1}y_{2}))$\n\n令d=0，则E：$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，则加法重写为$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}y_{2}+x_{2}y_{1},x_{1}x_{2}-y_{1}y_{2})$\n\n若我们设定d=0，那么$A(x_{1},y_{1}),B(x_{2},y_{2})$满足方程$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，求$x_{1}^{2}+y_{1}^{2}-1$与$x_{2}^{2}+y_{2}^{2}-1$的公约数，则p是其最大素因子；\n\n下面考虑如何解出b，这是一个离散对数问题，难点是sage并未实现Edwards曲线及其运算；\n\n给出一个有用的结论：$\\{(x,y)|x,y\\in GF(p),x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p\\}$与$H=F_{p}(w)/(w^{2}+1)$(有限域$F_{p}$上的多项式在模$w^{2}+1$下的剩余环)同构，同构映射$\\sigma :E\\rightarrow H$，$\\sigma((x,y))=x+yw$\n\n在sage中通过extend函数就可以生成H，从而可以求解此离散对数问题；\n\n### 5.3 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出p；第二步，解出b然后以同样的方式生成AES密钥再对消息进行解密；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n435393448000740628395634230535241428961470055780764193459123534837759996\n```\n\n使用yafu分解，可得到p(在solve.sage中有给出)\n\n```Bash\n$ sage solve.sage\ngactf{354b6ce4c03387a828a3c30061213204}\n```","tags":["ctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-xor_game","url":"/crypto/Attack-and-Defend-World-Cryptography-XOR-GAME.html","content":"## 一、题目信息\n\n题目给出实现加密的程序，且指出明文是一首诗。\n\n## 二、分析\n\n先总结一下有用的信息：\n* 明文是有意义的英文，即明文均为可见字符且明文中的各字母出现的频率接近统计规律(在够长的一段话里，各个字母的占比大致稳定，并且这个稳定值已经用巨大的语料库统计出来了，这就是字母频率)\n\n* 密钥均为可见字符\n\n* 加密时对密钥进行了重用\n\n解决方案可分为程序分析与如果人工分析两部分；\n(1)程序分析：穷举密钥的长度，对每一长度的密钥，筛选密钥每一位可行的字符集合(要求此密钥位为可见字符，且那些被此密钥位解密出的明文位亦为可见字符)，如果密钥某一位可行的字符集合为空，则说明当前穷举的长度不是密钥的长度，这一步结束之后，可确定密钥的长度，以及密钥每一位可能的字符值；\n\n注：就实际情况来看，如果穷举的长度不是密钥的长度，几乎一定会有密钥某一位可行的字符集合为空。\n\n接下来，利用词频分析对密钥每一位进行爆破：对密钥的每一位，使用上一步得到的候选字符集中不同字符将解密出不同的明文，其中各字母出现的频率也不会相同，计算各字母出现的频率分布与统计规律的相似程度，选择相似程度最高的字符作为此密钥位。\n\n注：相似度计算公式：$score=\\sum_{i=1}^{26}p_{i}*q_{i}$，其中$p_{i}$是明文中第$i$个字母出现的频率，$q_{i}$是已统计出的第$i$个字母的频率。$q_{i}$的值见下面的程序。\n\n(2)人工分析：经过(1)，可猜对大部分密钥位，之后再结合解密出的明文对错误的密钥位进行修正。\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.strxor import strxor\nfrom string import printable\nfrom base64 import b64decode\n\nfreq={'e':0.12702,'t':0.09056,'a':0.08167,'o':0.07507,\n        'i':0.06966,'n':0.06749,'s':0.06327,'h':0.06094,\n        'r':0.05987,'d':0.04253,'l':0.04025,'c':0.02782,\n        'u':0.02758,'m':0.02406,'w':0.02360,'f':0.02228,\n        'g':0.02015,'y':0.01974,'p':0.01929,'b':0.01492,\n        'v':0.00978,'k':0.00772,'j':0.00153,'x':0.00150,\n        'q':0.00095,'z':0.00074\n        }\n\ndef frequency(msg):\n    global freq\n    cnum=[len([s for s in msg if s==cc or s==cc.upper()]) for cc in freq.keys()]\n    csum=sum(cnum)\n    if csum==0:\n        return 0\n    return sum([x*y for x,y in zip(freq.values(),cnum)])/csum\n\ndef analysis(ks,cip):\n    lks=[len(sk) for sk in ks]\n    lc=len(cip)\n    step=len(lks)\n    key=[]\n    for ii,sk in enumerate(ks):\n        scores=[frequency(''.join([strxor(cip[ind],ik) for ind in range(ii,lc,step)])) for ik in sk]\n        key.append(sk[scores.index(max(scores))])\n    return key\n\ndef guessK(cip,low=4,high=33):\n    lc=len(cip)\n    for step in range(low,high):\n        ks=[]\n        for c1 in range(step):\n            optK=list(printable[:-6])\n            optK=[ik for ik in optK if ik not in \"{}'\\\"`^\"]\n            for ind in range(c1,lc,step):\n                tt=optK[:]\n                for ik in tt:\n                    if not strxor(cip[ind],ik) in printable:\n                        optK.remove(ik)\n            if len(optK)==0:\n                break\n            ks.append(optK[:])\n        if len(ks)<step:\n            continue\n        return analysis(ks,cip)\n\ndef enc(data, key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve():\n    with open('cipher.txt','r') as f:\n        cip=b64decode(f.read())\n    key=guessK(cip)\n    lc=len(cip)\n    lk=len(key)\n    while 1:\n        while 1:\n        print('\\033[1;31m'+''.join(key)+'\\033[0m')\n        msg=enc(cip,''.join(key))\n        out=['['+str(ii/lk)+']['+msg[ii:(ii+lk)]+']' for ii in range(0,lc-lk,lk)]\n        out.append('['+str(lc/lk)+']['+msg[-(lc%lk+lk):-(lc%lk)]+']')\n        if lc%lk:\n            out.append('['+str(lc/lk+1)+']['+msg[-(lc%lk):]+']')\n        print ''.join(out)\n        if raw_input('\\033[1;31m need correction(y) or not(n)\\033[0m')=='n':\n            break\n        row=int(raw_input('\\033[1;31m row \\033[0m'))\n        col=int(raw_input('\\033[1;31m col \\033[0m'))\n        cor=raw_input('\\033[1;31m correction \\033[0m')\n        key[col]=strxor(cip[row*lk+col],cor)\n    with open('msg','w') as f:\n        f.write(msg)\n    print('\\033[1;31m'+''.join(key)+'\\033[0m')\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```txt\n$ python solve.py\nxo7_is_,nte,estingn@f\n[0][\nL,fe, 1hin~and li(h1][1][-o#f ti(e a0d timeoa\"][2][ai+\nFri3olo+s tire#e6][3][s\n*ne\nIehea,d the *c-][4][o,efromethe~valley< $][5][ndethe -ear*\nOpen ;oe][6][th  lon ly -oul ofos,][7][ck)e ha7ves*ing\nRe?e$][8][t *utri\"htl', but .l6][9][o 7epea1 th; well--e,][10][ngeof\nE3ent+ally s8a<][11][in\" in 1he :esert  a6][12][isOI be)iev; I am\no7][13][n $s th  br7ght su\"m ][14][r #lowe7s\nD1 not w&t-][15][er d un!efe?ted fi*r<][16][ d mon 7uleTHeart =a1][17][e $nd b7eat6ing toob ][18][arethe )oad~of theoc0][19][mb rsom \nBo,ed\nTwoEIe][20][he$rd t-e m+sic, f=o(][21][ t-e mo*n a0d carc.s6][22][\nA0xili$ry ;xtremeoa ][23][st-etic,sm <ait tooc$][24][pt0re m,styTFillin( 1][25][heeinte+se 2ife, b:te][26][al6o fi)lin9 the p:r ][27][\nT-ere $re ?lways \"e(][28][or,es t-rou9hout t'ee][29][ea7th\nIebel7eve I .mO][30][Di d asethe~quiet -e$][31][ut< of $utu3n leav*sO][32][Sh ng i6 no* chaosc 6][33][mo.e ge6tur;\nEven 8i)][34][t $lso 7eta7ned bo!ee][35][pr*udlyeQin9 Feng \"u6][36][cl \nOcc0lt\n\nhree\nIoh ][37][arelovei I <elieveoi+][38][ l*ve\nL*ve 7s a po le][39][ofestru\"gli0g bluebg7][40][ee+ alg$e\nA- desol.t ][41][ m,cro-'urs* of wi!dO][42][Bl edin\" th,ough m6 3][43][ei+s\nYe$rs -tation*de][44][inethe 'eli;f\nFourEIe][45][be)ieveetha* all c.ne][46][he$r\nEv n a0ticipa;ee][47][di6cret , I~met th* *][48][th r th ir 1wn\nSom* &][49][anenot \"ras. the m m ][50][ntOLefteto *he Eas; 1][51][o \"o We6t, *he dea+ (][52][us1 noteret+rn to !o2][53][he7e\nSe , I~wear Z.ne][54][Fl*werseon 3y headc ,][55][n #ull 'loo3 alongot-][56][e 2ay a)l t6e way\n\tr ][57][qu ntlyemis-ed som*,e][58][bu1 als* de;ply mo9e!][59][ b< win!, f,ost, s!o2][60][ o7 rai+\nFi(e\nPraj!ae][61][Pa7amit$, s1on as <o*][62][n $s\nli#e b; beaut&f0][63][l )ike 6umm;r flow*r6][64][ a+d de$th 2ike au;u(][65][n )eave6\nAl-o careoa'][66][n )eave6\nAl-o careoa'][67][ou1 wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 2\ncorrection: i\nxor_is_,nte,estingn@f\n[0][\nLife, 1hin~and li(h1][1][-off ti(e a0d timeoa\"][2][ain\nFri3olo+s tire#e6][3][s\none\nIehea,d the *c-][4][o, fromethe~valley< $][5][nd the -ear*\nOpen ;oe][6][the lon ly -oul ofos,][7][ckle ha7ves*ing\nRe?e$][8][t outri\"htl', but .l6][9][o repea1 th; well--e,][10][ng of\nE3ent+ally s8a<][11][ing in 1he :esert  a6][12][is\nI be)iev; I am\no7][13][n as th  br7ght su\"m ][14][r flowe7s\nD1 not w&t-][15][ered un!efe?ted fi*r<][16][ demon 7uleTHeart =a1][17][e and b7eat6ing toob ][18][ar the )oad~of theoc0][19][mbersom \nBo,ed\nTwoEIe][20][heard t-e m+sic, f=o(][21][ the mo*n a0d carc.s6][22][\nAuxili$ry ;xtremeoa ][23][sthetic,sm <ait tooc$][24][pture m,styTFillin( 1][25][he inte+se 2ife, b:te][26][also fi)lin9 the p:r ][27][\nThere $re ?lways \"e(][28][ories t-rou9hout t'ee][29][earth\nIebel7eve I .mO][30][Died asethe~quiet -e$][31][uty of $utu3n leav*sO][32][Sheng i6 no* chaosc 6][33][moke ge6tur;\nEven 8i)][34][t also 7eta7ned bo!ee][35][proudlyeQin9 Feng \"u6][36][cle\nOcc0lt\n\nhree\nIoh ][37][ar lovei I <elieveoi+][38][ love\nL*ve 7s a po le][39][of stru\"gli0g bluebg7][40][een alg$e\nA- desol.t ][41][ micro-'urs* of wi!dO][42][Bleedin\" th,ough m6 3][43][eins\nYe$rs -tation*de][44][in the 'eli;f\nFourEIe][45][believeetha* all c.ne][46][hear\nEv n a0ticipa;ee][47][discret , I~met th* *][48][ther th ir 1wn\nSom* &][49][an not \"ras. the m m ][50][nt\nLefteto *he Eas; 1][51][o go We6t, *he dea+ (][52][ust noteret+rn to !o2][53][here\nSe , I~wear Z.ne][54][Flowerseon 3y headc ,][55][n full 'loo3 alongot-][56][e way a)l t6e way\n\tr ][57][quentlyemis-ed som*,e][58][but als* de;ply mo9e!][59][ by win!, f,ost, s!o2][60][ or rai+\nFi(e\nPraj!ae][61][Paramit$, s1on as <o*][62][n as\nli#e b; beaut&f0][63][l like 6umm;r flow*r6][64][ and de$th 2ike au;u(][65][n leave6\nAl-o careoa'][66][n leave6\nAl-o careoa'][67][out wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 7\ncorrection: t\nxor_is_inte,estingn@f\n[0][\nLife, thin~and li(h1][1][-off time a0d timeoa\"][2][ain\nFrivolo+s tire#e6][3][s\none\nI hea,d the *c-][4][o, from the~valley< $][5][nd the hear*\nOpen ;oe][6][the lonely -oul ofos,][7][ckle harves*ing\nRe?e$][8][t outrightl', but .l6][9][o repeat th; well--e,][10][ng of\nEvent+ally s8a<][11][ing in the :esert  a6][12][is\nI believ; I am\no7][13][n as the br7ght su\"m ][14][r flowers\nD1 not w&t-][15][ered undefe?ted fi*r<][16][ demon ruleTHeart =a1][17][e and breat6ing toob ][18][ar the load~of theoc0][19][mbersome\nBo,ed\nTwoEIe][20][heard the m+sic, f=o(][21][ the moon a0d carc.s6][22][\nAuxiliary ;xtremeoa ][23][stheticism <ait tooc$][24][pture mistyTFillin( 1][25][he intense 2ife, b:te][26][also fillin9 the p:r ][27][\nThere are ?lways \"e(][28][ories throu9hout t'ee][29][earth\nI bel7eve I .mO][30][Died as the~quiet -e$][31][uty of autu3n leav*sO][32][Sheng is no* chaosc 6][33][moke gestur;\nEven 8i)][34][t also reta7ned bo!ee][35][proudly Qin9 Feng \"u6][36][cle\nOccult\n```\n\n\n\n```txt\nhree\nIoh ][37][ar love, I <elieveoi+][38][ love\nLove 7s a po le][39][of struggli0g bluebg7][40][een algae\nA- desol.t ][41][ micro-burs* of wi!dO][42][Bleeding th,ough m6 3][43][eins\nYears -tation*de][44][in the beli;f\nFourEIe][45][believe tha* all c.ne][46][hear\nEven a0ticipa;ee][47][discrete, I~met th* *][48][ther their 1wn\nSom* &][49][an not gras. the m m ][50][nt\nLeft to *he Eas; 1][51][o go West, *he dea+ (][52][ust not ret+rn to !o2][53][here\nSee, I~wear Z.ne][54][Flowers on 3y headc ,][55][n full bloo3 alongot-][56][e way all t6e way\n\tr ][57][quently mis-ed som*,e][58][but also de;ply mo9e!][59][ by wind, f,ost, s!o2][60][ or rain\nFi(e\nPraj!ae][61][Paramita, s1on as <o*][62][n as\nlife b; beaut&f0][63][l like summ;r flow*r6][64][ and death 2ike au;u(][65][n leaves\nAl-o careoa'][66][n leaves\nAl-o careoa'][67][out what ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 11\ncorrection:  \nxor_is_interestingn@f\n[0][\nLife, thin and li(h1][1][-off time and timeoa\"][2][ain\nFrivolous tire#e6][3][s\none\nI heard the *c-][4][o, from the valley< $][5][nd the heart\nOpen ;oe][6][the lonely soul ofos,][7][ckle harvesting\nRe?e$][8][t outrightly, but .l6][9][o repeat the well--e,][10][ng of\nEventually s8a<][11][ing in the desert  a6][12][is\nI believe I am\no7][13][n as the bright su\"m ][14][r flowers\nDo not w&t-][15][ered undefeated fi*r<][16][ demon rule\nHeart =a1][17][e and breathing toob ][18][ar the load of theoc0][19][mbersome\nBored\nTwoEIe][20][heard the music, f=o(][21][ the moon and carc.s6][22][\nAuxiliary extremeoa ][23][stheticism bait tooc$][24][pture misty\nFillin( 1][25][he intense life, b:te][26][also filling the p:r ][27][\nThere are always \"e(][28][ories throughout t'ee][29][earth\nI believe I .mO][30][Died as the quiet -e$][31][uty of autumn leav*sO][32][Sheng is not chaosc 6][33][moke gesture\nEven 8i)][34][t also retained bo!ee][35][proudly Qing Feng \"u6][36][cle\nOccult\nThree\nIoh ][37][ar love, I believeoi+][38][ love\nLove is a po le][39][of struggling bluebg7][40][een algae\nAs desol.t ][41][ micro-burst of wi!dO][42][Bleeding through m6 3][43][eins\nYears station*de][44][in the belief\nFourEIe][45][believe that all c.ne][46][hear\nEven anticipa;ee][47][discrete, I met th* *][48][ther their own\nSom* &][49][an not grasp the m m ][50][nt\nLeft to the Eas; 1][51][o go West, the dea+ (][52][ust not return to !o2][53][here\nSee, I wear Z.ne][54][Flowers on my headc ,][55][n full bloom alongot-][56][e way all the way\n\tr ][57][quently missed som*,e][58][but also deeply mo9e!][59][ by wind, frost, s!o2][60][ or rain\nFive\nPraj!ae][61][Paramita, soon as <o*][62][n as\nlife be beaut&f0][63][l like summer flow*r6][64][ and death like au;u(][65][n leaves\nAlso careoa'][66][n leaves\nAlso careoa'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 18\ncorrection: g\nxor_is_interesting!@f\n[0][\nLife, thin and ligh1][1][-off time and time a\"][2][ain\nFrivolous tirele6][3][s\none\nI heard the ec-][4][o, from the valleys $][5][nd the heart\nOpen toe][6][the lonely soul of s,][7][ckle harvesting\nRepe$][8][t outrightly, but al6][9][o repeat the well-be,][10][ng of\nEventually swa<][11][ing in the desert oa6][12][is\nI believe I am\nBo7][13][n as the bright summ ][14][r flowers\nDo not wit-][15][ered undefeated fier<][16][ demon rule\nHeart ra1][17][e and breathing to b ][18][ar the load of the c0][19][mbersome\nBored\nTwo\nIe][20][heard the music, fro(][21][ the moon and carcas6][22][\nAuxiliary extreme a ][23][stheticism bait to c$][24][pture misty\nFilling 1][25][he intense life, bute][26][also filling the pur ][27][\nThere are always me(][28][ories throughout thee][29][earth\nI believe I amO][30][Died as the quiet be$][31][uty of autumn leavesO][32][Sheng is not chaos, 6][33][moke gesture\nEven wi)][34][t also retained bonee][35][proudly Qing Feng mu6][36][cle\nOccult\nThree\nI h ][37][ar love, I believe i+][38][ love\nLove is a poole][39][of struggling blue-g7][40][een algae\nAs desolat ][41][ micro-burst of windO][42][Bleeding through my 3][43][eins\nYears stationede][44][in the belief\nFour\nIe][45][believe that all cane][46][hear\nEven anticipatee][47][discrete, I met the *][48][ther their own\nSome &][49][an not grasp the mom ][50][nt\nLeft to the East 1][51][o go West, the dead (][52][ust not return to no2][53][here\nSee, I wear Zane][54][Flowers on my head, ,][55][n full bloom along t-][56][e way all the way\nFr ][57][quently missed some,e][58][but also deeply move!][59][ by wind, frost, sno2][60][ or rain\nFive\nPrajnae][61][Paramita, soon as so*][62][n as\nlife be beautif0][63][l like summer flower6][64][ and death like autu(][65][n leaves\nAlso care a'][66][n leaves\n```\n\n\n\n```txt\nAlso care a'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 20\ncorrection: t\nxor_is_interesting!@#\n[0][\nLife, thin and light][1][-off time and time ag][2][ain\nFrivolous tireles][3][s\none\nI heard the ech][4][o, from the valleys a][5][nd the heart\nOpen to ][6][the lonely soul of si][7][ckle harvesting\nRepea][8][t outrightly, but als][9][o repeat the well-bei][10][ng of\nEventually sway][11][ing in the desert oas][12][is\nI believe I am\nBor][13][n as the bright summe][14][r flowers\nDo not with][15][ered undefeated fiery][16][ demon rule\nHeart rat][17][e and breathing to be][18][ar the load of the cu][19][mbersome\nBored\nTwo\nI ][20][heard the music, from][21][ the moon and carcass][22][\nAuxiliary extreme ae][23][stheticism bait to ca][24][pture misty\nFilling t][25][he intense life, but ][26][also filling the pure][27][\nThere are always mem][28][ories throughout the ][29][earth\nI believe I am\n][30][Died as the quiet bea][31][uty of autumn leaves\n][32][Sheng is not chaos, s][33][moke gesture\nEven wil][34][t also retained bone ][35][proudly Qing Feng mus][36][cle\nOccult\nThree\nI he][37][ar love, I believe in][38][ love\nLove is a pool ][39][of struggling blue-gr][40][een algae\nAs desolate][41][ micro-burst of wind\n][42][Bleeding through my v][43][eins\nYears stationed ][44][in the belief\nFour\nI ][45][believe that all can ][46][hear\nEven anticipate ][47][discrete, I met the o][48][ther their own\nSome c][49][an not grasp the mome][50][nt\nLeft to the East t][51][o go West, the dead m][52][ust not return to now][53][here\nSee, I wear Zan ][54][Flowers on my head, i][55][n full bloom along th][56][e way all the way\nFre][57][quently missed some, ][58][but also deeply moved][59][ by wind, frost, snow][60][ or rain\nFive\nPrajna ][61][Paramita, soon as soo][62][n as\nlife be beautifu][63][l like summer flowers][64][ and death like autum][65][n leaves\nAlso care ab][66][n leaves\nAlso care ab][67][out what has]\nneed correction(y) or not(n)n\nxor_is_interesting!@#\n```\n\n","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-equation-2","url":"/crypto/Attack-and-Defend-World-Cryptography-Equation-2.html","content":"## 一、题目信息\n\n题目描述“RSA私钥上面的部分被屏蔽了请恢复私钥并解密文件”，附件给出私钥编码的截图，但是只能看见最后5行。\n\n## 二、分析\n\n### 2.1 OpenSSL私钥结构\n\n私钥信息按如下顺序排列：\nversion | pad | n | pad | e | pad | d | pad | p | pad | q | pad | x1 | pad | x2 | pad | x3\n其中，pad是填充信息，各pad并不同，$x_{1}= d\\ \\textrm{mod}\\ (p-1),x_{2}= d\\ \\textrm{mod}\\ (q-1),x_{3}=p^{-1}\\ \\textrm{mod}\\ q$，填充pad用来注释接下来的大数的(字节)长度，\\x02为pad开头的标记，有时后面接\\x81或\\x82，这用来标记长度值所占用的字节(\\x81代表占用1个字节，\\x82代表占用2个字节)，有时后面不接\\x81或\\x82而直接放置长度；\n例：\\x02\\x03代表接下来的大数的字节长度为3个字节；\\x02\\x81\\x80，首先，\\x81代表长度占用1个字节，因此\\x80就是长度值，即128，表明接下来的大数的字节长度为128个字节。\n\n将私钥信息按照上述顺序排列好之后，再进行base64编码。\n\n### 2.2 利用已知信息恢复私钥\n\n截图可见编码为\n```Bash\nOs9mhOQRdqW2cwVrnNI72DLcAXpXUJ1HGwJBANWiJcDUGxZpnERxVw7s0913WXNtV4GqdxCzG0pG5EHThtoTRbyX0aqRP4U/hQ9tRoSoDmBn+3HPITsnbCy67VkCQBM4xZPTtUKM6Xi+16VTUnFVs9E4rqwIQCDAxn9UuVMBXlX2Cl0xOGUF4C5hItrX2woF7LVS5EizR63CyRcPovMCQQDVyNbcWD7N88MhZjujKuSrHJot7WcCaRmTGEIJ6TkU8NWt9BVjR4jVkZ2EqNd0KZWdQPukeynPcLlDEkIXyaQx\n```\n\n解码后结合OpenSSL私钥结构分析可得：x1,x2,x3为已知；但是仅有x1,x2,x3并不能恢复出p,q与d，若我们假设e为常用的指数3,65537等等，则可试出p与q：\n\n$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)(q-1)$\n则有$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$与$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n由$x_{1}$与$x_{2}$的定义可得$x_{1}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$，$x_{2}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n因此$(p-1)|(x_{1}\\cdot e-1)$；\n记$x_{1}\\cdot e-1=r_{1}\\cdot (p-1)$；\n由于$x_{1}= d\\ \\textrm{mod}\\ (p-1)$，则$x_{1}<(p-1)$；\n几乎可以看做$x_{1}\\cdot e=r_{1}\\cdot (p-1)$，那么必有$r_{1}<e$；\n同理可得$r_{2}<e$，其中$x_{2}\\cdot e-1=r_{2}\\cdot (q-1)$\n可以看到，$r_{i}<e,i=1,2$，从而可使用试除法求出$r_{i},i=1,2$；\n则$p=(x_{1}\\cdot e-1)/r_{1}+1,q=(x_{2}\\cdot e-1)/r_{2}+1$；\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,isPrime,inverse\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\ndef genKey(X1,X2,X3):\n    e=65537L\n    N1=X1*e-1\n    N2=X2*e-1\n    for r in range(e):\n        if N1%(e-r)==0:\n            p=N1/(e-r)+1\n            if isPrime(p):\n                break\n    for r in range(e):\n        if N2%(e-r)==0:\n            q=N2/(e-r)+1\n            if isPrime(q):\n                break\n    N=p*q\n    phi=(p-1)*(q-1)\n    d=inverse(e,phi)\n    assert inverse(q,p)==X3\n    return RSA.construct((N,e,long(d),p,q))\n\ndef solve():\n    X1=bytes_to_long('\\xd5\\xa2%\\xc0\\xd4\\x1b\\x16i\\x9cDqW\\x0e\\xec\\xd3\\xddwYsmW\\x81\\xaaw\\x10\\xb3\\x1bJF\\xe4A\\xd3\\x86\\xda\\x13E\\xbc\\x97\\xd1\\xaa\\x91?\\x85?\\x85\\x0fmF\\x84\\xa8\\x0e`g\\xfbq\\xcf!;\\'l,\\xba\\xedY')\n    X2=bytes_to_long('\\x138\\xc5\\x93\\xd3\\xb5B\\x8c\\xe9x\\xbe\\xd7\\xa5SRqU\\xb3\\xd18\\xae\\xac\\x08@ \\xc0\\xc6\\x7fT\\xb9S\\x01^U\\xf6\\n]18e\\x05\\xe0.a\"\\xda\\xd7\\xdb\\n\\x05\\xec\\xb5R\\xe4H\\xb3G\\xad\\xc2\\xc9\\x17\\x0f\\xa2\\xf3')\n    X3=bytes_to_long('\\xd5\\xc8\\xd6\\xdcX>\\xcd\\xf3\\xc3!f;\\xa3*\\xe4\\xab\\x1c\\x9a-\\xedg\\x02i\\x19\\x93\\x18B\\t\\xe99\\x14\\xf0\\xd5\\xad\\xf4\\x15cG\\x88\\xd5\\x91\\x9d\\x84\\xa8\\xd7t)\\x95\\x9d@\\xfb\\xa4{)\\xcfp\\xb9C\\x12B\\x17\\xc9\\xa41')\n    rsa_key=genKey(X1,X2,X3)\n    key= PKCS1_v1_5.new(rsa_key)\n    with open('flag.enc','rb') as f:\n        return key.decrypt(f.read(),'')\n\nif __name__=='__main__':\n    print solve()[:-1]\n```\n\n注：这里之所以猜测e为65537而不是3是因为$r_{i}<e,i=1,2$，如果e=3可能情况太少。\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n0ctf{Keep_ca1m_and_s01ve_the_RSA_Eeeequati0n!!!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-SM","url":"/crypto/Attack-and-Defend-World-Cryptography-SM.html","content":"## 一、题目信息\n\n附件中包含一个Python脚本sm.py，3个文本文件。\n\n## 二、分析\n\n读完一遍sm.py后，可以确定解题的思路是先由ps与r解出bchoose，再由bchoose按照同样的过程计算出密钥key，最后进行AES解密求出flag。首先看生成r的代码：\n\n```Python\nr=0\nfor i in range(512):\n    if bchoose[i]=='1':\n        r=r^ps[i]\n```\n\n即$r=\\sum_{i=1}^{512}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$(此处的加法是异或)；虽然生成方式类似背包加密，但是由于ps具有很好的性质，我们不使用破解背包加密的方法来解此题；我们来分析生成ps的gen512num函数：\n\n```Python\ndef gen512num():\n    order=[]\n    while len(order)!=512:\n        tmp=randint(1,512)\n        if tmp not in order:\n            order.append(tmp)\n    ps=[]\n    for i in range(512):\n        p=getPrime(512-order[i]+10)\n        pre=bin(p)[2:][0:(512-order[i])]+\"1\"\n        ps.append(int(pre+\"0\"*(512-len(pre)),2))\n    return ps\n```\n\norder是1,2,...,512的一个随机的排列，对ps[i]:首先生成一个长度为512-order[i]+10的素数，去掉此素数的最后10位，同时在尾部追加一个二进制位1，最后在后面填充0使得长度为512；我们首先考虑生成r的最后1个二进制位，ps中只有1个数最后1位为1，其余数最后1位均为0，那么最后1位为1的数如果没有“加入”异或运算，那么r的最后1位一定为0，否则，一定为1，这样我们通过r的最后1位就可以推断出bchoose的第j位(记order[j]=1)。接下来，$r\\oplus (\\textrm{bchoose[j]}\\cdot \\textrm{ps[j]})=\\sum_{i\\neq j}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$，在{ps[i]| i$\\neq$j}中，只有1个数倒数第2位为1，同理，可推断出bchoose的第k位(记order[k]=2)，直到推断出bchoose所有位。\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\n\ndef cal_k():\n    with open('ps','r') as f:\n        ps=[long(x) for x in f.read().split('\\n')[:-1]]\n    with open('r','r') as f:\n        r=long(f.read())\n    pbits=[bin(x).rfind('1')-2 for x in ps]\n    bc=['0']*512\n    for le in range(512):\n        ind=pbits.index(511-le)\n        tt=bin(r)[2:].rjust(512,'0')[511-le]\n        if tt=='1':\n            bc[ind]='1'\n            r^=ps[ind]\n    return long(''.join(bc),2)\n\ndef solve():\n    with open('ef','rb') as f:\n        ef=b64decode(f.read())\n    key=long_to_bytes(int(md5(long_to_bytes(cal_k())).hexdigest(),16))\n    aes_obj = AES.new(key, AES.MODE_ECB)\n    return aes_obj.decrypt(ef)\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{shemir_alotof_in_wctf_fun!}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decode_The_File","url":"/crypto/Attack-and-Defend-World-Cryptography-DECODE-THE-FILE.html","content":"## 一、题目信息\n\n附件是一个文本文件，里面有658行base64编码。\n\n## 二、分析\n\n先将附件中每行base64编码进行解码，得到一个Python脚本。但其实信息并非隐藏在解码后的数据中，而是隐藏在编码中。首先介绍[base64编码的原理](https://chu-kangming.gitee.io//tech/B32-64-encode-explanation.html)，当需要编码的数据剩下1或2字节时，编码与解码过程如下：\n{% asset_img 1.png pic1 %}\n\n\n可以看到，即使$a_{i} \\neq 0$，解码过程也能正确进行；从而可以使用$a_{i}$传递一些信息。因此，只要我们将编码中的$a_{i}$提取出来，就可以解出flag。\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom string import uppercase,lowercase,digits\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('encode','r') as f:\n        codes=f.read()\n    Lc=codes.split('\\n')[:-1]\n    base=uppercase+lowercase+digits+'+/'\n    re2=[]\n    for code in Lc:\n        if '==' in code:\n            re2.append(bin(base.find(code[-3]))[2:].rjust(6,'0')[2:])\n        elif '=' in code:\n            re2.append(bin(base.find(code[-2]))[2:].rjust(6,'0')[4:])\n    ret=''.join(re2)\n    return long_to_bytes(long(ret[:ret.rfind('1')+1],2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nROIS{base_GA_caN_b3_d1ffeR3nT}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-简单流量分析","url":"/crypto/Attack-and-Defend-World-Cryptography-Simple-Traffic-Analysis.html","content":"## 一、题目信息\n\n题目背景：运维人员在日常安全检查的时候发现现场某设备会不时向某不知名ip发出非正常的ICMP PING包。这引起了运维人员的注意，他在过滤出ICMP包分析并马上开始做应急处理很可能已被攻击的设备，附件给出可疑流量包。\n\n## 二、分析\n\n流量分析题，分析的方法基本上有：binwalk、查找一些可疑字符串或16进制数据，排序流量包的长度(最长的流量包一般很可疑)；当我们对流量包的长度进行排序时，发现流量包最短90字节，最长也不过164字节，其中的data段数据长度从48到122，而ascii表中第48至122个字符为0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz，于是将每个流量包的长度转换为对应字符，然后连接成一段长字符串，看上去像base64编码，对字符串进行base64解码即可!\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom pyshark.capture.file_capture import FileCapture\nfrom base64 import b64decode\nfrom sys import argv\n\ndef solve(file_name):\n    packets=FileCapture(input_file=file_name)\n    res=''\n    for packet in packets:\n        for pkt in packet:\n            if pkt.layer_name=='icmp' and int(pkt.type,16):\n                res+=chr(int(pkt.data_len))\n    return b64decode(res)\n\nif __name__=='__main__':\n    print solve(argv[1])\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py fetus_pcap.pcap\n::\\nmongodb:!:17843:0:99999:7:::\\nubuntu:$6$LhHRomTE$M7C4n84UcFLAG{xx2b8a_6mm64c_fsociety}::\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-shanghai","url":"/crypto/Attack-and-Defend-World-Cryptography-Shanghai.html","content":"## 一、题目信息\n\n题目给出提示“维吉利亚密码”，密文在附件中。\n\n## 二、分析\n\n由于维吉利亚密码加密时密钥重用，导致可通过分析密文进行破解；由于明文中存在一些出现频率很高的单词：the,and,for,with等等，因此很有可能这些单词再次被同样的密钥加密，从而生成同样的密文，其间隔一定是密钥长度的倍数，因此可通过对密文进行分析得到密钥的长度；另外，由于这些密文对应着那些出现频率高的明文，因此可破解出密钥；自己写了一个[工具](https://gitee.com/chu-kangming/CTFs-Crypto/tree/tool/TRA/Virginia-analysis)来求解这类问题。\n\n## 三、解题\n\n如下是我使用工具的解题过程，注释是我自己加的，并非程序的输出\n```Bash\n$ python solve.py shanghai.txt\n# 先寻找密文中多次出现(本程序设定的至少3次)的词汇，并计算它们之间的距离，这有助于分析出密钥的长度\nword:  bju\ndistance:  [1078, 2222, 154, 814, 132, 264]\nthe minimum distance:  132\n\nword:  glv\ndistance:  [660, 408, 186, 374, 88, 66, 836, 44, 649, 110, 880, 88, 209, 66]\nthe minimum distance:  44\n\nword:  vxz\ndistance:  [1936, 154, 264, 253, 121, 517, 154, 440, 11, 220, 66]\nthe minimum distance:  11\n\nword:  bni\ndistance:  [22, 979, 2002, 583, 165, 132, 22]\nthe minimum distance:  22\n\nword:  xpg\ndistance:  [11, 396, 660, 2409, 11, 374, 37, 51, 572]\nthe minimum distance:  11\n\nword:  jcm\ndistance:  [1595, 88, 99, 297, 781, 11, 22, 110, 66, 231, 627]\nthe minimum distance:  11\n\nword:  zlr\ndistance:  [286, 583, 583, 154, 22, 154, 22, 407, 55, 396, 1155]\nthe minimum distance:  22\n\nword:  klm\ndistance:  [594, 308, 605, 2145, 231, 297, 44, 44, 198]\nthe minimum distance:  44\n\nword:  mfr\ndistance:  [44, 99, 99, 715, 1884, 536]\nthe minimum distance:  44\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  tyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  yiz\ndistance:  [165, 968, 550, 275, 220, 2167, 246, 106]\nthe minimum distance:  106\n\nword:  opk\ndistance:  [66, 1342, 385, 11, 1771, 583, 374]\nthe minimum distance:  11\n\nword:  tyi\ndistance:  [165, 968, 488, 62, 275, 220, 37, 1639, 491, 352]\nthe minimum distance:  37\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  pkv\ndistance:  [297, 33, 407, 1221, 572, 88]\nthe minimum distance:  33\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  xui\ndistance:  [638, 682, 77, 154, 55, 649, 363, 143]\nthe minimum distance:  55\n\nword:  tui\ndistance:  [55, 1628, 154, 286, 787, 797]\nthe minimum distance:  55\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n#到此我们应该也能看出，密钥的长度为11\n#接下来，进行已知明文攻击\n```\n```Bash\n#密文中有一段：frxnimp 1914 qil 1940，猜测是between 1914 and 1940\nplaintext:betweenand\ncipher:frxnimpqil\npossible key:enereicqvi len:10\n#如果需要更多的明-密文对分析，则输入y；否则，已计算出密钥，则可以进行解密你需要解密的内容\ntry more plain-cipher(y) or start decrypt(n)y\nplaintext:the\ncipher:opk\npossible key:vig len:3\ntry more plain-cipher(y) or start decrypt(n)n\nkey:enereicqvig\ncipher:jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}'\nfgyf, '{' rnh 'jacpnzpdzszsjupanwglh' ebv '}'\ndpps, '{' erb 'xfpnligqmwtgohnywntyl' ypa '}'\nbnyj, '{' ref 'rtuajgphzjxacmawuwkly' cjo '}'\nolws, '{' irs 'vnifwenqqwkewafjsutcl' pni '}'\ntyuq, '{' rif 'irctbrloznxrautofsrlc' cam '}'\nhdho, '{' prw 'vegnpwymxwoenynckfpjl' tnz '}'\nbrmb, '{' npf 'mrtrjkdzvuxvalrwykchj' cem '}'\nflag, '{' and 'vigenereisveryeasyhuh' and '}'\nspuu, '{' fab 'trxrailsnftcaprnwsvzu' ylm '}'\nfcyo, '{' tfo 'rpginvpmbkgayyiajwpnz' ljk '}'\nwpls, '{' ntt 'enereicqvylnwwrrwjthn' qwi '}'\n```\n\n解出flag为flag{vigenereisveryeasyhuh}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-OldDriver","url":"/crypto/Attack-and-Defend-World-Cryptography-OldDriver.html","content":"## 一、题目信息\n\n附件是一份密文，其中包含10组RSA密钥-密文对。\n\n## 二、分析\n\nRSA秘钥的指数e=10，这些特征暗示低加密指数广播攻击；当加密一份消息给多人时，$c_{i}=m^{e} \\ \\textrm{mod}\\ N_{i},i=1,\\cdots,k$，当$k \\geq e$时，可由中国剩余定理求解$m^{e}$，再开方即得明文$m$。\n\n## 三、解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import mpz,iroot\n\ncip_keys=[\n{\"c\": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, \"e\": 10, \"n\": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803},\n{\"c\": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, \"e\": 10, \"n\": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193},\n{\"c\": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, \"e\": 10, \"n\": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623},\n{\"c\": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, \"e\": 10, \"n\": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723},\n{\"c\": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, \"e\": 10, \"n\": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493},\n{\"c\": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, \"e\": 10, \"n\": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949},\n{\"c\": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, \"e\": 10, \"n\": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043},\n{\"c\": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, \"e\": 10, \"n\": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047},\n{\"c\": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, \"e\": 10, \"n\": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553},\n{\"c\": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, \"e\": 10, \"n\": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}\n]\n\ncips=[]\nkeys=[]\n\nfor cip_key in cip_keys:\n\tcips.append(cip_key['c'])\n\tkeys.append(cip_key['n'])\n\nsol=crt(cips,keys)\nmsg,flag=iroot(mpz(str(sol)),mpz(str(10)))\nprint msg\nprint flag\nprint long_to_bytes(long(msg))\n```\n\n程序运行效果如下：\n\n```Bash\n$ sage wp.sage\n854589733786598088127099154138504953368140761371523704656865879247874533963639770706597129057405\nTrue\nflag{wo0_th3_tr4in_i5_leav1ng_g3t_on_it}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decrypt-the-Message","url":"/crypto/Attack-and-Defend-World-Cryptography-Decrypt-the-Message.html","content":"## 一、题目信息\n\n题目要求我们解密附件中的信息；打开附件，里面是一首诗，最后给出需要解密的信息。\n\n## 二、分析\n\n此题考察[Poem加密](http://wmbriggs.com/post/1001/)；举例说明加密过程。\n诗：for my purpose holds to sail beyond the sunset, and the baths of all the western stars until I die.\n明文：We have run out of cigars, situation desperate.\n从诗中选择5个词for,sail,all,stars,die，将这些词中的每个字母排序(相同的不合并)，即：\n```Bash\n f  o  r  s  a  i  l  a  l  l  s  t  a  r  s  d  i  e\n 6 12 13 15  1  7  9  2 10 11 16 18  3 14 17  4  8  5\n```\n上表共有18个字母，将明文以18个字母一组分成若干行，最后一行未满之处用a,b,...进行填充，即\n```Bash\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n w e h a v e r u n o  u  t  o  f  c  i  g  a\n r s s i t u a t i o  n  d  e  s  p  e  r  a\n t e a b c d e f g h  i  j  k  l  m  n  o  p\n```\n\n再根据第一个表将各列置换，即eud tdj ...，最后连接起来生成密文。\n\n破解的思路就是从诗中穷举各种取词情况，然后进行解密，然后选择可读的“明文”，已有人写好破解的[工具](https://github.com/abpolym/crypto-tools/tree/master/poemcode)\n\n## 三、解题\n\n将诗与密文分别存为poem.txt，cip.txt并移到与poemcode.py同目录下，使用工具破解：\n\n```Bash\n$ python poemcode.py poem.txt cip.txt\n...\nifytuothikcrnyptorapyisheansnweroyoturprbletheyoulodnotnowkwhatourrobemiuasbcdfgheijklnoprst\nifyouthinkcryptographyistheanswertoyourproblemthenyoudonotknowwhatyourproblemisabcdefghijklmnopqrstu\npakprictiyorhftyselorohyphurbeewterunhwooaywtooonrbpofjhsgkeilncmbrt\n...\n```\n中间的为明文。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析1","url":"/crypto/Attack-and-Defense-World-Cryptography-Industrial-Protocol-Analysis-1.html","content":"## 一、 题目信息\n\n工业网络中存在异常，尝试通过分析PCAP流量包，分析出流量数据中的异常点，并拿到FLAG。flag形式为 flag{}，流量包在附件。\n\n## 二、分析\n\n将流量包的长度排序(由大到小)，第一个流量包的长度为10120，比第二长的流量包超过太多，猜测有问题；一段乱码之后，data=\"data:image/png;base64,后面是一段很长的base64编码。\n\n## 三、解题\n\n先将流量包中的base64编码复制到文本文件data.txt中，再进行解码，最后将解码的数据写入png文件，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\n\nwith open('data.txt','r') as f:\n    da=f.read()\n\ndata=b64decode(da)\n\nwith open('flag.png','w') as g:\n    g.write(data)\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-fanfie","url":"/crypto/Attack-and-Defense-World-Cryptography-fanfile.html","content":"## 一、题目信息\n\n附件是一个文本文件，里面是一段长34的字符串。\n\n## 二、分析\n\n文本中的字符串看上去像base32编码，加填充后解码得乱码；很多时候比赛的名称是解密的谜面，对字符串BITSCTF进行base32编码得字符串IJEVIU2DKRDA====，与文本中的字符串MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI进行对比，发现字符I两次对应M，猜测是移位密码或仿射密码，加密运算的有限集为{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,2,3,4,5,6,7}，不理解的可以参见[对base编码的介绍](https://www.cnblogs.com/coming1890/p/13503574.html),尝试之后得加密方式为仿射密码，求得解密式为$x=5y+12\\ \\textrm{mod}\\ 32$。\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b32decode\n\ndef solve():\n    s='MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'\n    dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n    msg=''.join([dic[(5*dic.find(x)+12)%32] for x in s])\n    return b32decode(msg+'='*(8-len(msg)%8))\n\nif __name__=='__main__':\n    #python solve.py\n    print solve()\n```\n\n运行程序得如下结果：\n```Bash\n$ python solve.py\nBITSCTF{S2VyY2tob2Zm}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-ecb,_it’s_easy_as_123","url":"/crypto/Attack-and-Defend-World-Cryptography-ECB-it-is-easy-as-123.html","content":"## 一、题目信息\n\n附件提供了背景介绍(Somebody leaked a still from the upcoming Happy Feet Three movie, which will be released in 4K, but Warner Bros. was smart enough to encrypt it. But those idiots used a black and white bmp format, and that wasn't their biggest mistake. Show 'em who's boss and get the flag.)，与一个bmp文件。\n\n## 二、分析\n\n根据背景介绍，原图片应该是bmp格式，经ecb工作模式加密得ecb.bmp；由于ecb工作模式不会掩盖明文的统计规律，因此只要能够修复ecb.bmp就可以见到明文，要修复ecb.bmp，则要求文件的前128字节为bmp文件格式特有的字节。\n\n## 三、解题\n\n将ecb.bmp的前128字节替换为bmp文件格式特有的字节，则可以见到明文信息，实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\nwith open('ecb.bmp','rb') as f:\n    data=f.read()\npre=0x424d76483f00000000007600000028000000000f000070080000010004000000000000483f00000000000000000000000000000000000000000000008000008000000080800080000000800080008080000080808000c0c0c0000000ff0000ff000000ffff00ff000000ff00ff00ffff0000ffffff00ffffffffffffffffffffL\nout=long_to_bytes(pre)+data[128:]\n\nwith open('out.bmp','wb') as g:\n    g.write(out)\n```\n\nout.bmp可被照片查看器打开，从而见到flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-safer-than-rot13","url":"/crypto/Attack-and-Defend-World-Cryptography-Safer-Than-Rot13.html","content":"## 一、题目信息\n\n附件是一个文本文件，题目名称safer-than-rot13。\n\n## 二、分析\n\n由题目名称safer-than-rot13，先对密文进行rot13置换；依然看不出任何逻辑，再进行词频分析,找到flag。\n\n## 三、解题\n\n对密文进行rot13置换：\n\n```Bash\ncat cry100 | tr A-Za-z N-ZA-Mn-za-m > dec100\n```\n\n再进行[词频分析](https://quipqiup.com/)，找到flag为NO THIS IS NOT CRYPTO MY DEAR。","tags":["xctf"],"categories":["crypto"]},{"title":"ctf密码学常用python库","url":"/crypto/CTF-cryptography-uses-Python-libraries.html","content":"## 一、pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n这个库是实现各种算法和协议的密码模块的集合，包含Cipher，Hash，Protocol，PublicKey，Signature，Util这些子包；\n\n### 1.1 Cipher子包\n\n实现了分组加密(AES，DES，DES3，CAST，Blowfish，RC2)，流加密(RC4，XOR)与公钥加密(RSA PKCS#1与PKCS#1 OAEP，这两个区别在于加密前对数据的填充不同)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nkey = b'Sixteen byte key'\niv = Random.new().read(AES.block_size)\ncipher = AES.new(key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\nprint msg.encode('hex')\n```\n\n有时在解RSA的题时，已经知道了密钥，解出来的flag却是乱码，也许是加了一些填充如OAEP，PKCS#1导致的；这时就需要使用对应的秘钥解密；如下是一个PKCS#1填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度-11\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom gmpy2 import invert\nfrom base64 import b64decode\n\ncip='bT633yPu4dOHEL66eKCHjg6cZb09CElt2mSSQZkRDHk='\n\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461L\ne=65537L\n#http://factordb.com/\np=275127860351348928173285174381581152299L\nq=319576316814478949870590164193048041239L\nphi=(p-1)*(q-1)\nd=invert(e,phi)\n\nprivkey=RSA.construct((n,e,long(d),p,q))\n\n#原生RSA\nprint privkey.decrypt(b64decode(cip))\n\n#PKCS#1填充\nkey= PKCS1_v1_5.new(privkey)\nprint key.decrypt(b64decode(cip),'')\n```\n\n再举个OAEP填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度减去41；你可以试一下在下面代码中的明文中多加一个字符运行就会报错。\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom base64 import b64encode,b64decode\n\nrsa_key=RSA.generate(1024)\nkey=PKCS1_OAEP.new(rsa_key)\ncip=b64encode(key.encrypt('PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}abcdef'))\nprint cip\n\nmsg=key.decrypt(b64decode(cip))\nprint msg\n```\n\n### 1.2 Hash子包\n\n实现了哈希算法(MD2，MD4，MD5，RIPEMD，SHA，SHA224，SHA256，SHA384，SHA512，HMAC，hashalgo)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Hash import MD2\nh = MD2.new()\nh.update(b'Hello')\nprint h.hexdigest()\n```\n\n但是没有实现SHA1，要使用SHA1，需要导入hashlib库，正好验证一下Google之前给出的求得两个 sha1 值一样的pdf对：https://shattered.io/\n\n```Python\nfrom hashlib import sha1\n\nwith open('shattered-1.pdf','rb') as f1:\n    da1=f1.read()\nwith open('shattered-2.pdf','rb') as f2:\n    da2=f2.read()\n\nprint sha1(da1).hexdigest()\nprint sha1(da2).hexdigest()\n```\n\n### 1.3 PublicKey子包\n\n实现了公钥加密和签名算法(RSA，DSA，ElGamal)；文档给出的例子：\n\n```Python\nfrom Crypto.PublicKey import RSA\nkey0 = RSA.generate(2048)\nwith open('mykey.pem','w') as f:\n    f.write(key0.exportKey('PEM'))\n\nwith open('mykey.pem','r') as g:\n    key = RSA.importKey(g.read())\n```\n\n### 1.4 Util子包\n\n实现了各种有用的模块和功能(Util.number：数论函数，Util.randpool：随机数生成，Util.RFC1751：在128位键和可读的字串之间进行转换，Util.asn1：对ASN.1 DER编码的最小支持)；自己写个例子如下：\n\n```Python\nfrom Crypto.Util import number\ns='this is a demo'\n#字节转换为long型整数\nls=number.bytes_to_long(s)\n\nbits=8*len(s)\n#生成长度为bits的素数\ngp=number.getPrime(bits)\n\n#生成长度小于bits的随机数\ngri=number.getRandomInteger(bits)\n \n#生成长度为bits的随机数\ngrnbi=number.getRandomNBitInteger(bits)\n \n#生成长度不超过bits的随机数\ngrn=number.getRandomNumber(bits)\n \n#生成grn与2*grn之间的随机数\ngrr=number.getRandomRange(grn,2*grn)\n\n#生成强的素数（gsp-1，gsp+1均至少具有一个大的素因子）\ngsp=number.getStrongPrime(1024)\n\n#计算gri在模grn下的逆\niin=number.inverse(gri,grn)\n\n#判断iin是否为素数\nip=number.isPrime(iin)\n\n#long型整数转换为字节\ntb=number.long_to_bytes(ls)\n```\n\n由于这个库很多函数都很有用，因此我们直接使用\n```Python\nfrom Crypto.Util.number import *\n```\n来导入这个包的所有函数。\n\n## 2. pwntools库\n\n```Bash\npip3 install pwntools -i https://pypi.douban.com/simple\n```\n\n这个库内容很多，只介绍比赛中用到的。\n\n### 2.1 mbruteforce函数\n\n多线程穷举函数，详细定义如下：mbruteforce(func, alphabet, length, method='upto', start=None, threads=None)，其中，\n* func输入参数为字符串，输出布尔值，mbruteforce穷举直到func输出True；\n* alphabet为组成输入参数字符串的字符集合；\n* length指定输入参数字符串的长度上界；\n* method默认为'upto'，指定穷举的字符串长度从1增大到length；另外两个选项为'fixed'、'downfrom'，fixed'指定穷举的字符串长度仅为ength，'downfrom'指定穷举的字符串长度从length减小到1；\n* start=(N,i)，就是把搜索空间分成N块从第i块开始穷举；默认为(1,1)\n* threads指定穷举时的线程数，默认值是内核的数量；\n\n举个例子：\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\nmbruteforce(lambda x: x == 'hello','helo',5,method='fixed')\n```\n\n### 2.2 remote类\n\n用来与服务器交互；常用函数的用法注释到如下脚本中。\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\n\n#创建到远程主机的TCP或udp连接，主机为cn.bing.com，连接主机的端口为443\n#ssl=True代表用SSL包装套接字\nr=remote('cn.bing.com',443,ssl=True)\n\n#向主机发送数据，只不过数据只能是一行\nr.sendline('GET /')\n\n#向主机发送数据，数据可以是多行\nr.send(b'\\r\\n\\r\\n')\n\n##上面两行代码等价于r.send(b'GET /\\r\\n\\r\\n')\n\n#从主机接收4个字节的数据\nre=r.recvn(4)\nprint re\n\n#从主机一直接收数据直到'Please'出现\nre=r.recvuntil('Please')\nprint re\n\n#从主机一直接收数据，最多接收4096字节\nre=r.recv()\nprint re\n\n#关闭连接\nr.close()\n```","tags":["ctf","python"],"categories":["crypto"]},{"title":"RSA攻击大全及其实现","url":"/crypto/RSA-attack-Daquo-and-its-implementation.html","content":"## 一、RSA攻击大全\n\n### 1.1 模数分解\n\n* Small q：模数N有小素数因子；\n* fermat：模数N的因子p与q非常接近；\n* 模不互素：给出多组公钥，但是其中的模数共用了素因子；\n\n### 1.2 针对指数进行攻击\n\n* 小公钥指数攻击：指数很小；\n* 低加密指数广播攻击：相同的消息发送给多个接收者，且加密指数较低；\n\n### 1.3 针对私钥进行攻击\n\n* 维纳攻击：指数很大(理论上$d<N^{0.25}$此攻击起作用)；\n* Boneh-Durfee攻击：同样针对指数很大的情形，理论上$d<N^{0.29}$此攻击起作用；\n\n### 1.4 Coppersmith相关攻击\n\nCoppersmith算法用于求解模$N$多项式$F(X)$($X$为单变量、二元变量甚至多元变量)所有小整数根($\\big\\|X\\big\\|<cN^{\\beta^{2}/\\delta}$，其中$\\delta$为多项式$F$的次数，假设$N$具有不小于$N^{\\beta}$的因子)\n\n* 明文高位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其高位$m_{b} \\cdots m_{t+1}$泄露，记$m'=m_{b} \\cdots m_{t+1}0 \\cdots 0$，则$m'$已知，但$\\Delta m=m_{t} \\cdots m_{1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其高位$p_{b} \\cdots p_{t+1}$泄露，记$p'=p_{b} \\cdots p_{t+1}0 \\cdots 0$，则$p'$已知，但$\\Delta p=p_{t} \\cdots p_{1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 明文低位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其低位$m_{t} \\cdots m_{1}$泄露，记$m'=m_{t} \\cdots m_{1}$，则$m'$已知，但$\\Delta m=m_{b} \\cdots m_{t+1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+2^{t}X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其低位$p_{t} \\cdots p_{1}$泄露，记$p'=p_{t} \\cdots p_{1}$，则$p'$已知，但$\\Delta p=p_{b} \\cdots p_{t+1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+2^{t}X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n[GithHub实现链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n## 二、攻击工具\n\n### 2.1 RsaCtfTool\nGitHub链接：[RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)\n\n在Ubuntu18.04下的安装RsaCtfTool(进入RsaCtfTool目录下)：\n\n```Bash\napt install -y libgmp-dev\napt install -y libmpfr-dev\napt install -y libmpc-dev\npip3 install gmpy2 -i https://pypi.douban.com/simple\npip3 install -r requirements.txt -i https://pypi.douban.com/simple\n```\n\n### 2.2 yafu\n\n我认为最强大的分解因子的工具。\n\n### 2.3 在线分解因子网站\n\n[factordb](http://factordb.com/)","tags":["rsa"],"categories":["crypto"]},{"title":"b32&64encode详解","url":"/tech/B32-64-encode-explanation.html","content":"以前只是用这些函数，从没想过这些编码的原理；还是因为一道ctf题让我好好的了解了一下这些编码方式！\n\n## 一、b32encode\n\n我们知道每个字节是8比特，b32encode将5个字节分成8块，每块前三位补0，从而将5个字节扩展为8个字节；那么扩展后的每个字节的值不超过32，与32个字符\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"对应，有时我们发现编码的字符串中还有\"=\"这个字符，但是它是填充字符，以上就是b32encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,digits\nfrom base64 import b32encode\n\ndef my_b32encode(s):\n    base=uppercase+digits[2:8]\n    assert(len(s))==5\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==40\n    sbs=[bs[5*ind:5*(ind+1)] for ind in range(8)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b32encode('BITSC')\n    print b32encode('BITSC')\n```\n\n## 二、b64encode\n\nb64encode将3个字节分成4块，每块前两位补0，从而将3个字节扩展为4个字节；那么扩展后的每个字节的值不超过64，与64个字符 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"对应，同样地，\"=\"作为填充字符，以上就是b64encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,lowercase,digits\nfrom base64 import b64encode\n\ndef my_b64encode(s):\n    base=uppercase+lowercase+digits+'+/'\n    assert len(s)==3\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==24\n    sbs=[bs[6*ind:6*(ind+1)] for ind in range(4)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b64encode('BIT')\n    print b64encode('BIT')\n```","tags":["encode"],"categories":["tech"]},{"title":"WMCTF2020密码学部分详解","url":"/crypto/WMCTF2020-Cryptography-Part-Detail.html","content":"比赛网址：[WMCTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=146&hash=684a58cc-1140-4937-99f2-ef347d777d9f.event)\n\n## 一、piece_of_cake\n\n### 1.1 题目信息\n附件是一个py脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/piece_of_cake)中的task.py。\n\n### 1.2 分析\n\neat_cake函数中的各个变量的定义如下：\n\n* $p,q$为512位随机素数，$ph=(p-1) \\cdot (q+1),N=p \\cdot q,d=e^{-1}\\ \\textrm{mod}\\ ph$\n\n* $cake$为768位随机素数，$q$重新赋值为1536位随机素数，将$d$的值赋给$f$，$g$为随机素数，$g$的位数等于$q$的位数减去$f$的位数再减去1\n\n* $h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$，$r$为512位随机素数，$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n由：\n$$\nh=f^{-1} \\cdot g\\ \\textrm{mod}\\ q\n$$\n可得：\n$$\nf \\cdot h \\equiv g\\ \\textrm{mod}\\ q\n$$\n即存在$t\\in Z$，使得：\n$$\nf \\cdot h-t \\cdot q=g\n$$\n构造矩阵$M$如下：\n$$\nM=\\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix}\n$$\n则有：\n$$\n\\begin{pmatrix}\nf & -t\n\\end{pmatrix} \\cdot \\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix} = \\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$$\n则$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$是格$L(M)$上的短格基，因此有可能可使用LLL算法或BKZ算法求出，这里说有可能求出，因为在解题时并不是每次都能找到短格基$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$\n假设我们求出的短格基为$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$，再由公式$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n则：\n\n$$\nf \\cdot c \\equiv f \\cdot (r \\cdot h+cake) \\equiv (r \\cdot g+f \\cdot cake)\\ \\textrm{mod}\\ q\n$$\n\n\n从而：\n\n$$\n(r \\cdot g+f \\cdot cake)= f \\cdot c\\ \\textrm{mod}\\ q\n$$\n\n\n两边模$g$可得：\n\n$$\nf \\cdot cake \\equiv (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n于是：\n\n$$\ncake=f^{-1} \\cdot (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n注意，上面等式中$f^{-1}$是$f$在$g$下的逆，不能与括号内的$f$抵消。\n\n### 1.3 解题\n\n上述链接中的solve.sage为解题的sage脚本。\n\n### 1.4 备注\n\n此exp并不能保证次次成功！不过它的有效性不可否认，上述链接中的test.sage即可验证。\n\n以下是我对test.sage四次的运行结果：\n\n```Bash\n$ sage test.sage\nsuccess! 48 -th\n$ sage test.sage\nsuccess! 2 -th\n$ sage test.sage\nsuccess! 50 -th\n$ sage test.sage\nsuccess! 24 -th\n```\n\n从而验证了解题脚本solve.sage的有效性。\n\n## 二、babySum\n\n### 2.1 题目信息\n\n附件是两个py脚本与一个json文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/babySum)中的task.py与check.py。\n\n### 2.2 分析\n\ntask.py告诉我们生成data中数据的逻辑，其实很好理解：生成$n=120$个150位的随机数，组成数组$A$，从中选$k=20$个相加生成和$s$；\n\n记数组$A=[a_{1},\\cdots,a_{n}]$，check.py读入120个数$b_{1},\\cdots,b_{n}(b_{i}={0,1})$，其中20个为1，另外100个为1，检验$\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$，如果等式成立，就打印出flag。\n\n到这里我们共有3个约束条件：\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\\\\\n\\\\\nb_{i}=0,1;i=1,\\cdots,n\n\\end{cases}\n$$\n遇到这种问题一般转化为格基约减问题，构造矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & a_{1} & 1 \\\\\n  & 1 &   &   & a_{2} & 1 \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & a_{n} & 1 \\\\\n  &   &   &   & -s & -k &\n\\end{pmatrix}\n$$\n\n\n那么$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n即通过格基约减可以求出$b_{1},\\cdots,b_{n}$。\n\n理想很丰满，现实很骨感！\n\n约减后的格基无法达到我们需要的结果！直到看到writeup，这里需要记住一个很有用的技巧，可类比约束优化问题对约束条件的处理，当不满足如下约束条件时\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\n\\end{cases}\n$$\n\n\n\n\n加大“惩罚”，我们重新设计格基矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & N \\cdot a_{1} & N \\\\\n  & 1 &   &   & N \\cdot a_{2} & N \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & N \\cdot a_{n} & N \\\\\n  &   &   &   & -N \\cdot s & -N \\cdot k &\n\\end{pmatrix}\n$$\n其中$N=[\\sqrt{n}]$，此时仍然有$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n然后就是比较玄学的问题，对同一格，改变格基矩阵行的顺序，约减的结果也会不同，官方的writeup就是不断打乱格基矩阵的行，然后进行格基约减；再就是为了更快得到结果，需要进行多线程编程；上述链接中的solve.sage为解题的sage脚本；官方设置的8个线程，我自己改成6个线程，跑了几次，基本上都是20分钟左右出结果。\n\n```Bash\n$ sage solve.sage   \n(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)\ncost time:  0:25:27\n```","tags":["ctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-说我作弊需要证据","url":"/crypto/Attack-and-Defend-World-Cryptography-Need-proof-that-I-cheated.html","content":"## 一、题目信息\n\n题目背景为在一次考试中两名学生作弊，给出他们的RSA公钥，附件两者通信的pcapng流量包。\n\n## 二、分析\n\n鉴于Alice与Bob的密钥位数如此地低，通过yafu或者去[factordb](http://factordb.com/)立马就分解出模数，进而计算出私钥。\n\n用wireshark打开流量包，按下Ctrl+Alt+Shift+T快捷键来追踪TCP流(并保存下来，比如我保存为data.txt)；通过数据格式应该可以确定是base64编码后的数据格式，那么先解码前三个看看编码的数据；\n```Bash\nSEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;\nSEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;\nSEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;\n```\n\nDATA应该是密文，但是另外两个数据也很重要，SEQ是明文的顺序，SIG是对明文的签名；因此对保存的TCP流依次解码，使用Bob的私钥对密文DATA解密，再验证SIG是否为Alice对明文的签名，如果是则放到明文列表的第SEQ位置；\n\n## 三、解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom gmpy2 import invert,powmod\nfrom base64 import b64decode\n\ndef solve():\n    N1=0x53a121a11e36d7a84dde3f5d73cfL\n    N2=0x99122e61dc7bede74711185598c7L\n    e=0x10001L\n#   p1,q1=38456719616722997L,44106885765559411L\n    p2,q2=49662237675630289L,62515288803124247L\n    \n#   phi1=(p1-1)*(q1-1)\n    phi2=(p2-1)*(q2-1)\n#   d1=invert(e,phi1)\n    d2=invert(e,phi2)\n    \n#   rsa_key1=RSA.construct((N1,e,long(d1),p1,q1))\n    rsa_key2=RSA.construct((N2,e,long(d2),p2,q2))\n\n    with open('data.txt','r') as f:\n        data=f.read()\n\n    cips=data.split('\\n')\n    res=['']*len(cips)\n    for cip in cips[:-1]:\n        data=b64decode(cip)\n        seq=int(data[(data.find('= ')+2):data.find(';')])\n        cipher=data[(data.find('x')+1):data.find('L')]\n        sig=data[(data.rfind('x')+1):data.rfind('L')]\n        msg=rsa_key2.decrypt(long(cipher,16))\n        if msg==powmod(long(sig,16),e,N1):\n            res[seq]+=chr(msg)\n    return res\n\nif __name__=='__main__':\n    #python solve.py\n    print ''.join(solve())\n```\n\n运行结果如下：\n\n```Bash\n$ python solve.py\nflag{n0th1ng_t0_533_h3r3_m0v3_0n}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-Easy one","url":"/crypto/Attack-and-Defense-World-Cryptography-Easy-One.html","content":"## 一、题目信息\n\n题目这样描述：“破解密文，解密msg002.enc文件”，并且提供附件下载，附件中有4个文件：encryptor.c、msg001、msg001.enc与msg002.enc。\n\n## 二、分析\n\nencryptor.c向我们展示了加密的原理,\n\n```C\nc = (p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;\n```\n对明文的每个字符p，按照上述代码生成密文c，之后t更新为p，i增1，再加密下一个字符。只不过，当我写了对应的解密程序进行解密时，得到的明文是乱码。\n\n我用encryptor.c重新加密了一遍msg001，发现得到的密文与所给的msg001.enc不同，结合加密程序分析，怀疑t的初值或者k被“做了手脚”，我首先穷举了t的256个初值，发现加密的结果均与msg001.enc不同，那么应该是真正加密所用的k并不是encryptor.c展示的k，所以第一步应该解出真正加密所用的k，根据加密原理，k的每一个字符x都能通过下式求出，也就是考察已知明密文求解密钥。\n\n```Python\nx=(ord(c)-ord(m)-ii*ii)&0xff\nx^=t\n```\n\n## 三、解题\n\n由密文求明文的程序很简单，难点在于你需要先通过msg001、msg001.enc求解出真正加密所用的密钥。\n\n```Python\ndef get_true_key(msg_data,cip_data):\n    xs=''\n    ii,t=0,0\n    for m,c in zip(msg_data,cip_data):\n        x=(ord(c)-ord(m)-ii*ii)&0xff\n        x^=t\n        t=ord(m)\n        ii+=1\n        xs+=chr(x)\n    return xs[:(xs[1:].find(xs[0])+1)]\n\ndef test(msg_data,cip_data,o_k):\n    tt=0\n    cip=''\n    lk=len(o_k)\n    for ii,m in enumerate(msg_data):\n        c=(ord(m)+(o_k[ii%lk]^tt)+ii*ii)&0xff\n        cip+=chr(c)\n        tt=ord(m)\n    return all(x==c for x,c in zip(cip,cip_data))\n\ndef solve():\n    with open('msg001','r') as f:\n        msg_data=f.read().strip()\n    with open('msg001.enc','r') as f:\n        cip_data=f.read().strip()\n    with open('msg002.enc','r') as f:\n        data=f.read().strip()\n    k=get_true_key(msg_data,cip_data)\n    print 'the true key is : ',k\n    o_k=[ord(c) for c in k]\n    assert test(msg_data,cip_data,o_k)\n    t=0\n    msg=''\n    for ii,c in enumerate(data):\n        p=(ord(c)-ii*ii-(o_k[ii%28]^t))&0xff\n        t=p\n        msg+=chr(p)\n    with open('msg002','w') as f:\n        f.write(msg)\n    return msg\n\nif __name__=='__main__':\n#   python solve.py\n    print solve().strip()\n```\n\n解出加密所用密钥，破解密文：\n\n```Bash\n$ python solve.py\nthe true key is : VeryLongKeyYouWillNeverGuess\nThe known-plaintext attack (KPA) is an attack model for cryptanalysis where the attacker has samples of both the plaintext (called a crib), and its encrypted version (ciphertext). These can be used to reveal further secret information such as secret keys and code books. The term \"crib\" originated at Bletchley Park, the British World War II decryption operation. \nThe flag is CTF{6d5eba48508efb13dc87220879306619}\n```\n简要介绍了已知明文攻击之后，后面给出flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-wtc_rsa_bbq","url":"/crypto/Attack-and-Defend-World-Cryptography-WTC-RSA-BBQ.html","content":"## 一、题目信息\n\n附件是一个压缩包，解压之后还是一个压缩包，再解压(禁止套娃!!!)得一个文件夹，里面包含公钥(key.pem)与密文(cipher.bin)信息。\n\n## 二、分析\n\n使用openssl查看公钥信息：\n\n```Bash\nopenssl rsa -pubin -in key.pem -text -modulus\n```\n\n发现模数很大，8587位；本来分解模数无脑丢到yafu里面分解就行，但是几个小时都没有分解出来，去[factordb](http://factordb.com/)也分解不出来；回顾针对RSA的各种攻击，对本题可以使用的剩下Small q,费马分解(p与q接近)，试着用费马分解时分解成功。\n\n## 三、解题\n\n使用工具[RSACTFTool](https://github.com/Ganapati/RsaCtfTool)进行分解,将key.pem与cipher.bin移到与RsaCtfTool.py同目录下：\n\n```Bash\nsudo python3 RsaCtfTool.py --publickey key.pem --uncipherfile cipher.bin --attack fermat\n```\n\n在明文最后给出flag为flag{how_d0_you_7urn_this_0n?}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-banana-princess","url":"/crypto/Attack-and-Defense-World-Cryptography-Banana-Princess.html","content":"## 一、题目信息\n\n附件给出一个PDF文件，但是用阅读器打开显示文件已损坏。\n\n## 二、分析\n\n用vim打开PDF文件，开头为%CQS-1.5，既然是PDF文件，那就找找CQS与PDF的关系，首先想到的是凯撒密码，结果发现这三个字母均在字母表中相隔13，另外PDF文件中的小写字母也需要进行解密替换。\n\n## 三、解题\n使用Shell，一行就可以完成解密：\n\n```Bash\n$ cat cip.pdf | tr A-Za-z N-ZA-Mn-za-m > msg.pdf\n```\n\n结果发现flag被遮住了，另存为图片，flag可见，为BITSCTF{save_the_kid}。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-你猜猜","url":"/crypto/Attack-and-Defend-World-Cryptography-Guess.html","content":"## 一、题目信息\n\n附件是一个文本文件，里面是一串16进制数据。\n\n## 二、分析\n\n504B0304开头一般代表zip数据(另外还有526172211a0701开头代表rar数据，377abcaf271c开头代表7z数据)，于是将这一串16进制数据另存为一个zip文件，不用说，压缩时肯定进行了加密，使用fcrackzip工具进行破解。\n\n## 三、解题\n\n首先使用Python将16进制数据另存为一个zip文件：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\ns=0x504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000\nwith open('data.zip','wb') as f:\n    f.write(long_to_bytes(s))\n```\n\n再使用fcrackzip工具破解密码：\n\n```Bash\n$ fcrackzip -b -c '1' -l 4-8 -u data.zip\n\nPASSWORD FOUND!!!!: pw == 123456\n```\n解密得到flag.txt，里面保存着flag。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-sherlock","url":"/crypto/Attack-and-Defense-World-Cryptography-Sherlock.html","content":"## 一、 题目信息\n\n附件是网页上的一篇文章，先复制到txt中保存。\n\n## 二、分析\n\n如下是文章开头：\n\n```Bash\n(additional editing by jose menendeZ)\n\nthE adventuRes Of\nsherlOck holmes\n\nby\n\nsir arthur coNan doylE\n```\n\n奇怪之处是有些位置不应该使用大写字母，但是使用了大写字母，推断这些大写字母是用来传递消息的。将文章中的所有大写字母提取出来，得到一串全部由ZERO与ONE组成的字符串，ZERO替换为数字0，ONE替换为数字1，从而得到一个二进制表示的数，再将此数转换为字符串即可。\n\n## 三、解题\n\nPython代码如下：\n\n```Python\nfrom string import uppercase\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('paper','r') as f:\n        data=f.read()\n    cip=''\n    for c in data:\n        if c in uppercase:\n            cip+=c\n    cip=cip.replace('ZERO','0')\n    cip=cip.replace('ONE','1')\n    return long_to_bytes(long(cip,2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nBITSCTF{h1d3_1n_pl41n_5173}\n```","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-告诉你一个秘密","url":"/crypto/Attack-and-Defend-World-Cryptography-Tells-you-a-secret.html","content":"## 一、题目信息\n\n附件为两行数字与字母组成的字符串。\n\n## 二、分析\n\n字符串中的字母均未超过E，猜测是16进制编码，于是先将字符串进行16进制解码，解码之后看上去像base64编码，于是接着进行base64解码，得到两段全由字母组成的字符串，并且被空格隔开，每小段字符串包含3-4个字母，解密的方法就在眼前——键盘，每小段字符串的字母围起来的字母就是明文。\n\n## 三、解题\n\nPython代码如下：\n\n```Python\nfrom base64 import b64decode\n\ndef solve():\n    cips=[\n            '636A56355279427363446C4A49454A7154534230526D6843',\n            '56445A31614342354E326C4B4946467A5769426961453067'\n            ]\n    msgs=[]\n    for cip in cips:\n        msgs.append(b64decode(cip.decode('hex')))\n    return msgs\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行程序得到如下结果：\n\n```Bash\n$ python solve.py\n['r5yG lp9I BjM tFhB', 'T6uh y7iJ QsZ bhM ']\n```\n\n接下来在键盘上找每小段字符串的字母围起来的字母，得到flag为tongyuan。","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-flag in your hand","url":"/crypto/Attack-and-Defend-World-Cryptography-Flag-in-Your-Hand.html","content":"## 一、题目信息\n\n题目给了两个文件：index.html与script-min.js。\n\n## 二、分析\n\n先分析index.html的逻辑，第58行：\n\n```HTML\n<input type=\"button\" value=\"Get flag!\" onclick=\"getFlag()\" />\n```\n\n结合浏览器打开index.html的效果，我们知道点击 'Get flag!' 按钮时会调用getFlag()函数；\n\ngetFlag()函数的定义在第32行：\n```JavaScript\nfunction getFlag() {\n\tvar token = document.getElementById(\"secToken\").value;\n\tic = checkToken(token);\n\tfg = bm(token);\n\tshowFlag()\n}\n```\n\n在显示flag之前会调用checkToken(token)与bm(token)两个函数，我们先看一下显示flag的showFlag()函数，它定义在第39行：\n\n```JavaScript\nfunction showFlag() {\n\tvar t = document.getElementById(\"flagTitle\");\n\tvar f = document.getElementById(\"flag\");\n\tt.innerText = !!ic ? \"You got the flag below!!\" : \"Wrong!\";\n\tt.className = !!ic ? \"rightflag\" : \"wrongflag\";\n\tf.innerText = fg;\n}\n```\n\n可以看到是通过ic的布尔值判断我们是否输入正确的token，而ic由函数checkToken(token)返回，跳转到script-min.js中定义函数checkToken的地方看一下：\n\n```JavaScript\nfunction checkToken(s) {\n    return s === \"FAKE-TOKEN\";\n}\n```\n\n难不成FAKE-TOKEN就是正确的token？当然不是，还是抱着希望去试了一下，果然不是！那么问题只能出在函数bm中，它改变了ic的布尔值！\n\n于是去看一下函数bm，它定义如下：\n\n```JavaScript\nfunction bm(s){\n\treturn rb(rstr(str2rstr_utf8(s)));\n}\n```\n\n函数str2rstr_utf8与rb并没有改变ic的布尔值，是rstr调用的函数ck改变了ic的布尔值；函数ck的定义如下：\n\n```JavaScript\nfunction ck(s){\n    try {\n        ic\n    } catch (e) {\n        return;\n    }\n    var a = [118, 104, 102, 120, 117, 108, 119, 124, 48,123,101,120];\n    if (s.length == a.length) {\n        for (i = 0; i < s.length; i++) {\n            if (a[i] - s.charCodeAt(i) != 3)\n                return ic = false;\n        }\n        return ic = true;\n    }\n    return ic = false;\n}\n```\n\n看到这里明白了，checkToken就是个幌子，这里才决定ic布尔值！对函数ic的输入参数(字符串)s，只有s与列表a等长，且s每个字符在ascii表中的序号比列表a中每个对应元素小3时，ic才为True。\n\n于是可以写个python脚本求一下这里会让ic=True的s：\n\n```Python\na=[118,104,102,120,117,108,119,124,48,123,101,120];\nprint ''.join([chr(x-3) for x in a])\n```\n\n得到s为security-xbu字符串。\n\n综上，当函数ck的输入为字符串security-xbu时，会使ic的布尔值为True，从而得到正确的flag；通过分析调用过程，函数ck的输入为str2rstr_utf8(token)，那么token为何值时str2rstr_utf8(token)为字符串security-xbu呢？是不是要写个str2rstr_utf8的逆程序？其实不用，我们将script-min.js中的函数bm改一下，如下：\n\n```JavaScript\nfunction bm(s){\n\t//return rb(rstr(str2rstr_utf8(s)));\n\treturn rb(rstr(s))\n}\n```\n\n刷新index.html，填入security-xbu，就可以得到正确的flag！","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析2","url":"/crypto/Attack-and-Defense-World-Cryptography-Industrial-Protocol-Analysis-II.html","content":"## 一、题目信息\n\n在进行工业企业检查评估工作中，发现了疑似感染恶意软件的上位机。现已提取出上位机通信流量，尝试分析出异常点，获取FLAG。 flag形式为 flag{}。\n\n## 二、分析\n字符串'flag'的16进制编码为0x666c6167，在筛选器输入data contains \"666c61677b\"筛选包含666c61677b的流量包，筛选出两个包。\n\n## 三、解题\n任选一个提取出数据666c61677b37466f4d3253746b6865507a7d，再进行16进制解码得到flag{7FoM2StkhePz}","tags":["xctf"],"categories":["crypto"]},{"title":"攻防世界-密码学-新手练习区","url":"/crypto/Attack-and-Defend-World-Cryptography-Beginner-Practice-Area.html","content":"## 一、Caeser\n\n凯撒密码：替换加密——明文中的所有字母都在字母表上向后按照一个固定数目offset进行偏移后被替换成密文。由于不知道偏移量，因此将每个偏移量都试一下进行解密;事实上，解密过程既可以看作密文中的所有字母都在字母表上向前按照一个固定数目offset进行偏移，也可以看作密文中的所有字母都在字母表上向后按照一个固定数目(26-offset)进行偏移！\n\n如下是解题的Python代码：\n\n```Python\nfrom string import lowercase\n\nclass Caeser():\n    def __init__(self,dic=None):\n        if dic==None:\n            self.dic=lowercase\n        else:\n            self.dic=dic\n\n    def enc(self,msg,ofst):\n        dic=self.dic\n        ld=len(dic)\n        cip=''\n        for c in msg:\n            if c in dic:\n                index=dic.find(c)\n                cip+=dic[(index+ofst)%ld]\n            else:\n                cip+=c\n        return cip\n\ndef solve():\n    msg='oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}'\n    caeser=Caeser()\n    for ii in range(len(caeser.dic)):\n        print caeser.enc(msg,ii)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp1.py\noknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\nplorecrnpr{lbh_unir_yrnearq_pnrfne_rapelcgvba}\nqmpsfdsoqs{mci_vojs_zsofbsr_qosgof_sbqfmdhwcb}\nrnqtgetprt{ndj_wpkt_atpgcts_rpthpg_tcrgneixdc}\nsoruhfuqsu{oek_xqlu_buqhdut_squiqh_udshofjyed}\ntpsvigvrtv{pfl_yrmv_cvrievu_trvjri_vetipgkzfe}\nuqtwjhwsuw{qgm_zsnw_dwsjfwv_uswksj_wfujqhlagf}\nvruxkixtvx{rhn_atox_extkgxw_vtxltk_xgvkrimbhg}\nwsvyljyuwy{sio_bupy_fyulhyx_wuymul_yhwlsjncih}\nxtwzmkzvxz{tjp_cvqz_gzvmizy_xvznvm_zixmtkodji}\nyuxanlawya{ukq_dwra_hawnjaz_ywaown_ajynulpekj}\nzvybombxzb{vlr_exsb_ibxokba_zxbpxo_bkzovmqflk}\nawzcpncyac{wms_fytc_jcyplcb_aycqyp_clapwnrgml}\nbxadqodzbd{xnt_gzud_kdzqmdc_bzdrzq_dmbqxoshnm}\ncyberpeace{you_have_learned_caesar_encryption}\ndzcfsqfbdf{zpv_ibwf_mfbsofe_dbftbs_fodszqujpo}\neadgtrgceg{aqw_jcxg_ngctpgf_ecguct_gpetarvkqp}\nfbehushdfh{brx_kdyh_ohduqhg_fdhvdu_hqfubswlrq}\ngcfivtiegi{csy_lezi_pievrih_geiwev_irgvctxmsr}\nhdgjwujfhj{dtz_mfaj_qjfwsji_hfjxfw_jshwduynts}\niehkxvkgik{eua_ngbk_rkgxtkj_igkygx_ktixevzout}\njfilywlhjl{fvb_ohcl_slhyulk_jhlzhy_lujyfwapvu}\nkgjmzxmikm{gwc_pidm_tmizvml_kimaiz_mvkzgxbqwv}\nlhknaynjln{hxd_qjen_unjawnm_ljnbja_nwlahycrxw}\nmilobzokmo{iye_rkfo_vokbxon_mkockb_oxmbizdsyx}\nnjmpcaplnp{jzf_slgp_wplcypo_nlpdlc_pyncjaetzy}\n```\n\n看上去像句人话的就是cyberpeace{you_have_learned_caesar_encryption}，这就是flag。\n\n## 二、Morse\n\n摩尔斯密码：使用0,1两种状态的二进制代码组合表示字母与数字；解密就是一个查找操作。如下是解题的Python代码：\n\n```Python\n#Morse Code\n\nclass Morse():\n    def __init__(self):\n        self.dic = {'a': '01',     'b': '1000',   'c': '1010',\n                'd': '100',    'e': '0',      'f': '0010',\n                'g': '110',    'h': '0000',   'i': '00',\n                'j': '0111',   'k': '101',    'l': '0100',\n                'm': '11',     'n': '10',     'o': '111',\n                'p': '0110',   'q': '1101',   'r': '010',\n                's': '000',    't': '1',      'u': '001',\n                'v': '0001',   'w': '011',    'x': '1001',\n                'y': '1011',   'z': '1100',   '_': '001101',\n                '0': '11111',  '1': '01111',  '2': '00111',\n                '3': '00011',  '4': '00001',  '5': '00000',\n                '6': '10000',  '7': '11000',  '8': '11100',\n                '9': '11110'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n            cip+=''\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in cip.split():\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'\n    morse=Morse()\n    print morse.dec(cip)\n\nif __name__=='__main__':\n#   python wp2.py\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp2.py\nmorsecodeissointeresting\n```\n\n## 三、不仅仅是Morse\n\n由于得到的数据格式与上一个相同，因此仍然进行Morse解密，解密出\n```Bash\nmay_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba\n```\n\n这还不是明文，提示你还需要一种解码；这种密码是培根密码：替换密码——根据所给表对应转换即可加密解密。\n\n如下是解题的Python代码：\n\n```Python\n#Morse code + Bacon cipher\n\nfrom wp2 import Morse\n\nclass Bacon():\n    def __init__(self):\n        self.dic={'a':'aaaaa','b':'aaaab','c':'aaaba','d':'aaabb',\n                'e':'aabaa','f':'aabab','g':'aabba','h':'aabbb',\n                'i':'abaaa','j':'abaab','k':'ababa','l':'ababb',\n                'm':'abbaa','n':'abbab','o':'abbba','p':'abbbb',\n                'q':'baaaa','r':'baaab','s':'baaba','t':'baabb',\n                'u':'babaa','v':'babab','w':'babba','x':'babbb',\n                'y':'bbaaa','z':'bbaab'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in [cip[5*ii:5*(ii+1)] for ii in range(len(cip)/5)]:\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 01 1011 001101 1000 0 001101 0000 01 0001 0 001101 01 10 111 1 0000 0 010 001101 100 0 1010 111 100 0 0000 0000 0000 0000 01 01 01 01 01 1000 01 01 1000 1000 1000 01 01 1000 1000 01 01 01 01 01 01 01 01 1000 01 01 1000 01 1000 01 01 01 01 01 01 01 1000 1000 01 1000 01 01 01 1000 1000 01 01 01 1000 1000 01 01 1000 01 01 01 01 1000 01 1000 01 01 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 01 1000 01 01 1000 01 1000 1000 01 01 1000 1000 1000 01 1000 01 01 01 1000 01 1000 01 1000 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 01 01 1000 1000 01 1000 1000 01 01 1000 1000 01 01 1000 01 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 1000 01 1000 01 01 1000 1000 01 1000 01 01 01 01 1000 1000 01 1000 01 01 1000 1000 01'\n    morse=Morse()\n    cip=morse.dec(cip)\n    print cip\n    cip=cip[cip.find('hhhh')+4:]\n    bacon=Bacon()\n    print bacon.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp3.py\nattackanddefenceworldisinteresting\n```\n\n## 四、幂数加密\n\n这题实际是云影密码：26个英文字母在字母表中的次序ord(x)<$2^{5}$，因此5位二进制数可以表示一个英文字母，即1,2,4,8,16的组合(求和)可表示一个英文字母，例如L在字母表中的次序为12=4+8，因此组合48就可以表示字母L；同时0作为分隔符。\n\n如下是解题的Python代码：\n\n```Python\ns='8842101220480224404014224202480122'\nls=s.split('0')\ndic='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nm=''\nfor c in ls:\n    t=0\n    for cc in c:\n        t+=int(cc)\n    m+=dic[t-1]\nprint m\n```\n\n运行上述程序：\n\n```Bash\n$ python wp4.py\nWELLDONE\n```\n\n## 五、Railfence\n\n栅栏密码：将明文row个为一组，排列为col行(明文的长度可能小于为row$\\cdot$col，即最后一行可能不会填满)，再将第一列的字母从上至下连接起来，接下来是第二列，直到第row列，生成密文。\n\n但是此题是栅栏密码的一个变种——W型栅栏密码；例如，如下是一个密钥为5的W型栅栏密码，明文为1-19的自然数，将其按照W的形状排列，再由上至下，从左至右连接数字，生成密文[1,9,17,2,8,10,16,18,3,7,11,15,19,4,6,12,14,5,13]。\n\n```Bash\n1             9               17\n  2         8   10          16  18\n    3      7      11      15      19\n      4   6         12  14\n        5             13\n```\n\n如下是解题的Python代码(此题的密钥为5)：\n\n```Python\n#W kind Railfence cipher\n\nclass Railfence_W():\n    def __init__(self,key=2):\n        self.key=key\n\n    def enc(self,msg,mode):\n        #mode = 0 means decrypt,mode = 1 means encrypt\n        ls=len(msg)\n        key=self.key\n        rep=range(0,ls,2*(key-1))\n        for dd in range(1,key-1):\n            ind=dd\n            de1=2*(key-1-dd)\n            de2=2*dd\n            while ind<ls:\n                rep.append(ind)\n                ind+=de1\n                if ind>=ls:\n                    break\n                rep.append(ind)\n                ind+=de2\n        rep.extend(range(key-1,ls,2*(key-1)))\n        if mode:\n            cips=''.join([msg[ii] for ii in rep])\n        else:\n            cip=rep[:]\n            for ii in range(ls):\n                cip[rep[ii]]=msg[ii]\n            cips=''.join(cip)\n        return cips\n\ndef solve():\n    cip='ccehgyaefnpeoobe{lcirg}epriec_ora_g'\n    for step in range(2,8):\n        railfence_w=Railfence_W(step)\n        print railfence_w.enc(cip,0)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp5.py\ncccierhgg}yeaperfinepce_ooorbae_{gl\ncnipceeoeocbhe_{glocyirraga}ee_pfrg\ncal_cecfiornepgr}ehoeapogbr_iey{egc\ncyberpeace{railfence_cipher_gogogo}\ncgecraiioycaore_cgbeefe}_goe{nhplpr\nchfbriaegengcyp{}c__eleaeeocpogrrio\n```\n\n## 六、easychallenge\n\n附件是一个pyc文件，使用uncompyle6进行反编译得到py脚本，脚本中定义了3个编码函数，这3个编码函数都是可逆的，从而可求解出与给定编码数据对应的明文。\n\n如下是解题的Python代码：\n\n```Python\nfrom base64 import b32decode\n\ndef decode1(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)-25\n        x^=36\n        s+=chr(x)\n    return s\n\ndef decode2(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)^36\n        x-=36\n        s+=chr(x)\n    return s\n\ndef decode3(ans):\n    return b32decode(ans)\n\ndef solve():\n    final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='\n    return decode1(decode2(decode3(final)))\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp6.py\ncyberpeace{interestinghhhhh}\n```\n\n## 七、转轮机加密\n\n题目提示托马斯·杰斐逊，搜索一下有一个关于此人的密码——杰斐逊密码：首先，转轮机每一圈有若干字母，共有若干圈；加密时，将转轮机调整至某一列为明文，然后任选其他的某一列，作为密文。因此解密时，转轮机调整至某一列为密文，然后分析其他列，找到语句通顺的就是明文。\n\n如下是解题的Python代码：\n\n```Python\n#Jefferson cipher\n\nclass Jefferson():\n    def __init__(self,key):\n        self.box=[\n                'ZWAXJGDLUBVIQHKYPNTCRMOSFE',\n                'KPBELNACZDTRXMJQOYHGVSFUWI',\n                'BDMAIZVRNSJUWFHTEQGYXPLOCK',\n                'RPLNDVHGFCUKTEBSXQYIZMJWAO',\n                'IHFRLABEUOTSGJVDKCPMNZQWXY',\n                'AMKGHIWPNYCJBFZDRUSLOQXVET',\n                'GWTHSPYBXIZULVKMRAFDCEONJQ',\n                'NOZUTWDCVRJLXKISEFAPMYGHBQ',\n                'XPLTDSRFHENYVUBMCQWAOIKZGJ',\n                'UDNAJFBOWTGVRSCZQKELMXYIHP',\n                'MNBVCXZQWERTPOIUYALSKDJFHG',\n                'LVNCMXZPQOWEIURYTASBKJDFHG',\n                'JZQAWSXCDERFVBGTYHNUMKILOP'\n                ]\n        self.key=key\n\n    def dec(self,cip):\n        box=self.box\n        key=self.key\n        lb=len(box)\n        tbox=[box[x-1] for x in key]\n        assert lb==len(cip)\n        for ii in range(lb):\n            ind=tbox[ii].find(cip[ii])\n            tbox[ii]=tbox[ii][ind:]+tbox[ii][:ind]\n        for ii in range(len(box[0])):\n            print (''.join([x[ii] for x in tbox])).lower()\n\ndef solve():\n    cip='NFQKSEVOQOFNP'\n    key=[2,3,7,5,13,12,9,1,8,10,4,11,6]\n    jefferson=Jefferson(key)\n    jefferson.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp7.py\n...\nsambkvlqsiaav\nfireinthehole\nuzaulcdkfprst\n...\n```\n\n唯一一句人话就是fireinthehole，这就是flag。","tags":["xctf"],"categories":["crypto"]},{"title":"about","url":"/about/index.html","content":"\n姓名：褚康明\n\n籍贯：湖北省孝感市\n\n本科：西安电子科技大学，数学与应用数学\n\n硕士：中国科学院大学信息工程研究所，电子信息\n\n方向：CTF密码学，NLP，代码嵌入"},{"title":"links","url":"/links/index.html","content":"\n[hexo文档](https://hexo.io/zh-cn/docs/)\n\n[hexo 主题大全](https://hexo.io/themes/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[攻防世界](https://adworld.xctf.org.cn)\n\n[pexels](https://www.pexels.com/)\n\n[Gnome-look](https://www.gnome-look.org)\n\n[中文马克思主义文库：毛泽东](https://www.marxists.org/chinese/maozedong/index.htm)\n\n[抗美援朝](http://www.12371.cn/2020/10/12/VIDA1602474174035898.shtml)\n\n\n\n"},{"title":"tags","url":"/tags/index.html"},{"title":"help","url":"/help/index.html","content":"\n**1**这博客很好看，是怎么做的？\n答：本博客使用Hexo制作，采用的jsimple主题，部署在Gitee Pages上，搭建步骤请参考：[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)，也可以多参考[主题作者的README](https://github.com/tangkunyin/hexo-theme-jsimple/blob/master/README.zhCN.md)\n\n**2**部署到Gitee Pages上面时布局一团糟怎么办？\n答：这可能是因为你没有做到`根目录部署`，导致数据索引不到，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客，在最后指出如何正确创建`根目录部署`\n\n**3**Gitee Pages与本地的博客效果不一致是为什么？\n答：因为您没有氪金，单用`hexo deploy`是不会更新Gitee Pages的，还需要手动更新，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客\n\n**4**怎么才能多给我打赏？\n答：好意心领了，我相信千里送鹅毛，礼轻情意重"}]